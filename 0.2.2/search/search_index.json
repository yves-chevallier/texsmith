{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to TeXSmith","text":"<p>TeXSmith turns Markdown into press-ready LATEX. Keep your docs authored in Markdown, then compile polished PDFs for print, journals, or long-form review packages\u2014without maintaining several sources of truth. No need to learn LATEX, install heavy toolchains, or wrestle with complex conversion setups.</p> <p> </p> <p>Furthermore, TeXSmith is optimized for MkDocs thanks to the TeXSmith MkDocs plugin, which seamlessly integrates into your documentation pipeline.</p> <p>Currently in Alpha</p> <p>TeXSmith is currently in Alpha. While we are actively working on it and welcome feedback, please be aware that some features may not be fully stable yet.</p> <p>You can use TeXSmith to generate academic papers, technical reports, letters, minutes, or class materials with diagrams, tables, citations, and more.</p> <p></p>"},{"location":"#why-would-i-use-texsmith","title":"Why would I use TeXSmith?","text":"<p>TeXSmith bridges the gap between lightweight Markdown authoring and the typographic power of LATEX. It is ideal for:</p> <ul> <li>Writing scientific articles.</li> <li>Writing product documentation.</li> <li>Writing books.</li> <li>Writing letters.</li> <li>Writing technical reports.</li> <li>Writing cooking recipes and more.</li> </ul> <p>The combination with MkDocs provides a single source of truth for both web and PDF output, which improves collaboration because all documentation lives in Markdown in a Git repository. Versioning with MkDocs stays simple and natural.</p>"},{"location":"#why-teams-choose-texsmith","title":"Why teams choose TeXSmith","text":"Pipeline parity The CLI and Python API share the same conversion engine,   so automation scripts and ad-hoc conversions stay in sync. Template-friendly Wrap multiple documents into a single LATEX project,   map fragments into template slots, and customise the runtime with Jinja2. Diagnostics you can trust Structured emitter APIs and CLI verbosity   flags surface the context you need when something goes wrong."},{"location":"#how-is-it-different-from-pandoc","title":"How is it different from Pandoc?","text":"<p>Pandoc is a powerhouse, but reproducing an extended Markdown syntax other than CommonMark or GitHub-flavored Markdown document in Pandoc requires custom filters and ongoing maintenance. TeXSmith focuses on MkDocs Markdown with Pymdown extensions, delivering parity out of the box:</p> <ul> <li>Handles Material-only components such as tabbed content, callouts, and   keyboard keys.</li> <li>Ships with diagram converters (Mermaid, Draw.io) that plug directly   into the LATEX build step.</li> <li>Exposes the same primitives via the CLI and Python API, so automation scripts   match what authors do locally.</li> </ul> <p>Use both tools together when it makes sense; reach for TeXSmith when MkDocs \u2192 LATEX compatibility is the priority.</p>"},{"location":"about/","title":"About","text":"<p>TeXSmith was originally created by Yves Chevallier in 2025 to address the need for a seamless workflow between Markdown-based documentation and LATEX-based publishing, initially for his own academic courses at HEIG-VD.</p> <p>Aside from Pandoc\u2014written in Haskell and not directly suited for MkDocs\u2014there were no tools capable of converting MkDocs-flavored Markdown into LATEX while preserving the original content\u2019s semantic intent.</p> <p>Because developing such an ambitious toolchain was a substantial and time-consuming effort, I postponed the project until I discovered the remarkable power of OpenAI Codex, which helped me bootstrap the initial version of TeXSmith in just a few days. I wanted to extract the core MkDocs-to-LATEX code used in my online course and turn it into a standalone, general-purpose tool that anyone needing to convert MkDocs content to LATEX could use. That is how TeXSmith was born.</p>"},{"location":"about/#branding","title":"Branding","text":"<p>This project is not affiliated with TEX, LATEX, or the LATEX Project. It merely produces LATEX-compatible output and interacts with the TEX toolchain in the same way any document-generation utility would. All trademarks belong to their respective owners.</p> <p>By convention within the TEX community, the names TEX and LATEX are used with care. Donald Knuth famously stated:</p> <p>\u201cTEX is not to be changed; only Knuth himself may change TEX.\u201d</p> <p>This is not a legal trademark declaration but a long-standing cultural rule: any system that calls itself TEX must be fully compatible with Knuth\u2019s canonical implementation. Similarly, the LATEX Project requires that only implementations conforming to the LATEX format may use the name LATEX.</p> <p>In keeping with these established norms, this project does not claim to be a TEX or LATEX implementation, nor does it modify or replace them. It is simply a tool that generates LATEX code as output, leaving the actual typesetting to standard, community-maintained engines.</p>"},{"location":"about/author/","title":"Author","text":"<p>I'm Yves Chevallier, the creator and maintainer of TeXSmith. I work full-time as an associate professor at HEIG-VD in Switzerland, where I teach software engineering. My research interests revolve around software architecture, meta-generation, and\u2014naturally\u2014documentation tooling. Before drifting into academia, I trained as an electronics engineer with a focus on real-time embedded systems for motion-control applications.</p> <p>I originally built TeXSmith mostly for fun\u2014and partly to see how far AI-assisted tooling can be pushed. Judging by the pace of progress, this was probably a terrible idea: my job may well be obsolete in a few years.</p>"},{"location":"about/contribute/","title":"Contributing","text":"<p>I welcome contributions from the community to help improve TeXSmith! Whether it's reporting bugs, suggesting new features, or submitting code changes, your input is valuable. Here's how you can contribute:</p> Reporting issues If you encounter any bugs or issues while using TeXSmith, please report them. Suggesting features Have an idea for a new feature or improvement? We'd love to hear it! Submitting code changes If you'd like to contribute code, please fork the repository, make your changes, and submit a pull request. Make sure to follow the coding style and include tests for any new functionality. Improving documentation Help us keep the documentation up-to-date and comprehensive by suggesting edits or additions. Documentation priorities Check the Release Notes &amp; Compatibility page and open issues to see which doc sections need attention when the engine evolves. Develop templates Create and share your own LATEX templates for TeXSmith users to use. <p>TeXSmith is a newly developed project and is not ready for production use yet, but you can test it out and help us improve it.</p>"},{"location":"about/contribute/#run-the-tests","title":"Run the tests","text":"<pre><code>git clone https://github.com/yves-chevallier/texsmith.git\ncd texsmith\nuv sync\nuv run pytest\n</code></pre>"},{"location":"about/contribute/#build-the-documentation-locally","title":"Build the documentation locally","text":"<pre><code>uv sync --group docs\nuv run mkdocs serve\n</code></pre>"},{"location":"about/contribute/#test-ci","title":"Test CI","text":"<p>To test the Continuous Integration (CI) using GitHub Actions, we need <code>act</code> installed on your local machine:</p> <pre><code>curl -s https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash\ngit clone https://github.com/yves-chevallier/texsmith.git\ncd texsmith\nact -j build\n</code></pre> <p>This would require a lot of disk space, as it uses Docker containers to simulate the GitHub Actions environment. Select the medium size image when prompted.</p>"},{"location":"about/license/","title":"License","text":"<p>TeXSmith is licensed under the terms of the MIT License.</p> <p>Copyright (c) 2025 Yves Chevallier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses-and-notices","title":"Third-Party Licenses and Notices","text":"<p>TeXSmith depends on several third-party components. When you redistribute TeXSmith or ship built assets that include any of the items below, you must also follow their licenses and attribution rules.</p> <ul> <li>Bundled/downloaded assets</li> <li>OpenMoji (emoji glyphs and font): CC BY-SA 4.0 for the artwork and SIL Open Font License 1.1 for the font files.</li> <li>Noto fonts (Google): primarily SIL Open Font License 1.1; Noto Color Emoji is Apache License 2.0.</li> <li>IBM Plex: SIL Open Font License 1.1.</li> <li>Python libraries (non-exhaustive) \u2013 Markdown (BSD-3-Clause), PyMdown Extensions (MIT), Beautiful Soup (MIT), Requests (Apache-2.0), Jinja2 (BSD-3-Clause), PyBtex (MIT), TQDM (MIT). Each library carries its own permissive license; see the packages for full texts.</li> <li>External tools invoked but not bundled \u2013 Tectonic (MIT), Mermaid CLI / <code>@mermaid-js/mermaid-cli</code> (MIT), Draw.io CLI (Apache-2.0), latexmk (GPL/Artistic-2.0, distributed with TEX Live), biber/bibtex (per their upstream licenses). Users must comply with these tools\u2019 licenses when installing and running them.</li> </ul> <p>If you distribute TeXSmith together with any of these assets or tools, include the corresponding license texts and attribution files. When in doubt, consult each upstream project\u2019s LICENSE file.</p>"},{"location":"about/other-resources/","title":"Other Similar Projects","text":"<p>Here are some other projects and tools that are related to TeXSmith in terms of functionality, purpose, or target audience.</p>"},{"location":"about/other-resources/#converters-and-parsers","title":"Converters and Parsers","text":"Pandoc A universal document converter that supports a wide range of formats, including Markdown, LATEX, HTML, and more. Written in Haskell, it is not ideal for smooth integration with Python projects. Very extensible, but may require effort to set up custom conversions, filters, and to adapt templates. kramdown A fast, pure Ruby Markdown parser that supports a wide range of extensions and features. It is the default Markdown engine for Jekyll. Highly customizable and feature-rich, but primarily geared towards Ruby developers. MultiMarkdown An extended version of Markdown that adds support for tables, footnotes, citations, and more. It is designed for writers who need more advanced features while maintaining Markdown's simplicity. More powerful than standard Markdown, but with additional syntax to learn."},{"location":"about/other-resources/#online-editors-and-platforms","title":"Online Editors and Platforms","text":"Overleaf The leading online LATEX editor, offering real-time collaboration and a rich set of templates. While primarily focused on LATEX, it provides some support for Markdown through conversion tools. It is a commercial platform with free and paid plans. Numerous templates and collaboration features, but limited direct Markdown support. A good knowledge of LATEX is often required. Authorea An online platform for writing and publishing scientific documents. It supports Markdown, LATEX, and other formats, with a focus on academic writing. It offers collaboration features and integration with reference management tools. Designed for researchers and academics, but may not be ideal for general-purpose document creation. The WYSIWYG editor is user-friendly, but advanced formatting may be tricky. No direct support for glossary or index generation. ShareLaTeX An online LATEX editor that allows for real-time collaboration. It has merged with Overleaf, so users are directed to use Overleaf for new projects. Primarily focused on LATEX, with limited Markdown support through conversion. Strong LATEX capabilities, but not ideal for Markdown-centric workflows. Curvenote A collaborative platform for writing scientific documents, supporting Markdown and Jupyter Notebooks. It offers real-time collaboration, version control, and integration with data sources. Tailored for scientific writing, but may not cover all general document needs. Good for integrating code and data, but may lack advanced formatting features. It is based on MyST Markdown. The WYSIWYG editor is tr\u00e8s aboutit. Typora A popular Markdown editor that provides a seamless live preview experience. It supports various Markdown flavors and offers a clean, distraction-free interface. While it excels as an editor, it lacks advanced document structuring features like glossary or index generation. Great for writing and note-taking, but not a full-fledged document processor."},{"location":"about/other-resources/#other-structured-document-formats","title":"Other structured document formats","text":"AsciiDoc A text document format for writing notes, documentation, articles, books, ebooks, slideshows, web pages, and blogs. It is human-readable and can be converted to HTML, PDF, and other formats. More powerful than Markdown in terms of features and flexibility, but with a steeper learning curve. reStructuredText A file format for textual data used primarily in the Python programming community for technical documentation. It is part of the Docutils project and can be converted to various output formats, including HTML and LATEX. More complex than Markdown, with a focus on technical documentation. Le langage reST est plus verbeux que Markdown, mais offre des fonctionnalit\u00e9s avanc\u00e9es pour la documentation technique, il est de moins en moins utilis\u00e9 en faveur de Markdown. LATEX A high-quality typesetting system commonly used for technical and scientific documents. It provides extensive control over document layout and formatting, making it suitable for complex documents. Steeper learning curve compared to Markdown, but offers unparalleled typesetting capabilities. DocBook An XML-based markup language for technical documentation. It is designed to be both human-readable and machine-processable, allowing for the creation of structured documents that can be transformed into various output formats. More complex than Markdown, with a focus on technical documentation."},{"location":"about/other-resources/#static-site-generator-tools","title":"Static site generator tools","text":"Sphinx A documentation generator primarily used for Python projects. It supports reStructuredText and Markdown (with extensions) and can produce HTML, LATEX, PDF, and other formats. Highly extensible with a wide range of plugins and themes, but primarily geared towards technical documentation. Jekyll A popular static site generator that transforms plain text into static websites and blogs. It supports Markdown and Liquid templating. Widely used for GitHub Pages, with a large community and many themes available. Simple to set up, but may require knowledge of Ruby for advanced customization. Hugo A fast and flexible static site generator written in Go. It supports Markdown and offers a variety of themes and plugins. Known for its speed and ease of use, making it suitable for both beginners and advanced users. Extensive documentation and a strong community. MkDocs A static site generator focused on project documentation. It uses Markdown for content and YAML for configuration. Easy to set up and use, with a variety of themes available. Ideal for creating simple, clean documentation sites. Zensical A modern static site generator that emphasizes simplicity and speed. It supports Markdown and offers a range of themes. Designed for quick setup and deployment, making it suitable for personal blogs and small websites. A next-gen MkDocs Material alternative. Gatsby A React-based static site generator that allows for building fast and modern websites. It supports Markdown and offers a rich ecosystem of plugins and themes. Ideal for developers familiar with React, but may have a steeper learning curve for beginners. Docusaurus A static site generator designed for building documentation websites. It supports Markdown and offers features like versioning and localization. Backed by Facebook, it has a strong community and is easy to set up for documentation projects. TypeDoc A documentation generator for TypeScript projects. It uses TypeScript's type information to generate API documentation in Markdown or HTML format. Ideal for TypeScript developers looking to document their codebases. Hexo A fast, simple, and powerful blog framework powered by Node.js. It uses Markdown for content creation and offers a variety of themes and plugins. Known for its speed and ease of use, making it suitable for bloggers and developers alike. Pelican A static site generator written in Python that uses Markdown and reStructuredText for content. It offers a range of themes and plugins, making it flexible for various types of websites. Ideal for Python developers looking for a static site solution. Zola A fast static site generator in a single binary with everything built-in. It uses Markdown for content and offers a variety of themes. Known for its speed and simplicity, making it easy to set up and deploy websites."},{"location":"about/other-resources/#markdown-syntaxes","title":"Markdown Syntaxes","text":"CommonMark A strongly defined, highly compatible specification of Markdown. It aims to standardize Markdown syntax and behavior across different implementations. Very limited in features compared to other Markdown flavors, focusing on core syntax for maximum compatibility. GitHub Flavored Markdown (GFM) An extension of CommonMark used by GitHub, adding features like tables, task lists, and strikethrough. Widely used in the developer community, especially for README files and documentation on GitHub. More feature-rich than CommonMark, but still focused on simplicity and compatibility. Pandoc Markdown A Markdown flavor used by the Pandoc document converter, supporting a wide range of extensions and features. It is highly flexible and can be customized for various output formats. Very feature-rich, but may be overwhelming for users looking for a simple Markdown experience. Markdown Extra An extension of the original Markdown syntax that adds features like tables, footnotes, and definition lists. It is designed to enhance Markdown's capabilities while remaining easy to read and write. More features than standard Markdown, but still user-friendly. Used on PHP-based platforms like WordPress. MyST Markdown A Markdown flavor designed for technical documentation, supporting directives and roles similar to reStructuredText. It is used in Sphinx and Jupyter Book for creating complex documents. Very powerful for technical writing, but with a steeper learning curve due to additional syntax. MDX A Markdown flavor that allows embedding JSX components within Markdown files. It is commonly used in React-based projects to create interactive documentation and blogs. Highly flexible for React developers, but requires knowledge of JSX and React. Pymdown A set of extensions for Python Markdown that adds various features and enhancements. It includes support for tables, footnotes, and more. Designed to work seamlessly with Python Markdown, making it suitable for Python projects. Offers additional functionality while maintaining compatibility with standard Markdown."},{"location":"about/other-resources/#markdown-parsers","title":"Markdown parsers","text":"Python Markdown A popular Markdown parser for Python, supporting various extensions and features. It is easy to use and integrates well with Python projects. Highly extensible, making it suitable for developers looking to customize their Markdown processing. Used in MkDocs and other Python-based tools. Markdown-it A flexible and extensible Markdown parser for JavaScript. It supports a wide range of plugins and can be customized to fit various needs. Highly configurable, making it suitable for developers looking to tailor their Markdown processing. Marked A fast, lightweight Markdown parser and compiler for JavaScript. It supports a variety of extensions and is designed for performance. Suitable for web applications that require quick Markdown processing. Remarkable A Markdown parser for JavaScript that supports various extensions and plugins. It is designed to be fast and flexible, allowing developers to customize their Markdown processing. Highly extensible, making it suitable for developers looking to tailor their Markdown experience."},{"location":"about/other-resources/#diagramming-tools-online-editors","title":"Diagramming Tools (online editors)","text":"Mermaid A popular diagramming and charting tool that uses a simple Markdown-like syntax to create diagrams. It supports flowcharts, sequence diagrams, Gantt charts, and more. Easily integrable with various platforms and tools, making it a favorite among developers and technical writers. Draw.io A free online diagramming tool that supports a wide range of diagram types, including flowcharts, UML diagrams, network diagrams, and more. It offers a user-friendly interface and integrates with various cloud storage services. Versatile and easy to use, making it suitable for both casual and professional users. Graphviz An open-source graph visualization software that uses the DOT language to describe graphs. It is widely used for creating complex diagrams and visualizations. Highly customizable, but may have a steeper learning curve due to its syntax. PlantUML A tool that allows users to create UML diagrams from plain text descriptions. It supports various diagram types, including class diagrams, sequence diagrams, and use case diagrams. Popular among software developers for documenting system designs. Ditaa A small command-line tool that converts ASCII art diagrams into proper bitmap graphics. It is useful for creating simple diagrams quickly without the need for complex software. Lightweight and easy to use, but limited in features compared to other diagramming tools. SVGBob A tool that converts ASCII art diagrams into SVG graphics. It is designed to be simple and easy to use, making it suitable for quick diagram creation. Lightweight and focused on SVG output, but may lack advanced features found in other tools. BlockDiag A set of tools that generate block diagrams from simple text descriptions. It supports various diagram types, including block diagrams, sequence diagrams, and activity diagrams. Useful for creating structured diagrams quickly, but may have limited customization options. BPMN An online tool for creating Business Process Model and Notation (BPMN) diagrams. It provides a user-friendly interface for designing business processes and workflows. Specifically focused on BPMN, making it ideal for business analysts and process designers. Can be exported in XML format for further processing. Pikchr A simple diagramming tool that uses a text-based syntax to create diagrams. It is designed to be easy to learn and use, making it suitable for quick diagram creation. Lightweight and straightforward, but may lack advanced features found in other diagramming tools. TikZ A powerful LATEX package for creating high-quality graphics programmatically. It is widely used in academic and scientific documents for creating complex diagrams and illustrations. Highly customizable, but requires knowledge of LATEX and a steeper learning curve. WaveDrom An online tool for creating digital timing diagrams from a simple text-based description. It is useful for visualizing digital signals and timing relationships. Focused on timing diagrams, making it ideal for hardware designers and engineers. Kroki A service that allows users to create diagrams from various text-based formats, including PlantUML, Mermaid, Graphviz, and more. It provides an easy way to generate diagrams without installing software locally. Supports a wide range of diagram types, making it versatile for different use cases."},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#release-notes-compatibility","title":"Release Notes &amp; Compatibility","text":"<p>Use this page to see what changed in each TeXSmith release and which LATEX prerequisites (TEX Live year, <code>tlmgr</code> packages, shell-escape requirements) the bundled templates expect. Update your automation and CI images accordingly before bumping versions.</p>"},{"location":"about/release-notes/#texsmith-releases","title":"TeXSmith releases","text":"Version Highlights Notes <code>0.1.0</code> Unified conversion engine (<code>ConversionService</code>, slot assignments, diagnostics emitters), Typer CLI with <code>render</code>/<code>bibliography</code>, initial template catalog (article, book), diagram adapters (Mermaid, Draw.io, Svgbob), MkDocs integration hooks. Requires Python 3.10+, MkDocs \u2265 1.6 for docs. Templates target TEX Live 2023. <code>0.4.0</code> Fragment manifest/ABC (attributes, partials, slot validation), explicit partial precedence (template &gt; fragment &gt; core), template discovery order (built-ins \u2192 packages \u2192 local \u2192 <code>~/.texsmith/templates</code>), improved <code>--template-info</code> output (slots, fragments, attribute columns). Update custom fragments to <code>fragment.toml</code> + <code>partials</code>/<code>required_partials</code>; remove legacy template attributes (cover/twocolumn/backmatter/emoji) and use fragment-provided options instead. Use <code>texsmith templates</code> to confirm discovery. <p>Future releases will append to this table with new features, migration notes, and API changes. If you upgrade past the compatibility range declared in a template manifest (<code>[compat]</code>), update the template and rerun its smoke tests.</p>"},{"location":"about/release-notes/#template-compatibility-matrix","title":"Template compatibility matrix","text":"Template Version TEX Live year Shell escape Key <code>tlmgr</code> packages Notes <code>article</code> 0.1.0 2023 Required (minted) <code>babel</code>, <code>geometry</code>, <code>hyperref</code>, <code>microtype</code>, <code>lmodern</code>, <code>textcomp</code>, <code>fontspec</code>, <code>biblatex</code> Provides <code>mainmatter</code> + <code>abstract</code> slots, ships custom <code>.latexmkrc</code> with minted settings. <code>book</code> 0.2.0 2023 Required (minted) <code>babel</code>, <code>babel-french</code>, <code>csquotes</code>, <code>fontspec</code>, <code>fancyvrb</code>, <code>geometry</code>, <code>hyperref</code>, <code>longtable</code>, <code>microtype</code>, <code>titlesec</code>, <code>titletoc</code>, <code>xcolor</code>, <code>xunicode</code> Adds chapter-aware slots (<code>frontmatter</code>, <code>mainmatter</code>, <code>appendix</code>), reuses shared callouts/utility styles, ships cover assets. <p>To inspect third-party or local templates, run:</p> <pre><code>texsmith --template &lt;name-or-path&gt; --template-info\n</code></pre> <p>The command lists TEX Live requirements, shell-escape expectations, slot definitions, and declared assets.</p>"},{"location":"about/release-notes/#upgrade-checklist","title":"Upgrade checklist","text":"<ol> <li>Run <code>uv run mkdocs build</code> to confirm docs compile without warnings on the new release.</li> <li>Update your TEX Live image with any new packages referenced in the table above or in <code>template-info</code>.</li> <li>Rebuild the examples (<code>docs/examples/index.md</code>) and confirm smoke tests still pass.</li> <li>Capture notable migrations (CLI flags, metadata schema changes) in this page and link PRs or release notes for future reference.</li> </ol>"},{"location":"about/versioning/","title":"Versioning","text":"<p>TeXSmith follows Semantic Versioning 2.0.0. Each release version is identified by a three-part number: <code>MAJOR.MINOR.PATCH</code>. We will therefore ensure that no breaking changes are introduced in minor or patch releases.</p> <p>However, versions prior to <code>1.0.0</code> are considered initial development releases, and as such, the public API may change at any time without notice. Users are advised to expect potential breaking changes when upgrading between pre-1.0.0 versions. As we are not yet near a stable release, TeXSmith is not recommended for production use at this time. Testing and feedback from early adopters are highly appreciated to help us improve the tool.</p>"},{"location":"about/devel/","title":"Development Roadmap","text":"<p>Roadmap and development notes for TeXSmith. I keep this file as a running checklist of features to implement, refactorings to perform, and documentation to write. It will remain part of TeXSmith until version 1.0.0 ships.</p>"},{"location":"about/devel/#roadmap","title":"Roadmap","text":"<ul> <li>[x] Simplify the attributes SSOT for templates and fragments</li> <li>[x] Deploy to PyPI</li> <li>[x] WARNING -  Unresolved mustache <code>{{callouts.style}}</code> in template attributes; leaving placeholder as-is.</li> <li>[x] Attribute redundancy (<code>numbered</code>, <code>press.numbered</code>, etc.)</li> <li>[x] Refactoring snippets and fixing snippet templates</li> <li>[x] Font: mono fallback for missing characters</li> <li>[ ] Global user configuration (.texsmith/config.yml)</li> <li>[ ] Unified Fences Syntax</li> <li>[ ] Multicolumns</li> <li>[ ] Font Size</li> <li>[ ] Center/Right alignment</li> <li>[ ] Language</li> <li>[ ] LATEX only / HTML only</li> <li>[ ] LATEX raw</li> <li>[ ] More examples</li> <li>[ ] University exam</li> <li>[ ] Student quiz</li> <li>[ ] Multiline Acronyms</li> <li>[ ] Support for <code>inserted text</code> and <code>{~~deleted text~~}</code> (goodbox)</li> <li>[ ] Index: support for multi-indexes</li> <li>[ ] Cross-references (cleveref package)</li> <li>[ ] Enhanced tables: add with controls (auto, fixed width, <code>tabulary</code>, etc.)</li> <li>[ ] Support table orientation (rotate very large tables)</li> <li>[ ] CI: uv run mkdocs build #--strict not yet ready</li> <li>[ ] Support for <code>tocloft</code> package to customize list of figures/tables</li> <li>[ ] Support for <code>enumitem</code> package to customize lists</li> <li>[ ] Develop submodules as standalone plugins</li> <li>[ ] Marginalia (<code>marginpar</code> package with footnotes syntax)</li> <li>[ ] Epigraph Plugin</li> <li>[ ] Letterine</li> <li>[ ] Custom variables to insert in a document using mustaches</li> </ul>"},{"location":"about/devel/#unified-fences-syntax","title":"Unified Fences Syntax","text":"<p>Markdown format has evolves like a living spece and multiple syntaxes coexists for different purposes. While MyST chose to only use backticks for any blocks (code, admonition), it seems more natural to use different fence styles for different purposes:</p> <ul> <li><code>```</code> for code blocks and special blocks (Mermaid, LATEX, custom tables, etc.) that require processing</li> <li><code>&lt;language&gt;</code> Language highlighting for code blocks</li> <li><code>mermaid</code> for Mermaid diagrams</li> <li><code>svgbob</code> for SVGBob diagrams</li> <li><code>tikz</code> for TikZ diagrams</li> <li><code>table</code> for custom tables</li> <li><code>python figure</code> for Python-generated figures</li> <li><code>!!!</code> and <code>???</code> for admonitions and promoted text (notes, warnings, tips, etc.)</li> <li><code>:::</code> or <code>///</code> for custom containers environments (center, right, language, font size, LATEX only, HTML only, raw LATEX, etc.)</li> <li><code>align center</code> for centered text</li> <li><code>align right</code> for right-aligned text</li> <li><code>language &lt;lang&gt;</code> for language-specific content</li> <li><code>font large</code> for font size adjustments</li> <li><code>font small</code> for font size adjustments</li> </ul> <p>which can add captions to figures or tables, but discrimination of target (figure or table) is not done automatically you must specify <code>figure-caption</code> or <code>table-caption</code></p> <p>MyST Directives support adding options/arguments using this syntax:</p> <pre><code>```{directive}\n:option: value\n```\n\n{rolename}`text`\n</code></pre> <pre><code>:::{note}\nAdmonition\n:::\n</code></pre> <p>The subfigures with the <code>| ^1</code> syntax work, but this is not optimal for LATEX rendering, and the reference ID generated with <code>attrs: {id: static-id}</code> can be misleading.</p> <p>TeXSmith offers a more convenient way of adding figures using the admonition style</p> <pre><code>/// figure { #reference }\n\n   ![alt](image.png)\n\n   Caption...\n</code></pre> <p>You can automatically use subfigures with the following. The layout attribute will dictate how the figures are arranged in the output (<code>2:1</code> two figures horizontally, <code>2:2</code> four figures in two columns with two rows).</p> <pre><code>/// figure { #reference layout=\"2:1\" }\n\n   ![a](image.png)\n   ![b](image.png)\n\n   We see in (a) a figure and in (b) another one.\n</code></pre> <p>To refer to figures, use the <code>[](reference)</code> which will be replaced by the element number.</p> <pre><code>We see in Figure [](duck) that the animal has two legs.\n</code></pre>"},{"location":"about/devel/#tectonic-log","title":"Tectonic log","text":"<p>We want to mute false warnings and not display them:</p> <pre><code>/^warning:\\s*.*?:\\d+:\\s*Requested font.*?at.*$/\n/^warning:\\s*.*?:\\d+:\\s*Unknown feature.*?in font.*$/\n</code></pre> <p>Recent matrix runs with TEX Gyre (bonum/pagella/termes/schola/heros/adventor/cursor) trigger many Tectonic warnings like <code>Unknown feature '</code> or repeated <code>Requested font</code> lines; output is otherwise correct. Keep these noted as benign until we wire the log filter above or document a flag to silence them.</p>"},{"location":"about/devel/#features","title":"Features","text":""},{"location":"about/devel/#mermaid-color-configuration","title":"Mermaid color configuration","text":"<p>Je remarque que les diagrammes Mermaid qui sont cr\u00e9\u00e9s apparaissent avec un fond gris dans le PDF. Mais nous avions configur\u00e9 un style Mermaid global a TeXSmith pour avoir des diagrammes b&amp;w dans le PDF final. Il n'est probablement plus activ\u00e9 ou pris en compte. Il faut v\u00e9rifier cela et corriger le probl\u00e8me.</p> <p>La gestion du cache des assets est aussi \u00e0 v\u00e9rifier et la rendre d\u00e9pendante de la configuration mermaid (si on change le style, il faut reg\u00e9n\u00e9rer les diagrammes), ou alors si l'ex\u00e9cutable ou la version de l'image docker utilis\u00e9e change.</p> <p>On ajoute aussi cette v\u00e9rification pour les assets drawio.</p>"},{"location":"about/devel/#mkdocs-linking-issues","title":"MkDocs Linking Issues","text":"<p>MkDocs currently fails to resolve links to other pages. For example, <code>[High-Level Workflows](api/high-level.md)</code> becomes <code>\\ref{snippet:...</code> but the referenced snippet is never defined. Replacing the syntax with <code>\\ref</code> builds successfully but still fails at runtime. Investigate and fix the resolver so links work throughout the site.</p> <p>Also note that the scientific paper \u201ccheese\u201d example prematurely closes code blocks after a snippet. Identify why the snippet terminates early and correct it.</p>"},{"location":"about/devel/#acronyms-multiline","title":"Acronyms multiline","text":"<p>The following doesn't work; it should either warn or join the different lines together.</p> <pre><code># Acronyms\n\nThe National Aeronautics and Space Administration NASA is responsible for the\ncivilian space program.\n\n*[NASA]:\n    Line 1\n    Line 2\n</code></pre>"},{"location":"about/devel/#font-style-with-mono","title":"Font style with mono","text":"<p>We want to support combinations of font styles with the monospace font. For example:</p> <pre><code>*`abc`*\n***`abc`***\n__*`abc`*__\n</code></pre>"},{"location":"about/devel/#fences-the-gros-bordel","title":"Fences the gros bordel","text":""},{"location":"about/devel/#code","title":"Code","text":"<p>We only use <code>```</code> fences for code blocks or other special blocks like Mermaid, LATEX, custom tables, etc. No other uses should be allowed.</p>"},{"location":"about/devel/#admonitions","title":"Admonitions","text":"<p>We prefer the MkDocs admonition syntax as it is more flexible and better supported.</p> <pre><code>!!! note \"Note Title\"\n\n    This is the content of the note.\n\n??? info \"Foldable Info Title\"\n\n    This is the content of the info.\n</code></pre>"},{"location":"about/devel/#fenced-custom","title":"Fenced custom","text":"<p>The <code>:::</code> syntax is reserved for custom containers like <code>center</code>, <code>right</code>, <code>language</code>, etc. No other uses should be allowed.</p>"},{"location":"about/devel/#font-size","title":"Font Size","text":"<p>tiny, small, large, huge, enormous Other synonyms: tiny, scriptsize, footnotesize, small, normalsize, large, Large, LARGE, huge, Huge Other english synonyms: tiny, very small, small, normal, big, very big, huge, enormous</p> Adjective(s) (EN) LATEX HTML correspondance (CSS) tiny, very tiny \\tiny   (\u2248 5 pt) <code>&lt;span style=\"font-size:0.5em\"&gt;...&lt;/span&gt;</code> very small \\scriptsize (\u2248 7 pt) <code>&lt;span style=\"font-size:0.7em\"&gt;...&lt;/span&gt;</code> footnote-sized \\footnotesize (\u2248 8 pt) <code>&lt;span style=\"font-size:0.8em\"&gt;...&lt;/span&gt;</code> small \\small (\u2248 9 pt) <code>&lt;span style=\"font-size:0.9em\"&gt;...&lt;/span&gt;</code> normal \\normalsize (\u2248 10 pt) <code>&lt;span style=\"font-size:1em\"&gt;...&lt;/span&gt;</code> big \\large (\u2248 12 pt) <code>&lt;span style=\"font-size:1.2em\"&gt;...&lt;/span&gt;</code> very big \\Large (\u2248 14.4 pt) <code>&lt;span style=\"font-size:1.4em\"&gt;...&lt;/span&gt;</code> between big and huge \\LARGE (\u2248 17.3 pt) <code>&lt;span style=\"font-size:1.7em\"&gt;...&lt;/span&gt;</code> huge \\huge (\u2248 20.7 pt) <code>&lt;span style=\"font-size:2.1em\"&gt;...&lt;/span&gt;</code> enormous, gigantic \\Huge (\u2248 24.9 pt) <code>&lt;span style=\"font-size:2.5em\"&gt;...&lt;/span&gt;</code> <pre><code>::: font large\nThis text is large.\n:::\n</code></pre>"},{"location":"about/devel/#centerright-alignment","title":"Center/Right alignment","text":"<pre><code>::: center\ntexte\n:::\n\n::: right\ntexte\n:::\n</code></pre>"},{"location":"about/devel/#alignment","title":"Alignment","text":"<pre><code>::: align center\nThis text is centered.\n:::\n\n::: align right\nThis text is right-aligned.\n:::\n\n::: language arabic\n</code></pre> <p>We use the syntax <code>verb</code> + <code>option</code> after the opening <code>:::</code> to specify the type of container and any relevant options.</p> <pre><code>::: latex only\nThis LaTeX-only content will be included in the LaTeX output but ignored in HTML.\n:::\n\n::: html only\nThis HTML-only content will be included in the HTML output but ignored in LaTeX.\n:::\n</code></pre> <p>We can use raw LATEX blocks for more complex LATEX content that doesn't fit well in Markdown:</p> <pre><code>::: latex raw\n\\clearpage\n:::\n</code></pre> <p>With SuperFences we support extra HTML attributes for custom containers:</p> <pre><code>::: language arabic {#custom-id .custom-class data-attr=\"value\"}\nThis is Arabic content with custom HTML attributes.\n:::\n</code></pre> <p>Each <code>:::</code> container is converted into a <code>&lt;div&gt;</code> with the specified attributes in HTML, while LATEX processes the content according to the container type.</p>"},{"location":"about/devel/#gfm-support-for-admonitions","title":"GFM Support for admonitions","text":"<p>We want TeXSmith to support GitHub Flavored Markdown (GFM) admonitions as well. This includes the ability to create notes, warnings, tips, and other types of admonitions using the GFM syntax.</p> <pre><code>&gt; [!NOTE]\n&gt; This is a note admonition.\n</code></pre> <p>This is converted to the exact same output as the MkDocs admonition syntax. It is equivalent to:</p> <pre><code>!!! note\n    This is a note admonition.\n</code></pre>"},{"location":"about/devel/#figure-references","title":"Figure References","text":"<p>Printed references depend on the document language. In English we would write, \u201cThe elephant shown in Figure 1 is large.\u201d The LATEX equivalent is <code>The elephant shown in Figure~\\ref{fig:elephant} is large.</code> Pymdown lets us write:</p> <pre><code>The elephant shown in figure [#fig:elephant] is large.\n</code></pre> <pre><code>\\hyperref[fig:elephant]{Figure~\\ref*{fig:elephant}}\n\n\\usepackage[nameinlink]{cleveref}\nThe elephant shown in \\Cref{fig:elephant} is large.\nThe same sentence in French typography would translate to \u201cThe elephant shown in \\cref{fig:elephant} is large,\u201d keeping \u201cfigure\u201d lowercase.\n</code></pre> <p>In scientific English we capitalize \u201cFigure\u201d, while French typography keeps \u201cfigure\u201d lowercase.</p>"},{"location":"about/devel/config/","title":"Global user configuration","text":"<p>We want TeXSmith to support a global user configuration file located at <code>.texsmith/config.yml</code>. This file allows users to set their preferred defaults for templates, Mermaid styles, compilation options, and paper formats. The configuration file is optional and can be placed in the current working directory or any parent directory.</p> <p>This only affects CLI usage of TeXSmith. The API remains robust and does not depend on any global configuration, except for the cache directory.</p> <p>A config file could be:</p> <pre><code>template: article\nengine: tectonic\npaper:\n  format: a4\n  orientation: portrait\nmermaid:\n  theme: neutral\ncallouts:\n  style: fancy\n</code></pre> <p>The format is not rigidly defined. It is used to set default values for command-line options. Command-line options always take precedence over configuration file settings, and YAML front matter in Markdown files has the highest precedence.</p> <p>Fragments, plugins, and everything else inherit from this global configuration when using the CLI.</p>"},{"location":"about/devel/glossary/","title":"Glossary","text":"<p>The MkDocs ezglossary plugin exists, but the syntax is unintuitive (for example, the semicolon separator) and does not handle spaced or formatted entries well. Ideally, readers should be able to access the glossary as a popup, tooltip, or link.</p> <p>LATEX glossaries usually rely on the <code>glossaries</code> package and definitions declared in the preamble via <code>\\newglossaryentry</code>:</p> <pre><code>\\newglossaryentry{key}{\n  name={singular form},\n  plural={plural form},\n  description={descriptive text},\n  first={special form for first use},\n  text={normal form (if you want to force it)},\n}\n</code></pre> <p><code>\\gls</code> uses the standard form, <code>\\Gls</code> capitalizes the first letter, <code>\\glspl</code> gives the plural, and <code>\\Glspl</code> capitalizes the plural. The first use of the term falls back to the <code>first</code> form when present, otherwise <code>name</code>. Markdown alone cannot express all of that. One option is to define glossary entries in front matter:</p> <pre><code>glossary:\n  html:\n    name: HTML\n    plural: HTMLs\n    description: &gt;\n      HyperText Markup Language, the standard markup language for\n      documents designed to be displayed in a web browser.\n    first: HyperText Markup Language (HTML)\n</code></pre> <p>Place an anchor where the term is defined:</p> <pre><code>The **HTML**{#gls-html} is the standard markup language for web pages...\n</code></pre>"},{"location":"about/devel/plugins/","title":"Standalone Plugins","text":"<p>Some ideas on standalone plugins that can be developed and shared independently or included in TeXSmith by default. These are some features that I can use myself and that can be useful to others.</p>"},{"location":"about/devel/plugins/#epigraph","title":"Epigraph","text":"<p>Integrate epigraph support via a dedicated plugin. The goal is to let users insert epigraphs easily from Markdown files. It can be declared as a fragment and declared in the document via front matter:</p> <pre><code>epigraph: text\nepigraph:\n  quote: \"To be, or not to be, that is the question.\"\n  source: \"William Shakespeare, Hamlet\"\n</code></pre> <p>This is inserted into the LATEX output using the <code>epigraph</code> package:</p> <pre><code>\\usepackage{epigraph}\n\\setlength\\epigraphwidth{0.6\\textwidth}\n\\setlength\\epigraphrule{0pt}\n</code></pre> <p>Then, at the desired location in the document:</p> <pre><code>\\epigraph{To be, or not to be, that is the question.}{William Shakespeare, \\textit{Hamlet}}\n</code></pre>"},{"location":"about/devel/plugins/#svgbob","title":"SvgBob","text":"<p>This can be a good example of a standalone TeXSmith plugin that allows rendering ASCII art diagrams using Svgbob.</p> <p>Svgbob lets you sketch diagrams using ASCII art. Save the source with a <code>.bob</code> extension (or keep it inline) and link to it like any other image:</p> <pre><code>![Sequence diagram](assets/pipeline.bob)\n</code></pre> <p>During the build TeXSmith calls the bundled Svgbob converter, generates a PDF, and inserts it into the final LATEX output. Cached artifacts prevent repeated rendering when the source diagram stays the same.</p> <p>SVGBob can be installed on Ubuntu via:</p> <pre><code>cargo install svgbob_cli\n</code></pre> <p>It is installed by default into <code>svgbob_cli</code> or <code>~/.cargo/bin/svgbob_cli</code>. We want to check both, warn if the binary is missing, and allow users to override the path via configuration.</p> <p>We can insert the image in both ways:</p> <pre><code>```svgbob\n       +10-15V           ___0,047R\n      *---------o-----o-|___|-o--o---------o----o-------.\n    + |         |     |       |  |         |    |       |\n    -===-      _|_    |       | .+.        |    |       |\n    -===-      .-.    |       | | | 2k2    |    |       |\n    -===-    470| +   |       | | |        |    |      _|_\n    - |       uF|     '--.    | '+'       .+.   |      \\ / LED\n      +---------o        |6   |7 |8    1k | |   |      -+-\n             ___|___   .-+----+--+--.     | |   |       |\n              -\u2550\u2550\u2550-    |            |     '+'   |       |\n                -      |            |1     |  |/  BC    |\n               GND     |            +------o--+   547   |\n                       |            |      |  |`&gt;       |\n                       |            |     ,+.   |       |\n               .-------+            | 220R| |   o----||-+  IRF9Z34\n               |       |            |     | |   |    |+-&gt;\n               |       |  MC34063   |     `+'   |    ||-+\n               |       |            |      |    |       |  BYV29     -12V6\n               |       |            |      '----'       o--|&lt;-o----o--X OUT\n 6000 micro  - | +     |            |2                  |     |    |\n Farad, 40V ___|_____  |            |--o                C|    |    |\n Capacitor  ~ ~ ~ ~ ~  |            | GND         30uH  C|    |   --- 470\n                      |            |3      1nF         C|    |   ###  uF\n               |       |            |-------||--.       |     |    | +\n               |       '-----+----+-'           |      GND    |   GND\n               |            5|   4|             |             |\n               |             |    '-------------o-------------o\n               |             |                           ___  |\n               `-------------*------/\\/\\/------------o--|___|-'\n                                     2k              |       1k0\n                                                    .+.\n                                                    | | 5k6 + 3k3\n                                                    | | in Serie\n                                                    '+'\n                                                     |\n                                                    GND\n```\n</code></pre> <p>If Svgbob is not available, diagrams can be skipped with a warning and rendered as code blocks.</p>"},{"location":"about/devel/plugins/#circuittikz","title":"CircuitTikZ","text":"<p>The CircuitTikZ designer helps produce circuit diagrams from the browser. Export the generated TikZ snippet and wrap it in a raw LATEX fence:</p> <pre><code>```latex { circuitikz }\n\\begin{circuitikz}\n    \\draw (0,0) to[battery] (0,2)\n          -- (3,2) to[R=R] (3,0) -- (0,0);\n\\end{circuitikz}\n```\n</code></pre> <p>Raw blocks bypass the HTML output but remain in the LATEX build. To keep the TikZ code in a separate file, include it via <code>\\input{}</code> inside a raw fence and store the <code>.tex</code> asset alongside the Markdown.</p>"},{"location":"about/devel/plugins/#module-design-principles","title":"Module Design Principles","text":"<p>Verify that TeXSmith respects these design principles:</p> <ul> <li>Modules can inject, extend, and redefine functionality.</li> <li>Modules remain deterministic through topological ordering.</li> <li>Modules foster reusability and remixing.</li> <li>Modules cooperate through well-defined contracts.</li> </ul>"},{"location":"about/devel/plugins/#visual-tweaks","title":"Visual Tweaks","text":"<ul> <li>Reduce line height for code that uses Unicode box characters.</li> <li>Restyle inserted text (currently green and overly rounded); see \u201cFormatting inserted text\u201d.</li> <li><code>{~~deleted text~~}</code> should drop the curly braces, which currently leak into the output.</li> </ul>"},{"location":"about/devel/plugins/#issues","title":"Issues","text":""},{"location":"about/devel/plugins/#markdown-package-issues","title":"Markdown Package Issues","text":"<p><code>mkdocstrings</code> autorefs define heading anchors via <code>[](){#}</code>, which triggers Markdown lint violations. Find a syntax or lint configuration that avoids false positives.</p>"},{"location":"about/devel/tables/","title":"Tables","text":""},{"location":"about/devel/tables/#complex-tables","title":"Complex Tables","text":"<p>Markdown offers limited table configuration\u2014only column alignment by default. PyMdown provides captions, and superfences can inject more metadata, but we still miss:</p> <ul> <li>Table width (auto vs. full width)</li> <li>Resizing oversized tables</li> <li>Orientation (portrait vs. landscape)</li> <li>Column and row spanning</li> <li>Horizontal and vertical separator lines</li> <li>Column widths (fixed, auto, relative)</li> </ul>"},{"location":"about/devel/tables/#extended-markdown-table-syntax","title":"Extended Markdown Table Syntax","text":"<p>Leverage Pymdown\u2019s table extension to add more metadata directly in Markdown. For example: The <code>texsmith.spantable</code> extension lets us span cells in standard Markdown tables.</p> <p>The <code>&gt;&gt;&gt;</code> syntax will span cells horizontally, the <code>vvv</code> syntax will span cells vertically.</p> <pre><code>| Header 1 | Header 2 | Header 3 |\n|:---------|:--------:|---------:|\n| Cell 1   | Cell 2   | Cell 3   |\n| Cell 4   | &gt;&gt;&gt;      | Cell 6   |\n| Cell 7   | Cell 8   | Cell 11  |\n| Cell 9   |          | vvv      |\n</code></pre>"},{"location":"about/devel/tables/#cmidrule-example","title":"Cmidrule example","text":"<pre><code>\\begin{tabular}{@{}lll@{}}\n\\toprule\n&amp; \\multicolumn{2}{c}{Reaction} \\\\\n\\cmidrule(l){2-3}\nPerson &amp; Face &amp; Exclamation \\\\\n\\midrule\n\\multirow[t]{2}{*}{VIPs} &amp; :) &amp; Nice \\\\\n&amp; :] &amp; Sleek \\\\\nOthers &amp; \\multicolumn{2}{c}{Not available} \\\\\n\\bottomrule\n\\end{tabular}\n</code></pre>"},{"location":"about/devel/tables/#align-to-decimal-points","title":"Align to decimal points","text":"<p>Find a syntax to align numbers to dot. <code>lS@{}</code></p>"},{"location":"about/devel/tables/#raw-table-syntax","title":"Raw table syntax","text":"<p>Superfences do not work directly with tables, so define a <code>table</code> fence that accepts YAML options:</p> <pre><code>```table\nwidth: full\ncaption: Sample Table\nlabel: tbl:sample\nheader: true\nprint:\n  orientation: landscape\n  resize: true\ncolumns:\n  - alignment: left\n    width: auto\n  - alignment: center\n    width: 2cm\n  - alignment: right\n    width: auto\nrows:\n  - height: auto\n    alignment: top\n    span: [2, auto]\ndata:\n  - [Cell 1, Cell 2, Cell 3]\n  - [Cell 4, null, Cell 6]\n  - [Cell 7, Cell 8, null]\n```\n</code></pre> <p>The goal is to convert Markdown tables into LATEX tables with automatic line breaks so that columns wrap gracefully when a table is too wide.</p>"},{"location":"about/devel/tables/#shrink-to-fit-vs-auto-expand","title":"Shrink-to-fit vs Auto-expand","text":"<p>Long tables et auto-ajustement.</p> <pre><code>\\documentclass{article}\n\\usepackage[margin=2cm]{geometry}\n\\usepackage{booktabs}\n\\usepackage[french]{babel}\n\\usepackage{array}\n\n% ltablex : Le pont entre tabularx et longtable\n\\usepackage{ltablex}\n\n% IMPORTANT : On NE met PAS \\keepXColumns ici.\n% Sans cette commande, ltablex va calculer si le tableau a besoin\n% de toute la largeur ou non.\n\n\\begin{document}\n\n\\section*{Cas 1 : Table petite (Compacte)}\n% Ici, comme le texte est court, le tableau ne prendra pas toute la page\n% Les colonnes X vont se comporter comme des colonnes 'l'\n\\begin{tabularx}{\\textwidth}{lXX}\n    \\toprule\n    \\textbf{ID} &amp; \\textbf{Statut} &amp; \\textbf{Note} \\\\\n    \\midrule\n    \\endfirsthead\n    1 &amp; OK &amp; R.A.S. \\\\\n    \\midrule\n\\end{tabularx}\n\n\\vspace{2cm}\n\n\\section*{Cas 2 : Table large (Extension automatique)}\n% Ici, le texte est long. Le tableau va d\u00e9tecter qu'il d\u00e9passe,\n% s'\u00e9tendre jusqu'\u00e0 \\textwidth, et activer le retour \u00e0 la ligne.\n\\begin{tabularx}{\\textwidth}{lXX}\n    \\toprule\n    \\textbf{ID} &amp; \\textbf{Description} &amp; \\textbf{Analyse} \\\\\n    \\midrule\n    \\endfirsthead\n\n    \\textbf{ID} &amp; \\textbf{Description} &amp; \\textbf{Analyse} \\\\\n    \\midrule\n    \\endhead\n\n    204 &amp;\n    Ici j'ai un texte suffisamment long pour justifier que le tableau prenne toute la largeur disponible sur la page. &amp;\n    Et ici une autre colonne qui va se partager l'espace restant \u00e9quitablement avec la colonne pr\u00e9c\u00e9dente. \\\\\n\n    205 &amp; Test de remplissage &amp; Encore du texte... \\\\\n    \\bottomrule\n\\end{tabularx}\n\\end{document}\n</code></pre> <p>We could use a tester to have a rough idea if the table will fit or not, and decide to use <code>tabularx</code> or <code>ltablex</code> accordingly.</p> <pre><code>\\documentclass{article}\n\\usepackage{booktabs}\n\\usepackage{tabularx} % ou tabularray (tblr), etc.\n\n\\newsavebox{\\tblbox}\n\n\\begin{document}\n\\typeout{TEXTWIDTH_PT=\\the\\textwidth}\n\\typeout{LINEWIDTH_PT=\\the\\linewidth}\n\\typeout{COLUMNWIDTH_PT=\\the\\columnwidth}\n\\typeout{PAPERWIDTH_PT=\\the\\paperwidth}\n\\typeout{PAPERHEIGHT_PT=\\the\\paperheight}\n\\thispagestyle{empty}\n\n\\sbox{\\tblbox}{%\n  \\begin{tabular}{l l r}\n    \\toprule\n    Item &amp; Description &amp; Price\\\\\n    \\midrule\n    Pink Rabbit &amp; A small pink puppet made of soft fur. &amp; \\$10\\\\\n    \\bottomrule\n  \\end{tabular}%\n}\n\n\\typeout{TABLE_WD_PT=\\the\\wd\\tblbox}\n\\typeout{TABLE_HT_PT=\\the\\dimexpr\\ht\\tblbox+\\dp\\tblbox\\relax}\n\n\\end{document}\n</code></pre>"},{"location":"api/","title":"TeXSmith API Overview","text":"<p>The API reference is generated with mkdocstrings to stay in sync with the codebase. This section is organized into themed pages so you can quickly locate the module you need.</p> <p>Each page uses <code>module.path</code> directives; mkdocstrings resolves them at build time and renders docstrings, signatures, and cross-references.</p>"},{"location":"api/#api-sections","title":"API Sections","text":"<code>high-level</code> High-level orchestration helpers (<code>ConversionService</code>, <code>TemplateSession</code>) for programmatic conversions and template sessions. <code>core</code> Core package modules (<code>texsmith</code>, configuration, contexts, conversion helpers, etc.). <code>bibliography</code> Bibliography tooling (BibTeX parsing, DOI resolution, issue reporting). <code>cli</code> Command-line entry points and utilities. <code>handlers</code> Rendering handlers that transform HTML into LATEX. <code>latex</code> LATEX infrastructure (formatter, renderer, templates). <code>markdown</code> Markdown conversion helpers and custom extensions. <code>plugins</code> Optional integrations (MkDocs Material-specific handlers). <code>transformers</code> Asset conversion strategies (SVG, Draw.io, Mermaid, remote images). <p>Use the navigation sidebar to jump to any section or follow the links above for more detail.</p>"},{"location":"api/bibliography/","title":"Bibliography","text":"<p>Bibliography facade exposed through the TeXSmith public API.</p> Architecture <code>BibliographyCollection</code> centralises reference merging, deduplication, and portable export so higher layers can treat bibliographies as immutable dictionaries. The collection records provenance internally so API consumers can report issues with source context. <code>DoiBibliographyFetcher</code> encapsulates remote lookups so IO code remains outside the pure transformation layers. Callers provide a DOI and receive parsed BibTeX data ready to inject into the collection. <code>bibliography_data_from_string</code> accepts inline BibTeX payloads and converts   them into <code>BibliographyData</code> objects, enabling templating systems to embed   references alongside content. Implementation Rationale The public API needs a stable, documented entry point that is decoupled from the evolving internal package layout. Re-exporting the curated primitives keeps backward compatibility guarantees manageable. Aggregation logic lives in <code>collection.py</code> so both the CLI and the programmatic   API can reuse it. By funnelling access through this module we expose   documentation and doctest examples close to the import surface users reach for   first. <p>Usage Example</p> <pre><code>&gt;&gt;&gt; from texsmith.core.bibliography import BibliographyCollection, bibliography_data_from_string\n&gt;&gt;&gt; collection = BibliographyCollection()\n&gt;&gt;&gt; payload = \"\"\"@article{doe2023,\n...   author = {Doe, Jane},\n...   title = {A Minimal Example},\n...   year = {2023},\n... }\"\"\"\n&gt;&gt;&gt; inline = bibliography_data_from_string(payload, \"doe2023\")\n&gt;&gt;&gt; collection.load_data(inline, source=\"inline.bib\")\n&gt;&gt;&gt; reference = collection.find(\"doe2023\")\n&gt;&gt;&gt; reference[\"fields\"][\"title\"]\n'A Minimal Example'\n</code></pre> <p>Aggregation utilities for BibTeX references.</p> <p>Helpers for resolving DOIs to BibTeX payloads.</p> <p>Shared data structures for bibliography processing.</p> <p>Parsing helpers for bibliography payloads.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection","title":"BibliographyCollection","text":"<pre><code>BibliographyCollection()\n</code></pre> <p>Aggregate references from one or more BibTeX sources.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._entries: dict[str, Entry] = {}\n    self._sources: dict[str, set[Path]] = {}\n    self._issues: list[BibliographyIssue] = []\n    self._file_entry_counts: dict[Path, int] = {}\n    self._file_order: list[Path] = []\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.file_stats","title":"file_stats  <code>property</code>","text":"<pre><code>file_stats: Sequence[tuple[Path, int]]\n</code></pre> <p>Return (file, entry_count) pairs in the order files were processed.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.issues","title":"issues  <code>property</code>","text":"<pre><code>issues: Sequence[BibliographyIssue]\n</code></pre> <p>Return the list of issues discovered while loading references.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.clone","title":"clone","text":"<pre><code>clone() -&gt; BibliographyCollection\n</code></pre> <p>Return a deep copy of the collection without reparsing sources.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def clone(self) -&gt; BibliographyCollection:\n    \"\"\"Return a deep copy of the collection without reparsing sources.\"\"\"\n    cloned = BibliographyCollection()\n    cloned._entries = copy.deepcopy(self._entries)\n    cloned._sources = copy.deepcopy(self._sources)\n    cloned._issues = list(self._issues)\n    cloned._file_entry_counts = dict(self._file_entry_counts)\n    cloned._file_order = list(self._file_order)\n    return cloned\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.find","title":"find","text":"<pre><code>find(reference_key: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Return the portable representation of a specific reference.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def find(self, reference_key: str) -&gt; dict[str, Any] | None:\n    \"\"\"Return the portable representation of a specific reference.\"\"\"\n    entry = self._entries.get(reference_key)\n    if entry is None:\n        return None\n\n    return self._portable_entry(reference_key, entry, self._sources[reference_key])\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.list_references","title":"list_references","text":"<pre><code>list_references() -&gt; list[dict[str, Any]]\n</code></pre> <p>Return all references as portable dictionaries sorted by key.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def list_references(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Return all references as portable dictionaries sorted by key.\"\"\"\n    portable: list[dict[str, Any]] = []\n    for key in sorted(self._entries):\n        portable.append(self._portable_entry(key, self._entries[key], self._sources[key]))\n    return portable\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.load_data","title":"load_data","text":"<pre><code>load_data(\n    data: BibliographyData,\n    *,\n    source: Path | str | None = None,\n) -&gt; None\n</code></pre> <p>Merge pre-parsed bibliography data into the collection.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def load_data(\n    self,\n    data: BibliographyData,\n    *,\n    source: Path | str | None = None,\n) -&gt; None:\n    \"\"\"Merge pre-parsed bibliography data into the collection.\"\"\"\n    source_path = self._resolve_source_path(source)\n    entry_count = len(data.entries)\n    self._file_entry_counts[source_path] = (\n        self._file_entry_counts.get(source_path, 0) + entry_count\n    )\n    if source_path not in self._file_order:\n        self._file_order.append(source_path)\n\n    if entry_count == 0:\n        self._issues.append(\n            BibliographyIssue(\n                message=\"No references found in inline bibliography data.\",\n                key=None,\n                source=source_path,\n            )\n        )\n        return\n\n    self._merge_entries(data, source_path)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.load_files","title":"load_files","text":"<pre><code>load_files(files: Iterable[Path | str]) -&gt; None\n</code></pre> <p>Load BibTeX entries from one or more files.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def load_files(self, files: Iterable[Path | str]) -&gt; None:\n    \"\"\"Load BibTeX entries from one or more files.\"\"\"\n    for file_path in files:\n        self._load_file(Path(file_path))\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.to_bibliography_data","title":"to_bibliography_data","text":"<pre><code>to_bibliography_data(\n    *, keys: Iterable[str] | None = None\n) -&gt; BibliographyData\n</code></pre> <p>Return a BibliographyData object scoped to the selected keys.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def to_bibliography_data(self, *, keys: Iterable[str] | None = None) -&gt; BibliographyData:\n    \"\"\"Return a BibliographyData object scoped to the selected keys.\"\"\"\n    if keys is None:\n        entries = dict(self._entries)\n    else:\n        selected = {key for key in keys if key in self._entries}\n        entries = {key: self._entries[key] for key in selected}\n    return BibliographyData(entries=entries)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Return a dictionary keyed by reference identifiers.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def to_dict(self) -&gt; dict[str, dict[str, Any]]:\n    \"\"\"Return a dictionary keyed by reference identifiers.\"\"\"\n    return {\n        key: self._portable_entry(key, entry, self._sources[key])\n        for key, entry in self._entries.items()\n    }\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyCollection.write_bibtex","title":"write_bibtex","text":"<pre><code>write_bibtex(\n    target: Path | str, *, keys: Iterable[str] | None = None\n) -&gt; None\n</code></pre> <p>Persist the bibliography to a BibTeX file.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def write_bibtex(self, target: Path | str, *, keys: Iterable[str] | None = None) -&gt; None:\n    \"\"\"Persist the bibliography to a BibTeX file.\"\"\"\n    path = Path(target)\n    data = self.to_bibliography_data(keys=keys)\n    raw_text = data.to_string(\"bibtex\")\n    sanitized_lines = []\n    for line in raw_text.splitlines():\n        stripped = line.lstrip().lower()\n        if stripped.startswith(\"url =\") or stripped.startswith(\"doi =\"):\n            line = line.replace(r\"\\_\", \"_\")\n        sanitized_lines.append(line)\n    payload = \"\\n\".join(sanitized_lines).rstrip() + \"\\n\"\n    try:\n        existing = path.read_text(encoding=\"utf-8\")\n    except FileNotFoundError:\n        existing = None\n    except OSError:\n        existing = None\n    if existing == payload:\n        return\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(payload, encoding=\"utf-8\")\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.BibliographyIssue","title":"BibliographyIssue  <code>dataclass</code>","text":"<pre><code>BibliographyIssue(\n    message: str,\n    key: str | None = None,\n    source: Path | None = None,\n)\n</code></pre> <p>Represents a problem encountered while loading bibliography entries.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.DoiBibliographyFetcher","title":"DoiBibliographyFetcher","text":"<pre><code>DoiBibliographyFetcher(\n    *,\n    session: Session | None = None,\n    timeout: float = 10.0,\n    user_agent: str | None = None,\n    cache: MutableMapping[str, str] | None = None,\n    cache_dir: Path | None = None,\n    enable_cache: bool = True,\n)\n</code></pre> <p>Retrieve BibTeX entries for DOIs using content negotiation fallbacks.</p> Source code in <code>src/texsmith/core/bibliography/doi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    session: RequestsSession | None = None,\n    timeout: float = 10.0,\n    user_agent: str | None = None,\n    cache: MutableMapping[str, str] | None = None,\n    cache_dir: Path | None = None,\n    enable_cache: bool = True,\n) -&gt; None:\n    self._session_lock = Lock()\n    self._session: RequestsSession | None = session\n    self._timeout = timeout\n    self._user_agent = user_agent or self._DEFAULT_USER_AGENT\n    self._cache: MutableMapping[str, str] = cache or {}\n    self._enable_cache = enable_cache\n    resolved_cache_dir = self._resolve_cache_dir(cache_dir) if enable_cache else None\n    if session is not None and cache_dir is None:\n        resolved_cache_dir = None\n    self._cache_dir = resolved_cache_dir if enable_cache else None\n\n    if self._cache_dir is not None:\n        self._cache_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.DoiBibliographyFetcher.fetch","title":"fetch","text":"<pre><code>fetch(value: str) -&gt; str\n</code></pre> <p>Return the BibTeX payload for a DOI, trying multiple providers.</p> Source code in <code>src/texsmith/core/bibliography/doi.py</code> <pre><code>def fetch(self, value: str) -&gt; str:\n    \"\"\"Return the BibTeX payload for a DOI, trying multiple providers.\"\"\"\n    if requests is None:\n        msg = (\n            \"Python 'requests' dependency is required to resolve DOIs. \"\n            \"Install it via 'pip install requests'.\"\n        )\n        raise DoiLookupError(msg)\n\n    doi = self._normalise(value)\n    cached = self._read_cache(doi)\n    if cached is not None:\n        return cached\n\n    attempts: list[str] = []\n    client = self._ensure_session()\n    for url, headers in self._candidate_requests(doi):\n        try:\n            response = client.get(url, headers=headers, timeout=self._timeout)\n        except requests.RequestException as exc:\n            attempts.append(f\"{url}: {exc}\")\n            continue\n        if response.status_code &gt;= 400:\n            attempts.append(f\"{url}: HTTP {response.status_code}\")\n            continue\n        content = response.text.strip()\n        if content:\n            self._write_cache(doi, content)\n            return content\n        attempts.append(f\"{url}: empty response\")\n    detail = \"; \".join(attempts) if attempts else \"no responses\"\n    raise DoiLookupError(f\"Unable to resolve DOI '{doi}': {detail}\")\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.DoiLookupError","title":"DoiLookupError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when resolving a DOI to a BibTeX payload fails.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.bibliography_data_from_inline_entry","title":"bibliography_data_from_inline_entry","text":"<pre><code>bibliography_data_from_inline_entry(\n    key: str, entry: InlineBibliographyEntry\n) -&gt; BibliographyData\n</code></pre> <p>Create a BibliographyData instance from a manual inline entry.</p> Source code in <code>src/texsmith/core/bibliography/parsing.py</code> <pre><code>def bibliography_data_from_inline_entry(\n    key: str,\n    entry: InlineBibliographyEntry,\n) -&gt; BibliographyData:\n    \"\"\"Create a BibliographyData instance from a manual inline entry.\"\"\"\n    if not entry.is_manual or not entry.entry_type:\n        raise ValueError(\"Inline entry must define a manual type before conversion.\")\n\n    persons_payload = {\n        role: [Person(name) for name in names] for role, names in entry.persons.items() if names\n    }\n\n    bib_entry = Entry(entry.entry_type, fields=dict(entry.fields), persons=persons_payload)\n    return BibliographyData(entries={key: bib_entry})\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.bibliography_data_from_string","title":"bibliography_data_from_string","text":"<pre><code>bibliography_data_from_string(\n    payload: str, key: str\n) -&gt; BibliographyData\n</code></pre> <p>Parse a BibTeX payload and scope it to a specific reference key.</p> Source code in <code>src/texsmith/core/bibliography/parsing.py</code> <pre><code>def bibliography_data_from_string(payload: str, key: str) -&gt; BibliographyData:\n    \"\"\"Parse a BibTeX payload and scope it to a specific reference key.\"\"\"\n    parser = bibtex.Parser()\n    try:\n        parsed = parser.parse_stream(io.StringIO(payload))\n    except (OSError, PybtexError) as exc:\n        raise PybtexError(f\"Failed to parse inline bibliography payload: {exc}\") from exc\n\n    entries = list(parsed.entries.items())\n    if not entries:\n        raise PybtexError(\"Inline bibliography payload does not contain an entry.\")\n    if len(entries) &gt; 1:\n        raise PybtexError(\"Inline bibliography payload must contain a single entry.\")\n\n    _, entry = entries[0]\n    return BibliographyData(entries={key: entry})\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection","title":"BibliographyCollection","text":"<pre><code>BibliographyCollection()\n</code></pre> <p>Aggregate references from one or more BibTeX sources.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._entries: dict[str, Entry] = {}\n    self._sources: dict[str, set[Path]] = {}\n    self._issues: list[BibliographyIssue] = []\n    self._file_entry_counts: dict[Path, int] = {}\n    self._file_order: list[Path] = []\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.file_stats","title":"file_stats  <code>property</code>","text":"<pre><code>file_stats: Sequence[tuple[Path, int]]\n</code></pre> <p>Return (file, entry_count) pairs in the order files were processed.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.issues","title":"issues  <code>property</code>","text":"<pre><code>issues: Sequence[BibliographyIssue]\n</code></pre> <p>Return the list of issues discovered while loading references.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.clone","title":"clone","text":"<pre><code>clone() -&gt; BibliographyCollection\n</code></pre> <p>Return a deep copy of the collection without reparsing sources.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def clone(self) -&gt; BibliographyCollection:\n    \"\"\"Return a deep copy of the collection without reparsing sources.\"\"\"\n    cloned = BibliographyCollection()\n    cloned._entries = copy.deepcopy(self._entries)\n    cloned._sources = copy.deepcopy(self._sources)\n    cloned._issues = list(self._issues)\n    cloned._file_entry_counts = dict(self._file_entry_counts)\n    cloned._file_order = list(self._file_order)\n    return cloned\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.find","title":"find","text":"<pre><code>find(reference_key: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Return the portable representation of a specific reference.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def find(self, reference_key: str) -&gt; dict[str, Any] | None:\n    \"\"\"Return the portable representation of a specific reference.\"\"\"\n    entry = self._entries.get(reference_key)\n    if entry is None:\n        return None\n\n    return self._portable_entry(reference_key, entry, self._sources[reference_key])\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.list_references","title":"list_references","text":"<pre><code>list_references() -&gt; list[dict[str, Any]]\n</code></pre> <p>Return all references as portable dictionaries sorted by key.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def list_references(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Return all references as portable dictionaries sorted by key.\"\"\"\n    portable: list[dict[str, Any]] = []\n    for key in sorted(self._entries):\n        portable.append(self._portable_entry(key, self._entries[key], self._sources[key]))\n    return portable\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.load_data","title":"load_data","text":"<pre><code>load_data(\n    data: BibliographyData,\n    *,\n    source: Path | str | None = None,\n) -&gt; None\n</code></pre> <p>Merge pre-parsed bibliography data into the collection.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def load_data(\n    self,\n    data: BibliographyData,\n    *,\n    source: Path | str | None = None,\n) -&gt; None:\n    \"\"\"Merge pre-parsed bibliography data into the collection.\"\"\"\n    source_path = self._resolve_source_path(source)\n    entry_count = len(data.entries)\n    self._file_entry_counts[source_path] = (\n        self._file_entry_counts.get(source_path, 0) + entry_count\n    )\n    if source_path not in self._file_order:\n        self._file_order.append(source_path)\n\n    if entry_count == 0:\n        self._issues.append(\n            BibliographyIssue(\n                message=\"No references found in inline bibliography data.\",\n                key=None,\n                source=source_path,\n            )\n        )\n        return\n\n    self._merge_entries(data, source_path)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.load_files","title":"load_files","text":"<pre><code>load_files(files: Iterable[Path | str]) -&gt; None\n</code></pre> <p>Load BibTeX entries from one or more files.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def load_files(self, files: Iterable[Path | str]) -&gt; None:\n    \"\"\"Load BibTeX entries from one or more files.\"\"\"\n    for file_path in files:\n        self._load_file(Path(file_path))\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.to_bibliography_data","title":"to_bibliography_data","text":"<pre><code>to_bibliography_data(\n    *, keys: Iterable[str] | None = None\n) -&gt; BibliographyData\n</code></pre> <p>Return a BibliographyData object scoped to the selected keys.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def to_bibliography_data(self, *, keys: Iterable[str] | None = None) -&gt; BibliographyData:\n    \"\"\"Return a BibliographyData object scoped to the selected keys.\"\"\"\n    if keys is None:\n        entries = dict(self._entries)\n    else:\n        selected = {key for key in keys if key in self._entries}\n        entries = {key: self._entries[key] for key in selected}\n    return BibliographyData(entries=entries)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Return a dictionary keyed by reference identifiers.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def to_dict(self) -&gt; dict[str, dict[str, Any]]:\n    \"\"\"Return a dictionary keyed by reference identifiers.\"\"\"\n    return {\n        key: self._portable_entry(key, entry, self._sources[key])\n        for key, entry in self._entries.items()\n    }\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.collection.BibliographyCollection.write_bibtex","title":"write_bibtex","text":"<pre><code>write_bibtex(\n    target: Path | str, *, keys: Iterable[str] | None = None\n) -&gt; None\n</code></pre> <p>Persist the bibliography to a BibTeX file.</p> Source code in <code>src/texsmith/core/bibliography/collection.py</code> <pre><code>def write_bibtex(self, target: Path | str, *, keys: Iterable[str] | None = None) -&gt; None:\n    \"\"\"Persist the bibliography to a BibTeX file.\"\"\"\n    path = Path(target)\n    data = self.to_bibliography_data(keys=keys)\n    raw_text = data.to_string(\"bibtex\")\n    sanitized_lines = []\n    for line in raw_text.splitlines():\n        stripped = line.lstrip().lower()\n        if stripped.startswith(\"url =\") or stripped.startswith(\"doi =\"):\n            line = line.replace(r\"\\_\", \"_\")\n        sanitized_lines.append(line)\n    payload = \"\\n\".join(sanitized_lines).rstrip() + \"\\n\"\n    try:\n        existing = path.read_text(encoding=\"utf-8\")\n    except FileNotFoundError:\n        existing = None\n    except OSError:\n        existing = None\n    if existing == payload:\n        return\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(payload, encoding=\"utf-8\")\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.doi.DoiBibliographyFetcher","title":"DoiBibliographyFetcher","text":"<pre><code>DoiBibliographyFetcher(\n    *,\n    session: Session | None = None,\n    timeout: float = 10.0,\n    user_agent: str | None = None,\n    cache: MutableMapping[str, str] | None = None,\n    cache_dir: Path | None = None,\n    enable_cache: bool = True,\n)\n</code></pre> <p>Retrieve BibTeX entries for DOIs using content negotiation fallbacks.</p> Source code in <code>src/texsmith/core/bibliography/doi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    session: RequestsSession | None = None,\n    timeout: float = 10.0,\n    user_agent: str | None = None,\n    cache: MutableMapping[str, str] | None = None,\n    cache_dir: Path | None = None,\n    enable_cache: bool = True,\n) -&gt; None:\n    self._session_lock = Lock()\n    self._session: RequestsSession | None = session\n    self._timeout = timeout\n    self._user_agent = user_agent or self._DEFAULT_USER_AGENT\n    self._cache: MutableMapping[str, str] = cache or {}\n    self._enable_cache = enable_cache\n    resolved_cache_dir = self._resolve_cache_dir(cache_dir) if enable_cache else None\n    if session is not None and cache_dir is None:\n        resolved_cache_dir = None\n    self._cache_dir = resolved_cache_dir if enable_cache else None\n\n    if self._cache_dir is not None:\n        self._cache_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.doi.DoiBibliographyFetcher.fetch","title":"fetch","text":"<pre><code>fetch(value: str) -&gt; str\n</code></pre> <p>Return the BibTeX payload for a DOI, trying multiple providers.</p> Source code in <code>src/texsmith/core/bibliography/doi.py</code> <pre><code>def fetch(self, value: str) -&gt; str:\n    \"\"\"Return the BibTeX payload for a DOI, trying multiple providers.\"\"\"\n    if requests is None:\n        msg = (\n            \"Python 'requests' dependency is required to resolve DOIs. \"\n            \"Install it via 'pip install requests'.\"\n        )\n        raise DoiLookupError(msg)\n\n    doi = self._normalise(value)\n    cached = self._read_cache(doi)\n    if cached is not None:\n        return cached\n\n    attempts: list[str] = []\n    client = self._ensure_session()\n    for url, headers in self._candidate_requests(doi):\n        try:\n            response = client.get(url, headers=headers, timeout=self._timeout)\n        except requests.RequestException as exc:\n            attempts.append(f\"{url}: {exc}\")\n            continue\n        if response.status_code &gt;= 400:\n            attempts.append(f\"{url}: HTTP {response.status_code}\")\n            continue\n        content = response.text.strip()\n        if content:\n            self._write_cache(doi, content)\n            return content\n        attempts.append(f\"{url}: empty response\")\n    detail = \"; \".join(attempts) if attempts else \"no responses\"\n    raise DoiLookupError(f\"Unable to resolve DOI '{doi}': {detail}\")\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.doi.DoiLookupError","title":"DoiLookupError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when resolving a DOI to a BibTeX payload fails.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.doi.normalise_doi","title":"normalise_doi","text":"<pre><code>normalise_doi(value: str) -&gt; str\n</code></pre> <p>Return a canonical representation for DOI strings.</p> Source code in <code>src/texsmith/core/bibliography/doi.py</code> <pre><code>def normalise_doi(value: str) -&gt; str:\n    \"\"\"Return a canonical representation for DOI strings.\"\"\"\n    if not isinstance(value, str):\n        raise DoiLookupError(\"DOI must be provided as a string.\")\n    candidate = value.strip()\n    if not candidate:\n        raise DoiLookupError(\"DOI value is empty.\")\n\n    lowered = candidate.lower()\n    for prefix in (\n        \"https://doi.org/\",\n        \"http://doi.org/\",\n        \"https://dx.doi.org/\",\n        \"http://dx.doi.org/\",\n    ):\n        if lowered.startswith(prefix):\n            candidate = candidate[len(prefix) :]\n            break\n\n    candidate = candidate.strip()\n    if candidate.lower().startswith(\"doi:\"):\n        candidate = candidate.split(\":\", 1)[1]\n\n    candidate = candidate.strip().strip(\"/\")\n    if not candidate:\n        raise DoiLookupError(\"DOI value is empty.\")\n    return candidate\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.issues.BibliographyIssue","title":"BibliographyIssue  <code>dataclass</code>","text":"<pre><code>BibliographyIssue(\n    message: str,\n    key: str | None = None,\n    source: Path | None = None,\n)\n</code></pre> <p>Represents a problem encountered while loading bibliography entries.</p>"},{"location":"api/bibliography/#texsmith.core.bibliography.parsing.bibliography_data_from_inline_entry","title":"bibliography_data_from_inline_entry","text":"<pre><code>bibliography_data_from_inline_entry(\n    key: str, entry: InlineBibliographyEntry\n) -&gt; BibliographyData\n</code></pre> <p>Create a BibliographyData instance from a manual inline entry.</p> Source code in <code>src/texsmith/core/bibliography/parsing.py</code> <pre><code>def bibliography_data_from_inline_entry(\n    key: str,\n    entry: InlineBibliographyEntry,\n) -&gt; BibliographyData:\n    \"\"\"Create a BibliographyData instance from a manual inline entry.\"\"\"\n    if not entry.is_manual or not entry.entry_type:\n        raise ValueError(\"Inline entry must define a manual type before conversion.\")\n\n    persons_payload = {\n        role: [Person(name) for name in names] for role, names in entry.persons.items() if names\n    }\n\n    bib_entry = Entry(entry.entry_type, fields=dict(entry.fields), persons=persons_payload)\n    return BibliographyData(entries={key: bib_entry})\n</code></pre>"},{"location":"api/bibliography/#texsmith.core.bibliography.parsing.bibliography_data_from_string","title":"bibliography_data_from_string","text":"<pre><code>bibliography_data_from_string(\n    payload: str, key: str\n) -&gt; BibliographyData\n</code></pre> <p>Parse a BibTeX payload and scope it to a specific reference key.</p> Source code in <code>src/texsmith/core/bibliography/parsing.py</code> <pre><code>def bibliography_data_from_string(payload: str, key: str) -&gt; BibliographyData:\n    \"\"\"Parse a BibTeX payload and scope it to a specific reference key.\"\"\"\n    parser = bibtex.Parser()\n    try:\n        parsed = parser.parse_stream(io.StringIO(payload))\n    except (OSError, PybtexError) as exc:\n        raise PybtexError(f\"Failed to parse inline bibliography payload: {exc}\") from exc\n\n    entries = list(parsed.entries.items())\n    if not entries:\n        raise PybtexError(\"Inline bibliography payload does not contain an entry.\")\n    if len(entries) &gt; 1:\n        raise PybtexError(\"Inline bibliography payload must contain a single entry.\")\n\n    _, entry = entries[0]\n    return BibliographyData(entries={key: entry})\n</code></pre>"},{"location":"api/cli/","title":"CLI","text":"<p>Public CLI exports for TexSmith.</p> <p>Typer application wiring for the TeXSmith CLI.</p> <p>Shared CLI state management utilities.</p> <p>Auxiliary helpers used by CLI commands.</p> <p>Bibliography-related CLI helpers.</p> <p>CLI command implementations exposed via <code>texsmith.ui.cli</code>.</p> <p>This module exists primarily to make the <code>texsmith.ui.cli.commands</code> package importable for documentation tools such as mkdocstrings. It re-exports the Typer command factories defined in the sibling modules so downstream code can import them using dotted paths (e.g. <code>texsmith.ui.cli.commands.render</code>).</p>"},{"location":"api/cli/#texsmith.ui.cli.debug_enabled","title":"debug_enabled","text":"<pre><code>debug_enabled() -&gt; bool\n</code></pre> <p>Return whether full tracebacks should be displayed.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def debug_enabled() -&gt; bool:\n    \"\"\"Return whether full tracebacks should be displayed.\"\"\"\n    try:\n        return get_cli_state(create=False).show_tracebacks\n    except RuntimeError:\n        return False\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.emit_error","title":"emit_error","text":"<pre><code>emit_error(\n    message: str, *, exception: BaseException | None = None\n) -&gt; None\n</code></pre> <p>Log an error-level message to stderr respecting verbosity settings.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def emit_error(message: str, *, exception: BaseException | None = None) -&gt; None:\n    \"\"\"Log an error-level message to stderr respecting verbosity settings.\"\"\"\n    if exception is not None and getattr(exception, \"_texsmith_logged\", False):\n        return\n    render_message(\"error\", message, exception=exception)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.emit_warning","title":"emit_warning","text":"<pre><code>emit_warning(\n    message: str, *, exception: BaseException | None = None\n) -&gt; None\n</code></pre> <p>Log a warning-level message to stderr respecting verbosity settings.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def emit_warning(message: str, *, exception: BaseException | None = None) -&gt; None:\n    \"\"\"Log a warning-level message to stderr respecting verbosity settings.\"\"\"\n    render_message(\"warning\", message, exception=exception)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.ensure_rich_compat","title":"ensure_rich_compat","text":"<pre><code>ensure_rich_compat() -&gt; None\n</code></pre> <p>Patch Rich stub modules provided by tests to expose required attributes.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def ensure_rich_compat() -&gt; None:\n    \"\"\"Patch Rich stub modules provided by tests to expose required attributes.\"\"\"\n    import importlib.machinery\n    import sys as _sys\n    import types\n\n    rich_mod = _sys.modules.get(\"rich\")\n    if rich_mod is None:\n        return\n    if getattr(rich_mod, \"__spec__\", None) is None:\n        rich_mod.__spec__ = importlib.machinery.ModuleSpec(\"rich\", loader=None)\n\n    is_stub = getattr(rich_mod, \"__file__\", None) is None\n\n    if is_stub:\n        try:\n            import typer.core as typer_core\n\n            cast(Any, typer_core).HAS_RICH = False\n        except ImportError:  # pragma: no cover - typer not available\n            pass\n        try:\n            import typer.main as typer_main\n\n            cast(Any, typer_main).HAS_RICH = False\n        except ImportError:  # pragma: no cover - typer not available\n            pass\n\n    if not hasattr(rich_mod, \"box\"):\n        box_module = types.ModuleType(\"rich.box\")\n        cast(Any, box_module).SQUARE = object()\n        cast(Any, box_module).MINIMAL_DOUBLE_HEAD = object()\n        cast(Any, box_module).SIMPLE = object()\n        cast(Any, rich_mod).box = box_module\n        _sys.modules.setdefault(\"rich.box\", box_module)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.get_cli_state","title":"get_cli_state","text":"<pre><code>get_cli_state(\n    ctx: Context | Context | None = None,\n    *,\n    create: bool = True,\n) -&gt; CLIState\n</code></pre> <p>Return the CLI state associated with the active Typer context.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def get_cli_state(\n    ctx: typer.Context | click.Context | None = None,\n    *,\n    create: bool = True,\n) -&gt; CLIState:\n    \"\"\"Return the CLI state associated with the active Typer context.\"\"\"\n    if ctx is None:\n        try:\n            candidate = click.get_current_context(silent=True)\n        except RuntimeError:\n            candidate = None\n        if isinstance(candidate, typer.Context):\n            ctx = candidate\n\n    state: CLIState | None = None\n\n    if isinstance(ctx, typer.Context):\n        current_ctx: typer.Context | None = ctx\n        while current_ctx is not None:\n            obj = getattr(current_ctx, \"obj\", None)\n            if isinstance(obj, CLIState):\n                state = obj\n                break\n            current_ctx = getattr(current_ctx, \"parent\", None)\n        if state is None and create:\n            state = CLIState()\n            current_ctx = ctx\n            current_ctx.obj = state\n        if state is not None:\n            _STATE_VAR.set(state)\n\n    if state is None:\n        fallback = _STATE_VAR.get(None)\n        if fallback is None:\n            if not create:\n                raise RuntimeError(\"CLI state is not initialised for this context.\")\n            fallback = CLIState()\n            _STATE_VAR.set(fallback)\n        state = fallback\n\n    return state\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Entry point compatible with console scripts.</p> Source code in <code>src/texsmith/ui/cli/app.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Entry point compatible with console scripts.\"\"\"\n    try:\n        app()\n    except typer.Exit:\n        raise\n    except KeyboardInterrupt as exc:\n        if debug_enabled():\n            raise\n        emit_error(\"Operation cancelled by user.\", exception=exc)\n        raise typer.Exit(code=1) from exc\n    except SystemExit:\n        raise\n    except Exception as exc:  # pragma: no cover - defensive catch-all\n        from .state import get_cli_state\n\n        state = get_cli_state()\n        if state.show_tracebacks:\n            from rich.traceback import Traceback\n\n            tb = Traceback.from_exception(\n                type(exc),\n                exc,\n                exc.__traceback__,\n                show_locals=state.verbosity &gt;= 2,\n            )\n            state.err_console.print(tb)\n        else:\n            emit_error(str(exc), exception=exc)\n        raise typer.Exit(code=1) from exc\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.app.HelpOnEmptyCommand","title":"HelpOnEmptyCommand","text":"<pre><code>HelpOnEmptyCommand(*args: object, **kwargs: object)\n</code></pre> <p>               Bases: <code>TyperCommand</code></p> <p>Typer command that disables positional argument enforcement.</p> Source code in <code>src/texsmith/ui/cli/app.py</code> <pre><code>def __init__(self, *args: object, **kwargs: object) -&gt; None:  # type: ignore[override]\n    super().__init__(*args, **kwargs)\n    for param in self.params:\n        if isinstance(param, click.Argument):\n            param.required = False\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.app.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Entry point compatible with console scripts.</p> Source code in <code>src/texsmith/ui/cli/app.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Entry point compatible with console scripts.\"\"\"\n    try:\n        app()\n    except typer.Exit:\n        raise\n    except KeyboardInterrupt as exc:\n        if debug_enabled():\n            raise\n        emit_error(\"Operation cancelled by user.\", exception=exc)\n        raise typer.Exit(code=1) from exc\n    except SystemExit:\n        raise\n    except Exception as exc:  # pragma: no cover - defensive catch-all\n        from .state import get_cli_state\n\n        state = get_cli_state()\n        if state.show_tracebacks:\n            from rich.traceback import Traceback\n\n            tb = Traceback.from_exception(\n                type(exc),\n                exc,\n                exc.__traceback__,\n                show_locals=state.verbosity &gt;= 2,\n            )\n            state.err_console.print(tb)\n        else:\n            emit_error(str(exc), exception=exc)\n        raise typer.Exit(code=1) from exc\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.CLIState","title":"CLIState  <code>dataclass</code>","text":"<pre><code>CLIState(verbosity: int = 0, show_tracebacks: bool = False)\n</code></pre> <p>Shared state controlling CLI diagnostics.</p>"},{"location":"api/cli/#texsmith.ui.cli.state.CLIState.console","title":"console  <code>property</code>","text":"<pre><code>console: Console\n</code></pre> <p>Return a lazily instantiated stdout console.</p>"},{"location":"api/cli/#texsmith.ui.cli.state.CLIState.err_console","title":"err_console  <code>property</code>","text":"<pre><code>err_console: Console\n</code></pre> <p>Return a lazily instantiated stderr console.</p>"},{"location":"api/cli/#texsmith.ui.cli.state.CLIState.consume_events","title":"consume_events","text":"<pre><code>consume_events(name: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve and clear events for the given name.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def consume_events(self, name: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Retrieve and clear events for the given name.\"\"\"\n    return self.events.pop(name, [])\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.CLIState.record_event","title":"record_event","text":"<pre><code>record_event(\n    name: str, payload: Mapping[str, Any] | None = None\n) -&gt; None\n</code></pre> <p>Store a structured diagnostic event for later presentation.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def record_event(self, name: str, payload: Mapping[str, Any] | None = None) -&gt; None:\n    \"\"\"Store a structured diagnostic event for later presentation.\"\"\"\n    entry = dict(payload or {})\n    self.events.setdefault(name, []).append(entry)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.debug_enabled","title":"debug_enabled","text":"<pre><code>debug_enabled() -&gt; bool\n</code></pre> <p>Return whether full tracebacks should be displayed.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def debug_enabled() -&gt; bool:\n    \"\"\"Return whether full tracebacks should be displayed.\"\"\"\n    try:\n        return get_cli_state(create=False).show_tracebacks\n    except RuntimeError:\n        return False\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.emit_error","title":"emit_error","text":"<pre><code>emit_error(\n    message: str, *, exception: BaseException | None = None\n) -&gt; None\n</code></pre> <p>Log an error-level message to stderr respecting verbosity settings.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def emit_error(message: str, *, exception: BaseException | None = None) -&gt; None:\n    \"\"\"Log an error-level message to stderr respecting verbosity settings.\"\"\"\n    if exception is not None and getattr(exception, \"_texsmith_logged\", False):\n        return\n    render_message(\"error\", message, exception=exception)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.emit_warning","title":"emit_warning","text":"<pre><code>emit_warning(\n    message: str, *, exception: BaseException | None = None\n) -&gt; None\n</code></pre> <p>Log a warning-level message to stderr respecting verbosity settings.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def emit_warning(message: str, *, exception: BaseException | None = None) -&gt; None:\n    \"\"\"Log a warning-level message to stderr respecting verbosity settings.\"\"\"\n    render_message(\"warning\", message, exception=exception)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.ensure_rich_compat","title":"ensure_rich_compat","text":"<pre><code>ensure_rich_compat() -&gt; None\n</code></pre> <p>Patch Rich stub modules provided by tests to expose required attributes.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def ensure_rich_compat() -&gt; None:\n    \"\"\"Patch Rich stub modules provided by tests to expose required attributes.\"\"\"\n    import importlib.machinery\n    import sys as _sys\n    import types\n\n    rich_mod = _sys.modules.get(\"rich\")\n    if rich_mod is None:\n        return\n    if getattr(rich_mod, \"__spec__\", None) is None:\n        rich_mod.__spec__ = importlib.machinery.ModuleSpec(\"rich\", loader=None)\n\n    is_stub = getattr(rich_mod, \"__file__\", None) is None\n\n    if is_stub:\n        try:\n            import typer.core as typer_core\n\n            cast(Any, typer_core).HAS_RICH = False\n        except ImportError:  # pragma: no cover - typer not available\n            pass\n        try:\n            import typer.main as typer_main\n\n            cast(Any, typer_main).HAS_RICH = False\n        except ImportError:  # pragma: no cover - typer not available\n            pass\n\n    if not hasattr(rich_mod, \"box\"):\n        box_module = types.ModuleType(\"rich.box\")\n        cast(Any, box_module).SQUARE = object()\n        cast(Any, box_module).MINIMAL_DOUBLE_HEAD = object()\n        cast(Any, box_module).SIMPLE = object()\n        cast(Any, rich_mod).box = box_module\n        _sys.modules.setdefault(\"rich.box\", box_module)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.get_cli_state","title":"get_cli_state","text":"<pre><code>get_cli_state(\n    ctx: Context | Context | None = None,\n    *,\n    create: bool = True,\n) -&gt; CLIState\n</code></pre> <p>Return the CLI state associated with the active Typer context.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def get_cli_state(\n    ctx: typer.Context | click.Context | None = None,\n    *,\n    create: bool = True,\n) -&gt; CLIState:\n    \"\"\"Return the CLI state associated with the active Typer context.\"\"\"\n    if ctx is None:\n        try:\n            candidate = click.get_current_context(silent=True)\n        except RuntimeError:\n            candidate = None\n        if isinstance(candidate, typer.Context):\n            ctx = candidate\n\n    state: CLIState | None = None\n\n    if isinstance(ctx, typer.Context):\n        current_ctx: typer.Context | None = ctx\n        while current_ctx is not None:\n            obj = getattr(current_ctx, \"obj\", None)\n            if isinstance(obj, CLIState):\n                state = obj\n                break\n            current_ctx = getattr(current_ctx, \"parent\", None)\n        if state is None and create:\n            state = CLIState()\n            current_ctx = ctx\n            current_ctx.obj = state\n        if state is not None:\n            _STATE_VAR.set(state)\n\n    if state is None:\n        fallback = _STATE_VAR.get(None)\n        if fallback is None:\n            if not create:\n                raise RuntimeError(\"CLI state is not initialised for this context.\")\n            fallback = CLIState()\n            _STATE_VAR.set(fallback)\n        state = fallback\n\n    return state\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.render_message","title":"render_message","text":"<pre><code>render_message(\n    level: str,\n    message: str,\n    *,\n    exception: BaseException | None = None,\n) -&gt; None\n</code></pre> <p>Render a formatted message to the console, including optional diagnostics.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def render_message(\n    level: str,\n    message: str,\n    *,\n    exception: BaseException | None = None,\n) -&gt; None:\n    \"\"\"Render a formatted message to the console, including optional diagnostics.\"\"\"\n    state = get_cli_state()\n\n    if level == \"info\":\n        # Use a neutral console log for info to align with pipeline logging.\n        console = state.console\n        if getattr(console, \"log\", None):\n            console.log(message)\n        return\n\n    from rich.text import Text\n\n    style = \"red\" if level == \"error\" else \"yellow\"\n    label_style = f\"bold {style}\"\n    if hasattr(Text, \"assemble\"):\n        text = Text.assemble((f\"{level}: \", label_style), (message, style))\n    else:  # pragma: no cover - stub Text fallback\n        text = Text()\n        text.append(f\"{level}: \")\n        text.append(message)\n    extra_lines: list[str] = []\n    if exception is not None and state.verbosity &gt;= 1:\n        detail = str(exception).strip()\n        if detail and detail not in message:\n            extra_lines.append(detail)\n        extra_lines.append(f\"type: {type(exception).__name__}\")\n        notes = getattr(exception, \"__notes__\", None)\n        if notes:\n            extra_lines.extend(str(note) for note in notes)\n        if state.verbosity &gt;= 2:\n            chain = _exception_chain(exception)\n            if chain:\n                extra_lines.append(\"caused by:\")\n                extra_lines.extend(f\"  {entry}\" for entry in chain)\n        if state.verbosity &gt;= 3:\n            extra_lines.append(f\"repr: {exception!r}\")\n\n    if extra_lines:\n        if hasattr(text, \"append\"):\n            text.append(\"\\n\")\n            if hasattr(Text, \"assemble\"):\n                text.append(\"\\n\".join(extra_lines), style=style)\n            else:  # pragma: no cover - stub Text fallback\n                text.append(\"\\n\".join(extra_lines))\n        else:  # pragma: no cover - fallback if text is a plain string\n            text = f\"{text}\\n\" + \"\\n\".join(extra_lines)\n\n    console = state.err_console if level != \"info\" else state.console\n    if type(console).__name__.startswith(\"_Stub\"):  # pragma: no cover - stub Console fallback\n        target = sys.stderr if level != \"info\" else sys.stdout\n        print(text if isinstance(text, str) else str(text), file=target)\n    else:\n        console.print(text)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.state.set_cli_state","title":"set_cli_state","text":"<pre><code>set_cli_state(\n    *,\n    ctx: Context | None = None,\n    verbosity: int | None = None,\n    debug: bool | None = None,\n) -&gt; CLIState\n</code></pre> <p>Update the CLI state, returning the current instance.</p> Source code in <code>src/texsmith/ui/cli/state.py</code> <pre><code>def set_cli_state(\n    *,\n    ctx: typer.Context | None = None,\n    verbosity: int | None = None,\n    debug: bool | None = None,\n) -&gt; CLIState:\n    \"\"\"Update the CLI state, returning the current instance.\"\"\"\n    state = get_cli_state(ctx)\n    if verbosity is not None:\n        state.verbosity = max(0, verbosity)\n    if debug is not None:\n        state.show_tracebacks = debug\n    return state\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.determine_output_target","title":"determine_output_target","text":"<pre><code>determine_output_target(\n    template_selected: bool,\n    documents: list[Path],\n    output_option: Path | None,\n) -&gt; tuple[str, Path | None]\n</code></pre> <p>Infer where conversion output should be written based on CLI arguments.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def determine_output_target(\n    template_selected: bool,\n    documents: list[Path],\n    output_option: Path | None,\n) -&gt; tuple[str, Path | None]:\n    \"\"\"Infer where conversion output should be written based on CLI arguments.\"\"\"\n    if template_selected:\n        if output_option is None:\n            base_dir = documents[0].parent if documents else Path()\n            return \"template\", (base_dir / \"build\")\n        suffix = output_option.suffix.lower()\n        if suffix == \".pdf\":\n            return \"template-pdf\", output_option\n        if output_option.exists() and output_option.is_file():\n            raise typer.BadParameter(\"Template output must be a directory.\")\n        if suffix:\n            raise typer.BadParameter(\"Template output must be a directory path.\")\n        return \"template\", output_option\n\n    if output_option is None:\n        return \"stdout\", None\n\n    if output_option.exists() and output_option.is_dir():\n        return \"directory\", output_option\n\n    if output_option.suffix:\n        return \"file\", output_option\n\n    return \"directory\", output_option\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.looks_like_document_path","title":"looks_like_document_path","text":"<pre><code>looks_like_document_path(candidate: str) -&gt; bool\n</code></pre> <p>Return True when the string has an extension resembling a document.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def looks_like_document_path(candidate: str) -&gt; bool:\n    \"\"\"Return True when the string has an extension resembling a document.\"\"\"\n    suffix = Path(candidate).suffix.lower()\n    return bool(suffix) and suffix in {\n        \".md\",\n        \".markdown\",\n        \".mdown\",\n        \".mkd\",\n        \".html\",\n        \".htm\",\n    }\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.normalise_selector","title":"normalise_selector","text":"<pre><code>normalise_selector(selector: str | None) -&gt; str | None\n</code></pre> <p>Strip surrounding quotes and whitespace from user-provided selectors.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def normalise_selector(selector: str | None) -&gt; str | None:\n    \"\"\"Strip surrounding quotes and whitespace from user-provided selectors.\"\"\"\n    if selector is None:\n        return None\n    candidate = selector.strip()\n    if len(candidate) &gt;= 2 and candidate[0] == candidate[-1] and candidate[0] in {'\"', \"'\"}:\n        candidate = candidate[1:-1].strip()\n    return candidate or None\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.organise_slot_overrides","title":"organise_slot_overrides","text":"<pre><code>organise_slot_overrides(\n    values: Iterable[str] | None, documents: list[Path]\n) -&gt; tuple[\n    dict[Path, dict[str, str]],\n    dict[Path, list[SlotAssignment]],\n]\n</code></pre> <p>Produce slot selector overrides and assignments for downstream processing.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def organise_slot_overrides(\n    values: Iterable[str] | None,\n    documents: list[Path],\n) -&gt; tuple[dict[Path, dict[str, str]], dict[Path, list[SlotAssignment]]]:\n    \"\"\"Produce slot selector overrides and assignments for downstream processing.\"\"\"\n    tokens = parse_cli_slot_tokens(values)\n    assignments = resolve_slot_assignments(tokens, documents)\n\n    slot_overrides: dict[Path, dict[str, str]] = {}\n    for doc, entries in assignments.items():\n        if not entries:\n            continue\n        mapping = slot_overrides.setdefault(doc, {})\n        for entry in entries:\n            if entry.selector is not None:\n                mapping[entry.slot] = entry.selector\n\n    return slot_overrides, assignments\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.parse_cli_slot_tokens","title":"parse_cli_slot_tokens","text":"<pre><code>parse_cli_slot_tokens(\n    values: Iterable[str] | None,\n) -&gt; list[tuple[str, str | None, str | None, str]]\n</code></pre> <p>Tokenise slot overrides into (slot, path, selector, raw) tuples.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def parse_cli_slot_tokens(\n    values: Iterable[str] | None,\n) -&gt; list[tuple[str, str | None, str | None, str]]:\n    \"\"\"Tokenise slot overrides into (slot, path, selector, raw) tuples.\"\"\"\n    tokens: list[tuple[str, str | None, str | None, str]] = []\n    if not values:\n        return tokens\n\n    for raw in values:\n        if not isinstance(raw, str):\n            continue\n        entry = raw.strip()\n        if not entry:\n            continue\n        if \":\" not in entry:\n            raise typer.BadParameter(\n                f\"Invalid slot override '{raw}', expected format \"\n                f\"'slot:selector' or 'slot:file[:selector]'.\"\n            )\n        slot_name, remainder = entry.split(\":\", 1)\n        slot_name = slot_name.strip()\n        remainder = remainder.strip()\n        if not slot_name or not remainder:\n            raise typer.BadParameter(\n                f\"Invalid slot override '{raw}', expected format \"\n                f\"'slot:selector' or 'slot:file[:selector]'.\"\n            )\n\n        path_hint: str | None\n        selector_value: str | None\n        if \":\" in remainder:\n            path_part, selector_part = remainder.split(\":\", 1)\n            path_part = path_part.strip()\n            selector_value = normalise_selector(selector_part)\n            path_hint = path_part or None\n        else:\n            if looks_like_document_path(remainder):\n                path_hint = remainder\n                selector_value = None\n            else:\n                path_hint = None\n                selector_value = normalise_selector(remainder)\n\n        tokens.append((slot_name, path_hint, selector_value, raw))\n\n    return tokens\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.parse_slot_option","title":"parse_slot_option","text":"<pre><code>parse_slot_option(\n    values: Iterable[str] | None,\n) -&gt; dict[str, str]\n</code></pre> <p>Parse CLI slot overrides declared as 'slot:Section' pairs.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def parse_slot_option(values: Iterable[str] | None) -&gt; dict[str, str]:\n    \"\"\"Parse CLI slot overrides declared as 'slot:Section' pairs.\"\"\"\n    overrides: dict[str, str] = {}\n    if not values:\n        return overrides\n\n    for raw in values:\n        if not isinstance(raw, str):\n            continue\n        entry = raw.strip()\n        if not entry:\n            continue\n        if \":\" not in entry:\n            raise ValueError(f\"Invalid slot override '{raw}', expected format 'slot:Section'.\")\n        slot_name, selector = entry.split(\":\", 1)\n        slot_name = slot_name.strip()\n        selector = selector.strip()\n        if not slot_name or not selector:\n            raise ValueError(f\"Invalid slot override '{raw}', expected format 'slot:Section'.\")\n        overrides[slot_name] = selector\n\n    return overrides\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.resolve_slot_assignments","title":"resolve_slot_assignments","text":"<pre><code>resolve_slot_assignments(\n    tokens: list[tuple[str, str | None, str | None, str]],\n    documents: list[Path],\n) -&gt; dict[Path, list[SlotAssignment]]\n</code></pre> <p>Resolve parsed slot tokens against provided documents.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def resolve_slot_assignments(\n    tokens: list[tuple[str, str | None, str | None, str]],\n    documents: list[Path],\n) -&gt; dict[Path, list[SlotAssignment]]:\n    \"\"\"Resolve parsed slot tokens against provided documents.\"\"\"\n    assignments: dict[Path, list[SlotAssignment]] = {doc: [] for doc in documents}\n    if not tokens:\n        return assignments\n\n    resolved_index = {doc.resolve(): doc for doc in documents}\n    name_index: dict[str, list[Path]] = {}\n    for doc in documents:\n        name_index.setdefault(doc.name, []).append(doc)\n\n    for slot_name, path_hint, selector_value, raw in tokens:\n        target_doc: Path | None = None\n        if path_hint is None:\n            if len(documents) == 1:\n                target_doc = documents[0]\n            else:\n                raise typer.BadParameter(\n                    f\"slot override '{raw}' requires a document \"\n                    \"path when multiple inputs are provided.\"\n                )\n        else:\n            candidate_path = Path(path_hint)\n            resolved_candidate: Path | None = None\n            try:\n                base = (\n                    candidate_path if candidate_path.is_absolute() else Path.cwd() / candidate_path\n                )\n                resolved_candidate = base.resolve()\n            except OSError:\n                resolved_candidate = None\n\n            if resolved_candidate is not None and resolved_candidate in resolved_index:\n                target_doc = resolved_index[resolved_candidate]\n            else:\n                matches = name_index.get(candidate_path.name, [])\n                if len(matches) == 1:\n                    target_doc = matches[0]\n                elif len(matches) &gt; 1:\n                    raise typer.BadParameter(\n                        f\"slot override '{raw}' is ambiguous; multiple \"\n                        f\"documents match '{candidate_path.name}'.\"\n                    )\n\n        if target_doc is None:\n            raise typer.BadParameter(f\"slot override '{raw}' does not match any provided document.\")\n\n        selector_clean = selector_value\n        include_document = False\n        if selector_clean is None:\n            include_document = True\n        else:\n            token_lower = selector_clean.strip().lower()\n            if token_lower in {\"*\", DOCUMENT_SELECTOR_SENTINEL.lower()}:\n                include_document = True\n                selector_clean = None\n\n        assignments[target_doc].append(\n            SlotAssignment(\n                slot=slot_name, selector=selector_clean, include_document=include_document\n            )\n        )\n\n    return assignments\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.utils.write_output_file","title":"write_output_file","text":"<pre><code>write_output_file(target: Path, content: str) -&gt; None\n</code></pre> <p>Persist LATEX content to disk, creating parent directories as needed.</p> Source code in <code>src/texsmith/ui/cli/utils.py</code> <pre><code>def write_output_file(target: Path, content: str) -&gt; None:\n    \"\"\"Persist LaTeX content to disk, creating parent directories as needed.\"\"\"\n    try:\n        target.parent.mkdir(parents=True, exist_ok=True)\n        target.write_text(content, encoding=\"utf-8\")\n    except OSError as exc:  # pragma: no cover - filesystem errors\n        raise OSError(f\"Failed to write LaTeX output to '{target}': {exc}\") from exc\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.bibliography.build_reference_panel","title":"build_reference_panel","text":"<pre><code>build_reference_panel(\n    reference: Mapping[str, object],\n) -&gt; Panel\n</code></pre> <p>Create a Rich panel that visualises a single bibliography entry.</p> Source code in <code>src/texsmith/ui/cli/bibliography.py</code> <pre><code>def build_reference_panel(reference: Mapping[str, object]) -&gt; Panel:\n    \"\"\"Create a Rich panel that visualises a single bibliography entry.\"\"\"\n    from rich import box\n    from rich.panel import Panel\n    from rich.table import Table\n\n    raw_fields = reference.get(\"fields\")\n    fields: dict[str, Any]\n    if isinstance(raw_fields, Mapping):\n        fields = {str(key): value for key, value in raw_fields.items()}\n    else:\n        fields = {}\n    grid = Table.grid(padding=(0, 1))\n    grid.add_column(style=\"bold green\", no_wrap=True)\n    grid.add_column()\n\n    def _pop_field(*keys: str) -&gt; str | None:\n        for key in keys:\n            value = fields.pop(key, None)\n            if isinstance(value, bytes):\n                text = value.decode(\"utf-8\", errors=\"ignore\").strip()\n                if text:\n                    return text\n            elif isinstance(value, str):\n                text = value.strip()\n                if text:\n                    return text\n            elif value is not None:\n                return str(value)\n        return None\n\n    def _add_field(label: str, value: object) -&gt; None:\n        if value is None:\n            return\n        if isinstance(value, str) and not value.strip():\n            return\n        grid.add_row(label, str(value))\n\n    title = _pop_field(\"title\")\n    _add_field(\"Title\", title)\n\n    year = _pop_field(\"year\")\n    _add_field(\"Year\", year)\n\n    journal = _pop_field(\"journal\", \"booktitle\")\n    _add_field(\"Journal\", journal)\n\n    persons_block = reference.get(\"persons\")\n    if isinstance(persons_block, Mapping):\n        authors = persons_block.get(\"author\")\n        if isinstance(authors, Iterable):\n            cast_authors = cast(Sequence[Mapping[str, object]], tuple(authors))\n            _add_field(\"Authors\", format_person_list(cast_authors))\n\n    sources = [\n        str(Path(str(path))) for path in _iterable_items(reference.get(\"source_files\")) if path\n    ]\n    if sources:\n        formatted_sources = \", \".join(sources)\n        _add_field(\"Sources\", formatted_sources)\n\n    for key, value in sorted(fields.items()):\n        _add_field(key.title(), value)\n\n    key = str(reference.get(\"key\", \"Reference\"))\n    entry_type = str(reference.get(\"type\", \"reference\"))\n    title = f\"{key} ({entry_type})\"\n    return Panel(grid, title=title, box=box.SIMPLE)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.bibliography.format_bibliography_person","title":"format_bibliography_person","text":"<pre><code>format_bibliography_person(\n    person: Mapping[str, object],\n) -&gt; str\n</code></pre> <p>Render a bibliography person dictionary into a readable string.</p> Source code in <code>src/texsmith/ui/cli/bibliography.py</code> <pre><code>def format_bibliography_person(person: Mapping[str, object]) -&gt; str:\n    \"\"\"Render a bibliography person dictionary into a readable string.\"\"\"\n    parts: list[str] = []\n    for field in (\"first\", \"middle\", \"prelast\", \"last\", \"lineage\"):\n        value = person.get(field)\n        if isinstance(value, str):\n            text = value.strip()\n            if text:\n                parts.append(text)\n            continue\n        for segment in _iterable_items(value):\n            if segment:\n                parts.append(str(segment))\n\n    text = \" \".join(part for part in parts if part)\n    if text:\n        return text\n    fallback = person.get(\"text\")\n    return str(fallback).strip() if isinstance(fallback, str) else \"\"\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.bibliography.format_person_list","title":"format_person_list","text":"<pre><code>format_person_list(\n    persons: Iterable[Mapping[str, object]],\n) -&gt; str\n</code></pre> <p>Join a sequence of person dictionaries into a comma-separated string.</p> Source code in <code>src/texsmith/ui/cli/bibliography.py</code> <pre><code>def format_person_list(persons: Iterable[Mapping[str, object]]) -&gt; str:\n    \"\"\"Join a sequence of person dictionaries into a comma-separated string.\"\"\"\n    names = [format_bibliography_person(person) for person in persons]\n    return \", \".join(name for name in names if name)\n</code></pre>"},{"location":"api/cli/#texsmith.ui.cli.bibliography.print_bibliography_overview","title":"print_bibliography_overview","text":"<pre><code>print_bibliography_overview(\n    collection: BibliographyCollection,\n) -&gt; None\n</code></pre> <p>Render a formatted summary of bibliography files, issues, and entries.</p> Source code in <code>src/texsmith/ui/cli/bibliography.py</code> <pre><code>def print_bibliography_overview(collection: BibliographyCollection) -&gt; None:\n    \"\"\"Render a formatted summary of bibliography files, issues, and entries.\"\"\"\n    ensure_rich_compat()\n    try:\n        from rich import box\n        from rich.table import Table\n        from rich.text import Text\n    except ImportError:  # pragma: no cover - fallback when Rich is unavailable\n        _print_bibliography_plain(collection)\n        return\n\n    console = get_cli_state().console\n    references = collection.list_references()\n\n    def _summarise_sources() -&gt; tuple[Counter[Path], int, int, int]:\n        per_file: Counter[Path] = Counter()\n        frontmatter = 0\n        doi = 0\n        for reference in references:\n            raw_sources = reference.get(\"source_files\") or []\n            sources = {Path(str(src)) for src in raw_sources if src}\n            if not sources:\n                continue\n            for src in sources:\n                per_file[src] += 1\n            names = {src.name.lower() for src in sources}\n            if any(\"frontmatter\" in name for name in names):\n                frontmatter += 1\n            if any(\"doi\" in name for name in names):\n                doi += 1\n        total = len(references)\n        return per_file, total, frontmatter, doi\n\n    per_file_counts, total_entries, frontmatter_entries, doi_entries = _summarise_sources()\n\n    stats = collection.file_stats\n    if stats:\n        stats_table = Table(\n            title=\"Bibliography Files\",\n            box=box.SQUARE,\n            show_edge=True,\n            header_style=\"bold cyan\",\n        )\n        stats_table.add_column(\"File\", overflow=\"fold\")\n        stats_table.add_column(\"Entries\", justify=\"right\")\n        for file_path, entry_count in stats:\n            stats_table.add_row(str(file_path), str(entry_count))\n        stats_table.add_row(\n            Text(\"Total\", style=\"bold\"), Text(str(sum(count for _, count in stats)))\n        )\n        console.print(stats_table)\n\n    if collection.issues:\n        issue_table = Table(\n            title=\"Warnings\",\n            box=box.SQUARE,\n            header_style=\"bold cyan\",\n            show_edge=True,\n        )\n        issue_table.add_column(\"Key\", style=\"yellow\", no_wrap=True)\n        issue_table.add_column(\"Message\", style=\"yellow\")\n        issue_table.add_column(\"Sources\", style=\"yellow\")\n        for issue in collection.issues:\n            issue_table.add_row(\n                issue.key or \"\u2014\",\n                issue.message,\n                str(issue.source) if issue.source else \"\u2014\",\n            )\n        console.print(issue_table)\n\n    if not references:\n        console.print(\"[dim]No references found.[/]\")\n        summary_table = Table(\n            title=\"Bibliography Summary\",\n            box=box.SQUARE,\n            header_style=\"bold cyan\",\n            show_edge=True,\n        )\n        summary_table.add_column(\"Category\", style=\"bold\")\n        summary_table.add_column(\"Count\", justify=\"right\")\n        summary_table.add_row(\"Total entries\", str(total_entries))\n        if per_file_counts:\n            for path, count in per_file_counts.most_common():\n                summary_table.add_row(f\"From {path.name}\", str(count))\n        summary_table.add_row(\"From front matter\", str(frontmatter_entries))\n        summary_table.add_row(\"From DOI fetches\", str(doi_entries))\n        console.print(summary_table)\n        return\n\n    for reference in references:\n        panel = build_reference_panel(reference)\n        console.print(panel)\n        console.print()\n\n    summary_table = Table(\n        title=\"Bibliography Summary\",\n        box=box.SQUARE,\n        header_style=\"bold cyan\",\n        show_edge=True,\n    )\n    summary_table.add_column(\"Category\", style=\"bold\")\n    summary_table.add_column(\"Count\", justify=\"right\")\n    summary_table.add_row(\"Total entries\", str(total_entries))\n    if per_file_counts:\n        for path, count in per_file_counts.most_common():\n            summary_table.add_row(f\"From {path.name}\", str(count))\n    summary_table.add_row(\"From front matter\", str(frontmatter_entries))\n    summary_table.add_row(\"From DOI fetches\", str(doi_entries))\n    console.print(summary_table)\n</code></pre>"},{"location":"api/core/","title":"Core","text":"<p>Configuration models used by the LATEX renderer.</p> <p>CommonConfig</p> <code>build_dir</code> (<code>Path | None</code>) Base directory for LATEX artifacts. Provide an absolute or project-relative   path to override the default export root that books inherit when they do not   specify one. <code>save_html</code> (<code>bool</code>) Persist the intermediate HTML render next to the PDF to aid troubleshooting   before LATEX compilation. <code>mermaid_config</code> (<code>Path | None</code>) Path to a Mermaid configuration file. Point to a <code>.json</code> or <code>.mermaid</code>   document to customise diagram rendering. <code>project_dir</code> (<code>Path | None</code>) MkDocs project root used to resolve relative paths when copying additional   assets. BCP 47 language code forwarded to LATEX for hyphenation, translations, and metadata localisation. <code>legacy_latex_accents</code> (<code>bool</code>) When <code>True</code>, escape accented characters, ligatures, and typographic punctuation   using legacy LATEX macros. When <code>False</code>, keep Unicode glyphs compatible with   LuaLaTeX/XeLaTeX (default). <code>language</code> (<code>str | None</code>) BCP 47 language code forwarded to LATEX for hyphenation, translations, and   metadata localisation. <p>CoverConfig</p> <code>name</code> (<code>str</code>) Identifier of the cover template to apply. The value must match a template   declared in the cover bundle. <code>color</code> (<code>str | None</code>) Primary colour override applied by the cover template. <code>logo</code> (<code>str | None</code>) Project-relative path to a logo asset displayed on the cover. <p>BookConfig</p> <code>root</code> (<code>str | None</code>) Navigation entry treated as the starting point for the book. Use it when the   root differs from the first MkDocs page. <code>title</code> (<code>str | None</code>) Title displayed on the cover and in output metadata. Falls back to <code>site_name</code>   when omitted. <code>subtitle</code> (<code>str | None</code>) Optional subtitle appended to the cover and metadata. <code>author</code> (<code>str | None</code>) Primary author string rendered in the book metadata. <code>year</code> (<code>int | None</code>) Publication year to freeze in the output when <code>site_date</code> is not supplied. <code>email</code> (<code>str | None</code>) Contact address printed in the credits. <code>folder</code> (<code>Path | None</code>) Output directory for the rendered book. Defaults to a slug of the title when   not provided. <code>frontmatter</code> (<code>list[str]</code>) MkDocs page titles moved before the main matter. <code>backmatter</code> (<code>list[str]</code>) MkDocs page titles grouped into the appendices. <code>base_level</code> (<code>int</code>) Heading offset applied to align section numbering with the template   expectations. <code>copy_files</code> (<code>dict[str, str]</code>) Mapping of glob patterns to destination paths for copying additional assets   alongside the book. <code>index_is_foreword</code> (<code>bool</code>) Treat the <code>index</code> page as a foreword, typically removing numbering. <code>drop_title_index</code> (<code>bool</code>) Suppress the <code>index</code> page heading when it acts as a foreword. <code>cover</code> (<code>CoverConfig</code>) Nested configuration controlling the book cover. <p>LaTeXConfig</p> <code>enabled</code> (<code>bool</code>) Toggle LATEX generation without discarding configuration. <code>books</code> (<code>list[BookConfig]</code>) Collection of books to produce, inheriting defaults from <code>CommonConfig</code>. <code>clean_assets</code> (<code>bool</code>) Remove stale assets from <code>build_dir</code> to avoid accumulating unused files. <p>Rendering context primitives shared across the LATEX pipeline.</p> <p>Context objects used during document conversion.</p> <p>Shared conversion primitives exposed by the core package.</p>"},{"location":"api/core/#texsmith.core.config.BookConfig","title":"BookConfig","text":"<p>               Bases: <code>CommonConfig</code></p> <p>Configuration for an individual book.</p>"},{"location":"api/core/#texsmith.core.config.BookConfig.set_folder","title":"set_folder","text":"<pre><code>set_folder() -&gt; BookConfig\n</code></pre> <p>Populate the output folder from the book title when missing.</p> Source code in <code>src/texsmith/core/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_folder(self) -&gt; BookConfig:\n    \"\"\"Populate the output folder from the book title when missing.\"\"\"\n    if self.folder is None and self.title:\n        self.folder = Path(slugify(self.title, separator=\"-\"))\n    return self\n</code></pre>"},{"location":"api/core/#texsmith.core.config.CommonConfig","title":"CommonConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common configuration propagated to each book.</p>"},{"location":"api/core/#texsmith.core.config.CoverConfig","title":"CoverConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata used to render book covers.</p>"},{"location":"api/core/#texsmith.core.config.LaTeXConfig","title":"LaTeXConfig","text":"<p>               Bases: <code>CommonConfig</code></p> <p>Configuration for LATEX taken from <code>mkdocs.yml</code>.</p>"},{"location":"api/core/#texsmith.core.config.LaTeXConfig.add_extra","title":"add_extra","text":"<pre><code>add_extra(**extra_data: Any) -&gt; None\n</code></pre> <p>Allow consumers to attach additional attributes at runtime.</p> Source code in <code>src/texsmith/core/config.py</code> <pre><code>def add_extra(self, **extra_data: Any) -&gt; None:\n    \"\"\"Allow consumers to attach additional attributes at runtime.\"\"\"\n    for key, value in extra_data.items():\n        object.__setattr__(self, key, value)\n</code></pre>"},{"location":"api/core/#texsmith.core.config.LaTeXConfig.propagate","title":"propagate","text":"<pre><code>propagate() -&gt; LaTeXConfig\n</code></pre> <p>Propagate common values to nested book configurations.</p> Source code in <code>src/texsmith/core/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef propagate(self) -&gt; LaTeXConfig:\n    \"\"\"Propagate common values to nested book configurations.\"\"\"\n    to_propagate = (\n        \"build_dir\",\n        \"mermaid_config\",\n        \"save_html\",\n        \"project_dir\",\n        \"language\",\n    )\n    for book in self.books:\n        for key in to_propagate:\n            if getattr(book, key) is None:\n                setattr(book, key, getattr(self, key))\n    return self\n</code></pre>"},{"location":"api/core/#texsmith.core.context.AssetRegistry","title":"AssetRegistry  <code>dataclass</code>","text":"<pre><code>AssetRegistry(\n    output_root: Path,\n    assets_map: MutableMapping[str, Path] = dict(),\n    copy_assets: bool = True,\n)\n</code></pre> <p>Centralised registry for rendered assets.</p>"},{"location":"api/core/#texsmith.core.context.AssetRegistry.get","title":"get","text":"<pre><code>get(key: str) -&gt; Path\n</code></pre> <p>Retrieve a previously registered artefact.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def get(self, key: str) -&gt; Path:\n    \"\"\"Retrieve a previously registered artefact.\"\"\"\n    try:\n        return Path(self.assets_map[key])\n    except KeyError as exc:\n        raise AssetMissingError(f\"Missing asset '{key}'\") from exc\n</code></pre>"},{"location":"api/core/#texsmith.core.context.AssetRegistry.items","title":"items","text":"<pre><code>items() -&gt; Iterable[tuple[str, Path]]\n</code></pre> <p>Iterate over registered assets yielding key/path pairs.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, Path]]:\n    \"\"\"Iterate over registered assets yielding key/path pairs.\"\"\"\n    return ((k, Path(v)) for k, v in self.assets_map.items())\n</code></pre>"},{"location":"api/core/#texsmith.core.context.AssetRegistry.latex_path","title":"latex_path","text":"<pre><code>latex_path(path: Path | str) -&gt; str\n</code></pre> <p>Return a LATEX-friendly path for an artefact.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def latex_path(self, path: Path | str) -&gt; str:\n    \"\"\"Return a LaTeX-friendly path for an artefact.\"\"\"\n    candidate = Path(path)\n    if not candidate.is_absolute():\n        return candidate.as_posix()\n\n    output_dir = self.output_root.parent\n    try:\n        reference = candidate.relative_to(output_dir)\n    except ValueError:\n        try:\n            reference = Path(os.path.relpath(candidate, output_dir))\n        except ValueError:\n            reference = candidate\n\n    return reference.as_posix()\n</code></pre>"},{"location":"api/core/#texsmith.core.context.AssetRegistry.lookup","title":"lookup","text":"<pre><code>lookup(key: str) -&gt; Path | None\n</code></pre> <p>Return a previously registered artefact when available.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def lookup(self, key: str) -&gt; Path | None:\n    \"\"\"Return a previously registered artefact when available.\"\"\"\n    stored = self.assets_map.get(key)\n    return Path(stored) if stored is not None else None\n</code></pre>"},{"location":"api/core/#texsmith.core.context.AssetRegistry.register","title":"register","text":"<pre><code>register(key: str, artefact: Path | str) -&gt; Path\n</code></pre> <p>Register a generated artefact and return its resolved path.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def register(self, key: str, artefact: Path | str) -&gt; Path:\n    \"\"\"Register a generated artefact and return its resolved path.\"\"\"\n    path = Path(artefact)\n    if not path.is_absolute():\n        path = (self.output_root / path).resolve() if self.copy_assets else Path(path)\n    self.assets_map[key] = path\n    return path\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState","title":"DocumentState  <code>dataclass</code>","text":"<pre><code>DocumentState(\n    abbreviations: dict[str, str] = dict(),\n    acronym_keys: dict[str, str] = dict(),\n    acronyms: dict[str, tuple[str, str]] = dict(),\n    glossary: dict[str, dict[str, Any]] = dict(),\n    snippets: dict[str, dict[str, Any]] = dict(),\n    solutions: list[dict[str, Any]] = list(),\n    headings: list[dict[str, Any]] = list(),\n    exercise_counter: int = 0,\n    has_index_entries: bool = False,\n    requires_shell_escape: bool = False,\n    counters: dict[str, int] = dict(),\n    bibliography: dict[str, dict[str, Any]] = dict(),\n    citations: list[str] = list(),\n    footnotes: dict[str, str] = dict(),\n    index_entries: list[tuple[str, ...]] = list(),\n    pygments_styles: dict[str, str] = dict(),\n    script_usage: list[dict[str, Any]] = list(),\n    fallback_summary: list[dict[str, Any]] = list(),\n    callouts_used: bool = False,\n)\n</code></pre> <p>In-memory state accumulated while rendering a document.</p>"},{"location":"api/core/#texsmith.core.context.DocumentState.add_heading","title":"add_heading","text":"<pre><code>add_heading(\n    *, level: int, text: str, ref: str | None = None\n) -&gt; None\n</code></pre> <p>Track heading metadata to power table-of-contents generation.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def add_heading(self, *, level: int, text: str, ref: str | None = None) -&gt; None:\n    \"\"\"Track heading metadata to power table-of-contents generation.\"\"\"\n    self.headings.append({\"level\": level, \"text\": text, \"ref\": ref})\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.add_solution","title":"add_solution","text":"<pre><code>add_solution(solution: dict[str, Any]) -&gt; None\n</code></pre> <p>Append a solution block encountered during parsing.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def add_solution(self, solution: dict[str, Any]) -&gt; None:\n    \"\"\"Append a solution block encountered during parsing.\"\"\"\n    self.solutions.append(solution)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.next_counter","title":"next_counter","text":"<pre><code>next_counter(key: str = 'default') -&gt; int\n</code></pre> <p>Increment and return the named counter.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def next_counter(self, key: str = \"default\") -&gt; int:\n    \"\"\"Increment and return the named counter.\"\"\"\n    value = self.counters.get(key, 0) + 1\n    self.counters[key] = value\n    return value\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.next_exercise","title":"next_exercise","text":"<pre><code>next_exercise() -&gt; int\n</code></pre> <p>Increment and return the exercise counter.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def next_exercise(self) -&gt; int:\n    \"\"\"Increment and return the exercise counter.\"\"\"\n    counter = self.next_counter(\"exercise\")\n    self.exercise_counter = counter\n    return counter\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.peek_counter","title":"peek_counter","text":"<pre><code>peek_counter(key: str = 'default') -&gt; int\n</code></pre> <p>Return the current value of the named counter without modifying it.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def peek_counter(self, key: str = \"default\") -&gt; int:\n    \"\"\"Return the current value of the named counter without modifying it.\"\"\"\n    return self.counters.get(key, 0)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.record_citation","title":"record_citation","text":"<pre><code>record_citation(key: str) -&gt; None\n</code></pre> <p>Track citation keys used throughout the document.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def record_citation(self, key: str) -&gt; None:\n    \"\"\"Track citation keys used throughout the document.\"\"\"\n    if key in self._citation_index:\n        return\n    self._citation_index.add(key)\n    self.citations.append(key)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.register_snippet","title":"register_snippet","text":"<pre><code>register_snippet(key: str, payload: dict[str, Any]) -&gt; None\n</code></pre> <p>Cache snippet metadata to render later in the pipeline.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def register_snippet(self, key: str, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Cache snippet metadata to render later in the pipeline.\"\"\"\n    self.snippets[key] = payload\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.remember_abbreviation","title":"remember_abbreviation","text":"<pre><code>remember_abbreviation(term: str, description: str) -&gt; str\n</code></pre> <p>Track abbreviation definitions while ensuring consistency.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def remember_abbreviation(self, term: str, description: str) -&gt; str:\n    \"\"\"Track abbreviation definitions while ensuring consistency.\"\"\"\n    normalised_term = term.strip()\n    normalised_description = description.strip()\n    if not normalised_term or not normalised_description:\n        return \"\"\n\n    existing_description = self.abbreviations.get(normalised_term)\n    if existing_description is not None:\n        if existing_description != normalised_description:\n            warnings.warn(\n                (\n                    f\"Inconsistent acronym definition for '{normalised_term}': \"\n                    f\"'{existing_description}' vs '{normalised_description}'\"\n                ),\n                stacklevel=2,\n            )\n        return self.acronym_keys.get(normalised_term, \"\")\n\n    key = self._generate_acronym_key(normalised_term)\n    self.abbreviations[normalised_term] = normalised_description\n    self.acronym_keys[normalised_term] = key\n    self.acronyms[key] = (normalised_term, normalised_description)\n    return key\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.remember_acronym","title":"remember_acronym","text":"<pre><code>remember_acronym(term: str, description: str) -&gt; str\n</code></pre> <p>Register an acronym definition keyed by a normalised identifier.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def remember_acronym(self, term: str, description: str) -&gt; str:\n    \"\"\"Register an acronym definition keyed by a normalised identifier.\"\"\"\n    return self.remember_abbreviation(term=term, description=description)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.remember_glossary","title":"remember_glossary","text":"<pre><code>remember_glossary(key: str, entry: dict[str, Any]) -&gt; None\n</code></pre> <p>Record a glossary entry keyed by its identifier.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def remember_glossary(self, key: str, entry: dict[str, Any]) -&gt; None:\n    \"\"\"Record a glossary entry keyed by its identifier.\"\"\"\n    self.glossary[key] = entry\n</code></pre>"},{"location":"api/core/#texsmith.core.context.DocumentState.reset_counter","title":"reset_counter","text":"<pre><code>reset_counter(key: str) -&gt; None\n</code></pre> <p>Clear the named counter if it has been tracked.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def reset_counter(self, key: str) -&gt; None:\n    \"\"\"Clear the named counter if it has been tracked.\"\"\"\n    self.counters.pop(key, None)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext","title":"RenderContext  <code>dataclass</code>","text":"<pre><code>RenderContext(\n    config: BookConfig,\n    formatter: LaTeXFormatter,\n    document: Any,\n    assets: AssetRegistry,\n    state: DocumentState = DocumentState(),\n    runtime: dict[str, Any] = dict(),\n    phase: RenderPhase | None = None,\n)\n</code></pre> <p>Shared context passed to every handler during rendering.</p>"},{"location":"api/core/#texsmith.core.context.RenderContext.attach_runtime","title":"attach_runtime","text":"<pre><code>attach_runtime(**runtime: Any) -&gt; None\n</code></pre> <p>Attach ad-hoc data visible to handlers for the running phase.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def attach_runtime(self, **runtime: Any) -&gt; None:\n    \"\"\"Attach ad-hoc data visible to handlers for the running phase.\"\"\"\n    self._persistent_runtime.update(runtime)\n    self.runtime.update(runtime)\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext.enter_phase","title":"enter_phase","text":"<pre><code>enter_phase(phase: RenderPhase) -&gt; None\n</code></pre> <p>Mark the current phase and reset transient runtime data.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def enter_phase(self, phase: RenderPhase) -&gt; None:\n    \"\"\"Mark the current phase and reset transient runtime data.\"\"\"\n    self.phase = phase\n    self.runtime = dict(self._persistent_runtime)\n    self._skip_children[phase.value].clear()\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext.is_processed","title":"is_processed","text":"<pre><code>is_processed(\n    node: Any, *, phase: RenderPhase | None = None\n) -&gt; bool\n</code></pre> <p>Check whether a node has been processed in the given phase.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def is_processed(self, node: Any, *, phase: RenderPhase | None = None) -&gt; bool:\n    \"\"\"Check whether a node has been processed in the given phase.\"\"\"\n    label = phase or self.phase\n    if label is None:\n        return False\n    return id(node) in self._processed_nodes[label.value]\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext.mark_processed","title":"mark_processed","text":"<pre><code>mark_processed(\n    node: Any, *, phase: RenderPhase | None = None\n) -&gt; None\n</code></pre> <p>Flag a node as already transformed for the selected phase.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def mark_processed(self, node: Any, *, phase: RenderPhase | None = None) -&gt; None:\n    \"\"\"Flag a node as already transformed for the selected phase.\"\"\"\n    label = phase or self.phase\n    if label is None:\n        return\n    self._processed_nodes[label.value].add(id(node))\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext.should_skip_children","title":"should_skip_children","text":"<pre><code>should_skip_children(\n    node: Any, *, phase: RenderPhase | None = None\n) -&gt; bool\n</code></pre> <p>Check whether children should be skipped during traversal.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def should_skip_children(self, node: Any, *, phase: RenderPhase | None = None) -&gt; bool:\n    \"\"\"Check whether children should be skipped during traversal.\"\"\"\n    label = phase or self.phase\n    if label is None:\n        return False\n    return id(node) in self._skip_children[label.value]\n</code></pre>"},{"location":"api/core/#texsmith.core.context.RenderContext.suppress_children","title":"suppress_children","text":"<pre><code>suppress_children(\n    node: Any, *, phase: RenderPhase | None = None\n) -&gt; None\n</code></pre> <p>Prevent traversal of node children for the active phase.</p> Source code in <code>src/texsmith/core/context.py</code> <pre><code>def suppress_children(self, node: Any, *, phase: RenderPhase | None = None) -&gt; None:\n    \"\"\"Prevent traversal of node children for the active phase.\"\"\"\n    label = phase or self.phase\n    if label is None:\n        return\n    self._skip_children[label.value].add(id(node))\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion_contexts.AssetMapping","title":"AssetMapping  <code>dataclass</code>","text":"<pre><code>AssetMapping(\n    source: Path, target: Path, kind: str | None = None\n)\n</code></pre> <p>Describe how a source asset should be persisted for LATEX generation.</p>"},{"location":"api/core/#texsmith.core.conversion_contexts.BinderContext","title":"BinderContext  <code>dataclass</code>","text":"<pre><code>BinderContext(\n    output_dir: Path,\n    config: BookConfig,\n    strategy: GenerationStrategy,\n    language: str,\n    slot_requests: dict[str, str],\n    template_overrides: dict[str, Any],\n    bibliography_map: dict[str, dict[str, Any]] = dict(),\n    bibliography_collection: BibliographyCollection\n    | None = None,\n    template_binding: TemplateBinding | None = None,\n    documents: list[Document] = list(),\n    bound_segments: dict[\n        str, list[SegmentContext]\n    ] = dict(),\n)\n</code></pre> <p>Binder-level context describing template binding and global state.</p>"},{"location":"api/core/#texsmith.core.conversion_contexts.GenerationStrategy","title":"GenerationStrategy  <code>dataclass</code>","text":"<pre><code>GenerationStrategy(\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n    prefer_inputs: bool = False,\n    persist_manifest: bool = False,\n)\n</code></pre> <p>Rendering strategy toggles shared across conversion workflows.</p>"},{"location":"api/core/#texsmith.core.conversion_contexts.SegmentContext","title":"SegmentContext  <code>dataclass</code>","text":"<pre><code>SegmentContext(\n    name: str,\n    html: str,\n    base_level: int,\n    metadata: Mapping[str, Any] = dict(),\n    bibliography: Mapping[str, Any] = dict(),\n    assets: list[AssetMapping] = list(),\n    destination: Path | None = None,\n)\n</code></pre> <p>Represent a fragment destined for insertion into a template slot.</p>"},{"location":"api/core/#texsmith.core.conversion.ConversionRequest","title":"ConversionRequest  <code>dataclass</code>","text":"<pre><code>ConversionRequest(\n    documents: Sequence[Path] = tuple(),\n    bibliography_files: Sequence[Path] = list(),\n    front_matter: Mapping[str, Any] | None = None,\n    front_matter_path: Path | None = None,\n    slot_assignments: Mapping[\n        Path, Sequence[SlotAssignment]\n    ] = dict(),\n    selector: str = \"article.md-content__inner\",\n    full_document: bool = False,\n    base_level: int = 0,\n    strip_heading_all: bool = False,\n    strip_heading_first_document: bool = False,\n    promote_title: bool = True,\n    suppress_title: bool = False,\n    numbered: bool = True,\n    markdown_extensions: Sequence[str] = list(),\n    template: str | None = None,\n    render_dir: Path | None = None,\n    template_options: Mapping[str, Any] = dict(),\n    embed_fragments: bool = False,\n    enable_fragments: Sequence[str] = tuple(),\n    disable_fragments: Sequence[str] = tuple(),\n    parser: str | None = None,\n    disable_fallback_converters: bool = False,\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n    manifest: bool = False,\n    persist_debug_html: bool = False,\n    language: str | None = None,\n    http_user_agent: str | None = None,\n    legacy_latex_accents: bool = False,\n    diagrams_backend: str | None = None,\n    emitter: DiagnosticEmitter | None = None,\n)\n</code></pre> <p>Immutable description of conversion inputs and engine settings.</p>"},{"location":"api/core/#texsmith.core.conversion.ConversionRequest.copy","title":"copy","text":"<pre><code>copy() -&gt; ConversionRequest\n</code></pre> <p>Create a deep copy to avoid cross-run mutations.</p> Source code in <code>src/texsmith/core/conversion/models.py</code> <pre><code>def copy(self) -&gt; ConversionRequest:\n    \"\"\"Create a deep copy to avoid cross-run mutations.\"\"\"\n    payload: dict[str, Any] = {}\n    for definition in fields(self):\n        value = getattr(self, definition.name)\n        if definition.name == \"emitter\":\n            payload[definition.name] = value\n        else:\n            payload[definition.name] = copy.deepcopy(value)\n    return ConversionRequest(**payload)\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion.InputKind","title":"InputKind","text":"<p>               Bases: <code>Enum</code></p> <p>Supported input modalities handled by the conversion pipeline.</p>"},{"location":"api/core/#texsmith.core.conversion.SlotAssignment","title":"SlotAssignment  <code>dataclass</code>","text":"<pre><code>SlotAssignment(\n    slot: str, selector: str | None, include_document: bool\n)\n</code></pre> <p>Directive mapping a document onto a template slot.</p>"},{"location":"api/core/#texsmith.core.conversion.UnsupportedInputError","title":"UnsupportedInputError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a CLI input argument cannot be processed.</p>"},{"location":"api/core/#texsmith.core.conversion.coerce_slot_selector","title":"coerce_slot_selector","text":"<pre><code>coerce_slot_selector(payload: Any) -&gt; str | None\n</code></pre> <p>Normalise a selector definition coming from front matter.</p> Source code in <code>src/texsmith/core/conversion/inputs.py</code> <pre><code>def coerce_slot_selector(payload: Any) -&gt; str | None:\n    \"\"\"Normalise a selector definition coming from front matter.\"\"\"\n    if isinstance(payload, str):\n        candidate = payload.strip()\n        return candidate or None\n    if isinstance(payload, Mapping):\n        for key in (\"label\", \"title\", \"section\"):\n            value = payload.get(key)\n            if isinstance(value, str) and value.strip():\n                return value.strip()\n    return None\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion.extract_content","title":"extract_content","text":"<pre><code>extract_content(html: str, selector: str) -&gt; str\n</code></pre> <p>Extract and return the inner HTML for the first element matching selector.</p> Source code in <code>src/texsmith/core/conversion/inputs.py</code> <pre><code>def extract_content(html: str, selector: str) -&gt; str:\n    \"\"\"Extract and return the inner HTML for the first element matching selector.\"\"\"\n    try:\n        soup = BeautifulSoup(html, \"lxml\")\n    except FeatureNotFound:\n        soup = BeautifulSoup(html, \"html.parser\")\n\n    element = soup.select_one(selector)\n    if element is None:\n        raise ValueError(f\"Unable to locate content using selector '{selector}'.\")\n    return element.decode_contents()\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion.extract_front_matter_bibliography","title":"extract_front_matter_bibliography","text":"<pre><code>extract_front_matter_bibliography(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; dict[str, InlineBibliographyEntry]\n</code></pre> <p>Return inline bibliography entries declared in the document front matter.</p> Source code in <code>src/texsmith/core/conversion/inputs.py</code> <pre><code>def extract_front_matter_bibliography(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; dict[str, InlineBibliographyEntry]:\n    \"\"\"Return inline bibliography entries declared in the document front matter.\"\"\"\n    if not isinstance(front_matter, Mapping):\n        return {}\n\n    bibliography: dict[str, InlineBibliographyEntry] = {}\n    container = front_matter.get(\"bibliography\")\n    if isinstance(container, Mapping):\n        for key, value in container.items():\n            if not isinstance(key, str):\n                continue\n            entry = _parse_inline_bibliography_entry(key, value)\n            bibliography[key] = entry\n\n    return bibliography\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion.extract_front_matter_slots","title":"extract_front_matter_slots","text":"<pre><code>extract_front_matter_slots(\n    front_matter: Mapping[str, Any],\n) -&gt; dict[str, str]\n</code></pre> <p>Collect slot overrides defined in document front matter.</p> Source code in <code>src/texsmith/core/conversion/inputs.py</code> <pre><code>def extract_front_matter_slots(front_matter: Mapping[str, Any]) -&gt; dict[str, str]:\n    \"\"\"Collect slot overrides defined in document front matter.\"\"\"\n    overrides: dict[str, str] = {}\n\n    root_slots = front_matter.get(\"slots\") or front_matter.get(\"entrypoints\")\n    overrides.update(parse_slot_mapping(root_slots))\n\n    return overrides\n</code></pre>"},{"location":"api/core/#texsmith.core.conversion.parse_slot_mapping","title":"parse_slot_mapping","text":"<pre><code>parse_slot_mapping(raw: Any) -&gt; dict[str, str]\n</code></pre> <p>Parse slot mappings declared in front matter structures.</p> Source code in <code>src/texsmith/core/conversion/inputs.py</code> <pre><code>def parse_slot_mapping(raw: Any) -&gt; dict[str, str]:\n    \"\"\"Parse slot mappings declared in front matter structures.\"\"\"\n    overrides: dict[str, str] = {}\n    if not raw:\n        return overrides\n\n    if isinstance(raw, Mapping):\n        for slot_name, payload in raw.items():\n            if not isinstance(slot_name, str):\n                continue\n            selector = coerce_slot_selector(payload)\n            if selector:\n                key = slot_name.strip()\n                if key:\n                    overrides[key] = selector\n        return overrides\n\n    if isinstance(raw, Iterable) and not isinstance(raw, str | bytes):\n        for entry in raw:\n            if not isinstance(entry, Mapping):\n                continue\n            slot_name = entry.get(\"target\") or entry.get(\"slot\")\n            if not isinstance(slot_name, str):\n                continue\n            selector = entry.get(\"label\") or entry.get(\"title\") or entry.get(\"section\")\n            selector_value = coerce_slot_selector(selector)\n            if not selector_value:\n                selector_value = coerce_slot_selector(entry)\n            slot_key = slot_name.strip()\n            if slot_key and selector_value:\n                overrides[slot_key] = selector_value\n        return overrides\n\n    if isinstance(raw, str):\n        entry = raw.strip()\n        if entry and \":\" in entry:\n            name, selector = entry.split(\":\", 1)\n            name = name.strip()\n            selector = selector.strip()\n            if name and selector:\n                overrides[name] = selector\n        return overrides\n\n    return overrides\n</code></pre>"},{"location":"api/core/#diagnostics-emitters","title":"Diagnostics emitters","text":"<p><code>texsmith.core.diagnostics</code> defines the <code>DiagnosticEmitter</code> protocol plus a few stock implementations. Pass any emitter into <code>ConversionService</code>, <code>convert_documents</code>, or <code>TemplateSession</code> to intercept warnings, errors, and structured events.</p> Emitter Description Typical usage <code>CliEmitter</code> (<code>texsmith.ui.cli.diagnostics</code>) Rich-powered emitter used by the Typer CLI. Respects <code>-v</code> and <code>--debug</code>, paints warnings as panels, and streams structured events to the diagnostics sidebar. Default when running <code>texsmith</code>. Import it in automation scripts when you want human-friendly output. <code>LoggingEmitter</code> Forwards <code>warning</code>, <code>error</code>, and <code>event</code> calls to the standard <code>logging</code> module. Daemons, notebooks, or services that rely on existing logging policy. <code>NullEmitter</code> No-op implementation. Useful when you want silent conversions or plan to capture diagnostics out-of-band. Unit tests and benchmarking. <p>Emitters expose a <code>debug_enabled</code> flag so downstream handlers can decide whether to include stack traces or expensive state dumps. Implement your own to route diagnostics to metrics systems or structured loggers.</p> <p>Diagnostic abstractions shared across the conversion pipeline.</p> <p>Custom exception hierarchy for the LATEX rendering pipeline.</p> <p>Rule declaration and execution engine for the LATEX renderer.</p> <p>This module implements the rule-based architecture that powers Texsmith's HTML-to-LATEX pipeline. Handlers declare their intent via the <code>@renders</code> decorator, which records structural metadata (phase, priority, targeted tags). At runtime the :class:<code>RenderEngine</code> collects those declarations, organises them per :class:<code>RenderPhase</code>, and walks the BeautifulSoup DOM ensuring that each pass is executed in a predictable, stable order.</p> <p>Architecture</p> <code>Declaration layer</code> <code>@renders</code> stores a lightweight :class:<code>RuleDefinition</code> on every handler. <code>Registry layer</code> :class:<code>RenderRegistry</code> collates definitions into sortable :class:<code>RenderRule</code>   instances grouped by phase/tag. <code>Execution layer</code> :class:<code>RenderEngine</code> coordinates multi-pass traversal using the private <p>:class:<code>_DOMVisitor</code> to apply handlers depth-first while respecting   auto-marking and child-suppression semantics.</p> <p>This separation keeps rule authors focused on transformations while the engine handles ordering, deduplication, and orchestration concerns.</p> <p>Utility helpers specific to LATEX rendering.</p> <p>Abstractions for invoking Docker containers safely.</p>"},{"location":"api/core/#texsmith.core.diagnostics.DiagnosticEmitter","title":"DiagnosticEmitter","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface used to surface warnings, errors, and structured events.</p>"},{"location":"api/core/#texsmith.core.diagnostics.LoggingEmitter","title":"LoggingEmitter","text":"<pre><code>LoggingEmitter(\n    *,\n    logger_obj: Logger | None = None,\n    debug_enabled: bool = False,\n)\n</code></pre> <p>Emitter that forwards diagnostics to the standard logging module.</p> Source code in <code>src/texsmith/core/diagnostics.py</code> <pre><code>def __init__(\n    self, *, logger_obj: logging.Logger | None = None, debug_enabled: bool = False\n) -&gt; None:\n    self._logger = logger_obj or logger\n    self.debug_enabled = debug_enabled\n</code></pre>"},{"location":"api/core/#texsmith.core.diagnostics.NullEmitter","title":"NullEmitter","text":"<p>Emitter that ignores every diagnostic.</p>"},{"location":"api/core/#texsmith.core.diagnostics.format_event_message","title":"format_event_message","text":"<pre><code>format_event_message(\n    name: str, payload: Mapping[str, Any]\n) -&gt; str | None\n</code></pre> <p>Return a human-friendly summary for selected diagnostic events.</p> Source code in <code>src/texsmith/core/diagnostics.py</code> <pre><code>def format_event_message(name: str, payload: Mapping[str, Any]) -&gt; str | None:\n    \"\"\"Return a human-friendly summary for selected diagnostic events.\"\"\"\n    try:\n        data = dict(payload)\n    except Exception:  # pragma: no cover - defensive\n        data = {}\n\n    if name == \"asset_fetch\":\n        url = data.get(\"url\") or \"&lt;unknown&gt;\"\n        convert = data.get(\"convert\")\n        suffix_hint = data.get(\"suffix_hint\")\n        details: list[str] = []\n        if convert:\n            details.append(\"convert\")\n        if suffix_hint:\n            details.append(f\"suffix={suffix_hint}\")\n        suffix = f\" ({', '.join(details)})\" if details else \"\"\n        return f\"Fetching: {url}{suffix}\"\n\n    if name == \"asset_fetch_cached\":\n        url = data.get(\"url\") or \"&lt;unknown&gt;\"\n        reason = data.get(\"reason\") or \"cache\"\n        return f\"Reusing cached remote image: {url} ({reason})\"\n\n    if name == \"doi_fetch\":\n        doi_value = data.get(\"value\") or data.get(\"doi\") or \"&lt;unknown&gt;\"\n        key = data.get(\"key\") or \"&lt;unknown&gt;\"\n        mode = data.get(\"mode\")\n        source = data.get(\"source\") or data.get(\"resolved_source\")\n        details: list[str] = []\n        if mode:\n            details.append(str(mode))\n        if source:\n            details.append(str(source))\n        suffix = f\" ({', '.join(details)})\" if details else \"\"\n        return f\"Resolved DOI {doi_value} for entry '{key}'{suffix}\"\n\n    return None\n</code></pre>"},{"location":"api/core/#texsmith.core.exceptions.AssetMissingError","title":"AssetMissingError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when an expected asset cannot be located or generated.</p>"},{"location":"api/core/#texsmith.core.exceptions.InvalidNodeError","title":"InvalidNodeError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when a handler receives an unexpected DOM node shape.</p>"},{"location":"api/core/#texsmith.core.exceptions.LatexRenderingError","title":"LatexRenderingError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Base exception for LATEX rendering failures.</p>"},{"location":"api/core/#texsmith.core.exceptions.TransformerExecutionError","title":"TransformerExecutionError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when an external converter fails to execute properly.</p>"},{"location":"api/core/#texsmith.core.exceptions.exception_hint","title":"exception_hint","text":"<pre><code>exception_hint(exc: BaseException) -&gt; str | None\n</code></pre> <p>Return the most specific message available for an exception chain.</p> Source code in <code>src/texsmith/core/exceptions.py</code> <pre><code>def exception_hint(exc: BaseException) -&gt; str | None:\n    \"\"\"Return the most specific message available for an exception chain.\"\"\"\n    messages = exception_messages(exc)\n    return messages[-1] if messages else None\n</code></pre>"},{"location":"api/core/#texsmith.core.exceptions.exception_messages","title":"exception_messages","text":"<pre><code>exception_messages(exc: BaseException) -&gt; list[str]\n</code></pre> <p>Return the collected message chain for an exception and its causes.</p> Source code in <code>src/texsmith/core/exceptions.py</code> <pre><code>def exception_messages(exc: BaseException) -&gt; list[str]:\n    \"\"\"Return the collected message chain for an exception and its causes.\"\"\"\n    messages: list[str] = []\n    visited: set[int] = set()\n    current: BaseException | None = exc\n    while current is not None and id(current) not in visited:\n        visited.add(id(current))\n        text = str(current).strip()\n        if text:\n            first_line = text.splitlines()[0].strip()\n            if first_line:\n                messages.append(first_line)\n        current = current.__cause__ or current.__context__\n    return messages\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderEngine","title":"RenderEngine","text":"<pre><code>RenderEngine(registry: RenderRegistry | None = None)\n</code></pre> <p>Execution engine that orchestrates the registered rules.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def __init__(self, registry: RenderRegistry | None = None) -&gt; None:\n    self.registry = registry or RenderRegistry()\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderEngine.collect_from","title":"collect_from","text":"<pre><code>collect_from(owner: Any) -&gt; None\n</code></pre> <p>Collect decorated callables from an object or module.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def collect_from(self, owner: Any) -&gt; None:\n    \"\"\"Collect decorated callables from an object or module.\"\"\"\n    for attribute in dir(owner):\n        handler = getattr(owner, attribute)\n        definition = getattr(handler, \"__render_rule__\", None)\n        if definition is None and hasattr(handler, \"__func__\"):\n            definition = getattr(handler.__func__, \"__render_rule__\", None)\n        if isinstance(definition, RuleDefinition):\n            self.registry.register(definition.bind(handler))\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderEngine.register","title":"register","text":"<pre><code>register(handler: RuleCallable) -&gt; None\n</code></pre> <p>Register a standalone callable decorated with <code>@renders</code>.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def register(self, handler: RuleCallable) -&gt; None:\n    \"\"\"Register a standalone callable decorated with ``@renders``.\"\"\"\n    definition = getattr(handler, \"__render_rule__\", None)\n    if not isinstance(definition, RuleDefinition):\n        msg = \"Handler must be decorated with @renders\"\n        raise TypeError(msg)\n    self.registry.register(definition.bind(handler))\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderEngine.run","title":"run","text":"<pre><code>run(root: Tag, context: RenderContext) -&gt; None\n</code></pre> <p>Execute all registered rules against the provided DOM root.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def run(self, root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Execute all registered rules against the provided DOM root.\"\"\"\n    for phase in RenderPhase:\n        context.enter_phase(phase)\n        phase_rules = self.registry.rules_for_phase(phase)\n        document_rules = phase_rules.get(DOCUMENT_NODE, ())\n\n        for rule in document_rules:\n            self._execute_rule(rule, root, context)\n\n        visitor = _DOMVisitor(phase, phase_rules, context)\n        visitor.walk(root)\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderPhase","title":"RenderPhase","text":"<p>               Bases: <code>Enum</code></p> <p>Ordered passes executed while mutating the parsed HTML tree.</p> <p>The renderer performs multiple sweeps over the DOM instead of a single monolithic traversal. Each phase isolates a category of mutations so that earlier transformations stabilise before later ones begin. This drastically reduces coupling between handlers and makes ordering guarantees explicit.</p> <p>Phases progress from coarse structural edits to fine-grained formatting:</p> <code>PRE</code> normalise the tree and discard unwanted nodes before any heavy lifting   occurs. <code>BLOCK</code> build block-level LATEX (paragraphs, lists, figures) once the structure is   stable. <code>INLINE</code> apply inline formatting after blocks have established their final shape. <code>POST</code> run cleanup or bookkeeping steps that depend on previous phases, such as   final numbering, synthetic nodes, or state aggregation."},{"location":"api/core/#texsmith.core.rules.RenderPhase.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = auto()\n</code></pre> <p>Block transformation pass: convert paragraphs, lists, figures, etc.</p>"},{"location":"api/core/#texsmith.core.rules.RenderPhase.INLINE","title":"INLINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INLINE = auto()\n</code></pre> <p>Inline formatting pass: apply emphasis, links, inline math once blocks exist.</p>"},{"location":"api/core/#texsmith.core.rules.RenderPhase.POST","title":"POST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POST = auto()\n</code></pre> <p>Finalisation pass: run cleanup that depends on earlier transformations.</p>"},{"location":"api/core/#texsmith.core.rules.RenderPhase.PRE","title":"PRE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRE = auto()\n</code></pre> <p>DOM normalisation pass: strip/reshape nodes before structural work begins.</p>"},{"location":"api/core/#texsmith.core.rules.RenderRegistry","title":"RenderRegistry","text":"<pre><code>RenderRegistry()\n</code></pre> <p>Container used to gather render rules before execution.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._rules: dict[RenderPhase, dict[str, list[RenderRule]]] = {}\n    self._rule_sources: dict[int, str] = {}\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderRegistry.describe","title":"describe","text":"<pre><code>describe() -&gt; list[dict[str, object]]\n</code></pre> <p>Return a serialisable snapshot of the registered rules.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def describe(self) -&gt; list[dict[str, object]]:\n    \"\"\"Return a serialisable snapshot of the registered rules.\"\"\"\n    entries: list[dict[str, object]] = []\n    for phase in RenderPhase:\n        for tag, rules in sorted(self.rules_for_phase(phase).items(), key=lambda item: item[0]):\n            for order, rule in enumerate(rules):\n                entries.append(\n                    {\n                        \"phase\": phase.name,\n                        \"tag\": tag,\n                        \"name\": rule.name,\n                        \"priority\": rule.priority,\n                        \"before\": list(rule.before),\n                        \"after\": list(rule.after),\n                        \"order\": order,\n                    }\n                )\n    return entries\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderRegistry.iter_phase","title":"iter_phase","text":"<pre><code>iter_phase(phase: RenderPhase) -&gt; Iterable[RenderRule]\n</code></pre> <p>Iterate over rules for the provided phase.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def iter_phase(self, phase: RenderPhase) -&gt; Iterable[RenderRule]:\n    \"\"\"Iterate over rules for the provided phase.\"\"\"\n    buckets = self._rules.get(phase, {})\n    for tag_rules in buckets.values():\n        yield from tag_rules\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderRegistry.register","title":"register","text":"<pre><code>register(rule: RenderRule) -&gt; None\n</code></pre> <p>Register a rule for later execution.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def register(self, rule: RenderRule) -&gt; None:\n    \"\"\"Register a rule for later execution.\"\"\"\n    phase_bucket = self._rules.setdefault(rule.phase, {})\n    self._rule_sources.setdefault(id(rule), rule.name)\n    if rule.applies_to_document():\n        tag_bucket = phase_bucket.setdefault(DOCUMENT_NODE, [])\n        tag_bucket.append(rule)\n        tag_bucket[:] = self._sort_rules(tag_bucket)\n        return\n\n    for tag in rule.tags:\n        tag_bucket = phase_bucket.setdefault(tag, [])\n        tag_bucket.append(rule)\n        tag_bucket[:] = self._sort_rules(tag_bucket)\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderRegistry.rules_for_phase","title":"rules_for_phase","text":"<pre><code>rules_for_phase(\n    phase: RenderPhase,\n) -&gt; dict[str, tuple[RenderRule, ...]]\n</code></pre> <p>Return the rule mapping for the requested phase.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def rules_for_phase(self, phase: RenderPhase) -&gt; dict[str, tuple[RenderRule, ...]]:\n    \"\"\"Return the rule mapping for the requested phase.\"\"\"\n    phase_bucket = self._rules.get(phase, {})\n    return {tag: tuple(rules) for tag, rules in phase_bucket.items()}\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RenderRule","title":"RenderRule  <code>dataclass</code>","text":"<pre><code>RenderRule(\n    priority: int,\n    phase: RenderPhase,\n    tags: tuple[str, ...],\n    name: str,\n    handler: RuleCallable,\n    auto_mark: bool = True,\n    nestable: bool = True,\n    after_children: bool = False,\n    before: tuple[str, ...] = (),\n    after: tuple[str, ...] = (),\n)\n</code></pre> <p>Concrete rendering rule registered in the engine.</p>"},{"location":"api/core/#texsmith.core.rules.RenderRule.applies_to_document","title":"applies_to_document","text":"<pre><code>applies_to_document() -&gt; bool\n</code></pre> <p>Return True when the rule targets the synthetic document node.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def applies_to_document(self) -&gt; bool:\n    \"\"\"Return True when the rule targets the synthetic document node.\"\"\"\n    return self.tags == (DOCUMENT_NODE,)\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RuleDefinition","title":"RuleDefinition  <code>dataclass</code>","text":"<pre><code>RuleDefinition(\n    phase: RenderPhase,\n    tags: tuple[str, ...],\n    priority: int = 0,\n    name: str | None = None,\n    auto_mark: bool = True,\n    nestable: bool = True,\n    after_children: bool = False,\n    before: tuple[str, ...] = (),\n    after: tuple[str, ...] = (),\n)\n</code></pre> <p>Descriptor installed on handler callables by the decorator.</p>"},{"location":"api/core/#texsmith.core.rules.RuleDefinition.bind","title":"bind","text":"<pre><code>bind(handler: RuleCallable) -&gt; RenderRule\n</code></pre> <p>Create a concrete rule instance bound to the callable.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def bind(self, handler: RuleCallable) -&gt; RenderRule:\n    \"\"\"Create a concrete rule instance bound to the callable.\"\"\"\n    name = self.name or getattr(handler, \"__name__\", handler.__class__.__name__)\n    return RenderRule(\n        phase=self.phase,\n        tags=self.tags,\n        priority=self.priority,\n        name=name,\n        handler=handler,\n        auto_mark=self.auto_mark,\n        nestable=self.nestable,\n        after_children=self.after_children,\n        before=self.before,\n        after=self.after,\n    )\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.RuleFactory","title":"RuleFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by rule decorators.</p> <p>Decorators return lightweight factory objects instead of immediately constructing :class:<code>RenderRule</code> instances. This indirection lets us bind metadata once (at decoration time) while deferring handler resolution until the registry collects rules. The factory pattern keeps the decorator API ergonomic, avoids premature instantiation, and allows the same definition to be rebound for different callables (e.g. class/static methods) without duplicating registration logic.</p>"},{"location":"api/core/#texsmith.core.rules.RuleFactory.bind","title":"bind","text":"<pre><code>bind(handler: RuleCallable) -&gt; RenderRule\n</code></pre> <p>Create a concrete render rule for the decorated handler.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def bind(self, handler: RuleCallable) -&gt; RenderRule:\n    \"\"\"Create a concrete render rule for the decorated handler.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#texsmith.core.rules.renders","title":"renders","text":"<pre><code>renders(\n    *tags: str,\n    phase: RenderPhase = RenderPhase.BLOCK,\n    priority: int = 0,\n    name: str | None = None,\n    auto_mark: bool = True,\n    nestable: bool = True,\n    after_children: bool = False,\n    before: Iterable[str] = (),\n    after: Iterable[str] = (),\n) -&gt; Callable[[RuleCallable], RuleCallable]\n</code></pre> <p>Decorator used to register element handlers.</p> Source code in <code>src/texsmith/core/rules.py</code> <pre><code>def renders(\n    *tags: str,\n    phase: RenderPhase = RenderPhase.BLOCK,\n    priority: int = 0,\n    name: str | None = None,\n    auto_mark: bool = True,\n    nestable: bool = True,\n    after_children: bool = False,\n    before: Iterable[str] = (),\n    after: Iterable[str] = (),\n) -&gt; Callable[[RuleCallable], RuleCallable]:\n    \"\"\"Decorator used to register element handlers.\"\"\"\n    selected_tags = tags or (DOCUMENT_NODE,)\n    definition = RuleDefinition(\n        phase=phase,\n        tags=tuple(selected_tags),\n        priority=priority,\n        name=name,\n        auto_mark=auto_mark,\n        nestable=nestable,\n        after_children=after_children,\n        before=tuple(before),\n        after=tuple(after),\n    )\n\n    def decorator(handler: RuleCallable) -&gt; RuleCallable:\n        cast(Any, handler).__render_rule__ = definition\n        return handler\n\n    return decorator\n</code></pre>"},{"location":"api/core/#texsmith.adapters.latex.utils.escape_latex_chars","title":"escape_latex_chars","text":"<pre><code>escape_latex_chars(\n    text: str, *, legacy_accents: bool = False\n) -&gt; str\n</code></pre> <p>Escape LATEX special characters leveraging pylatexenc.</p> Source code in <code>src/texsmith/adapters/latex/utils.py</code> <pre><code>def escape_latex_chars(text: str, *, legacy_accents: bool = False) -&gt; str:\n    \"\"\"Escape LaTeX special characters leveraging pylatexenc.\"\"\"\n    if not text:\n        return text\n    parts: list[str] = []\n    buffer: list[str] = []\n\n    def _encode_chunk(chunk: str) -&gt; str:\n        escaped = \"\".join(_BASIC_LATEX_ESCAPE_MAP.get(char, char) for char in chunk)\n        if legacy_accents:\n            encoded = unicode_to_latex(escaped, non_ascii_only=True, unknown_char_warning=False)\n            return _wrap_latex_output(encoded)\n        return escaped\n\n    def _should_skip_encoding(char: str) -&gt; bool:\n        try:\n            name = unicodedata.name(char)\n        except ValueError:\n            return False\n        if \"SUPERSCRIPT\" in name or \"SUBSCRIPT\" in name:\n            return True\n        return \"MODIFIER LETTER\" in name and (\"SMALL\" in name or \"CAPITAL\" in name)\n\n    for char in text:\n        replacement = _COMMON_SYMBOL_MAP.get(char)\n        if replacement is not None:\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(replacement)\n            continue\n        if _should_skip_encoding(char):\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(char)\n        else:\n            buffer.append(char)\n\n    if buffer:\n        parts.append(_encode_chunk(\"\".join(buffer)))\n\n    return \"\".join(parts)\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.DockerLimits","title":"DockerLimits  <code>dataclass</code>","text":"<pre><code>DockerLimits(\n    cpus: float | int | None = None,\n    memory: str | None = None,\n    pids_limit: int | None = None,\n)\n</code></pre> <p>Runtime constraints for Docker containers.</p>"},{"location":"api/core/#texsmith.adapters.docker.DockerRunRequest","title":"DockerRunRequest  <code>dataclass</code>","text":"<pre><code>DockerRunRequest(\n    image: str,\n    args: Sequence[str] = tuple(),\n    mounts: Sequence[VolumeMount] = tuple(),\n    environment: Mapping[str, str] = dict(),\n    workdir: str | None = None,\n    user: str | None = None,\n    use_host_user: bool = True,\n    remove: bool = True,\n    limits: DockerLimits | None = None,\n    network: str | None = None,\n    extra_args: Sequence[str] = tuple(),\n)\n</code></pre> <p>Full request payload for a Docker execution.</p>"},{"location":"api/core/#texsmith.adapters.docker.DockerRunner","title":"DockerRunner","text":"<pre><code>DockerRunner(executable: str | None = None)\n</code></pre> <p>Utility class encapsulating Docker invocations.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def __init__(self, executable: str | None = None) -&gt; None:\n    self._explicit_executable = executable\n    self._cached_executable: str | None = None\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.DockerRunner.is_available","title":"is_available","text":"<pre><code>is_available() -&gt; bool\n</code></pre> <p>Return True when Docker can be located.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def is_available(self) -&gt; bool:\n    \"\"\"Return True when Docker can be located.\"\"\"\n    try:\n        return self._resolve_executable(optional=True) is not None\n    except TransformerExecutionError:\n        return False\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.DockerRunner.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Clear cached executable lookup results.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Clear cached executable lookup results.\"\"\"\n    self._cached_executable = None\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.DockerRunner.run","title":"run","text":"<pre><code>run(\n    request: DockerRunRequest,\n    *,\n    capture_output: bool = True,\n    text: bool = True,\n) -&gt; subprocess.CompletedProcess[str]\n</code></pre> <p>Execute Docker with the supplied request.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def run(\n    self,\n    request: DockerRunRequest,\n    *,\n    capture_output: bool = True,\n    text: bool = True,\n) -&gt; subprocess.CompletedProcess[str]:\n    \"\"\"Execute Docker with the supplied request.\"\"\"\n    command = self._build_run_command(request)\n    try:\n        result = subprocess.run(\n            command,\n            check=False,\n            capture_output=capture_output,\n            text=text,\n        )\n    except FileNotFoundError as exc:\n        self._cached_executable = None\n        raise TransformerExecutionError(\"Docker executable could not be located.\") from exc\n    except OSError as exc:\n        raise TransformerExecutionError(f\"Failed to invoke Docker: {exc}\") from exc\n\n    if result.returncode != 0:\n        stderr = (result.stderr or \"\").strip()\n        stdout = (result.stdout or \"\").strip()\n        detail = stderr or stdout\n        message = f\"Docker image '{request.image}' failed with exit code {result.returncode}\"\n        if detail:\n            message = f\"{message}: {detail}\"\n        raise TransformerExecutionError(message)\n\n    return result\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.VolumeMount","title":"VolumeMount  <code>dataclass</code>","text":"<pre><code>VolumeMount(\n    source: Path | str, target: str, read_only: bool = False\n)\n</code></pre> <p>Bind mount configuration.</p>"},{"location":"api/core/#texsmith.adapters.docker.is_docker_available","title":"is_docker_available","text":"<pre><code>is_docker_available() -&gt; bool\n</code></pre> <p>Check if Docker can be executed.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def is_docker_available() -&gt; bool:\n    \"\"\"Check if Docker can be executed.\"\"\"\n    return _default_runner.is_available()\n</code></pre>"},{"location":"api/core/#texsmith.adapters.docker.run_container","title":"run_container","text":"<pre><code>run_container(\n    image: str,\n    args: Sequence[str] = (),\n    *,\n    mounts: Sequence[VolumeMount] = (),\n    environment: Mapping[str, str] | None = None,\n    workdir: str | None = None,\n    user: str | None = None,\n    use_host_user: bool = True,\n    limits: DockerLimits | None = None,\n    network: str | None = None,\n    remove: bool = True,\n    extra_args: Sequence[str] = (),\n    capture_output: bool = True,\n    text: bool = True,\n) -&gt; subprocess.CompletedProcess[str]\n</code></pre> <p>Execute Docker using the shared runner.</p> Source code in <code>src/texsmith/adapters/docker.py</code> <pre><code>def run_container(\n    image: str,\n    args: Sequence[str] = (),\n    *,\n    mounts: Sequence[VolumeMount] = (),\n    environment: Mapping[str, str] | None = None,\n    workdir: str | None = None,\n    user: str | None = None,\n    use_host_user: bool = True,\n    limits: DockerLimits | None = None,\n    network: str | None = None,\n    remove: bool = True,\n    extra_args: Sequence[str] = (),\n    capture_output: bool = True,\n    text: bool = True,\n) -&gt; subprocess.CompletedProcess[str]:\n    \"\"\"Execute Docker using the shared runner.\"\"\"\n    request = DockerRunRequest(\n        image=image,\n        args=tuple(args),\n        mounts=tuple(mounts),\n        environment=environment or {},\n        workdir=workdir,\n        user=user,\n        use_host_user=use_host_user,\n        remove=remove,\n        limits=limits,\n        network=network,\n        extra_args=tuple(extra_args),\n    )\n    return _default_runner.run(\n        request,\n        capture_output=capture_output,\n        text=text,\n    )\n</code></pre>"},{"location":"api/custom-transformers/","title":"Custom Transformers","text":"<p>Transformers convert non-PDF assets (Mermaid, Draw.io, bitmap images) into PDF fragments before the LATEX renderer emits <code>\\includegraphics</code>. When the built-in strategies do not cover your workflow, register custom converters via <code>texsmith.adapters.transformers.register_converter</code>.</p>"},{"location":"api/custom-transformers/#building-a-converter","title":"Building a converter","text":"<pre><code>from pathlib import Path\n\nfrom texsmith.adapters.transformers import register_converter\nfrom texsmith.adapters.transformers.base import CachedConversionStrategy\nfrom texsmith.core.exceptions import TransformerExecutionError\n\n\nclass PlantumlToPdf(CachedConversionStrategy):\n    suffix = \".pdf\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"plantuml\")\n\n    def _perform_conversion(self, source: Path | str, *, target: Path, cache_dir: Path, **options):\n        jar = Path(options.get(\"jar\", \"plantuml.jar\"))\n        if not jar.exists():\n            raise TransformerExecutionError(f\"PlantUML jar not found at {jar}\")\n\n        command = [\n            \"java\",\n            \"-jar\",\n            str(jar),\n            \"-tpdf\",\n            \"-pipe\",\n        ]\n        # write the PlantUML source to stdin\n        import subprocess\n\n        result = subprocess.run(\n            command,\n            input=Path(source).read_text(encoding=\"utf-8\"),\n            text=True,\n            capture_output=True,\n            check=False,\n        )\n        if result.returncode != 0:\n            raise TransformerExecutionError(result.stderr.strip() or \"plantuml failed\")\n\n        target.write_bytes(result.stdout.encode(\"utf-8\"))\n        return target\n\n\nregister_converter(\"plantuml\", PlantumlToPdf())\n</code></pre> <p>The base class adds caching, stable file naming, and retry/backoff hooks. Supply your own <code>suffix</code> when the converter emits something other than <code>.pdf</code>.</p>"},{"location":"api/custom-transformers/#wiring-the-converter","title":"Wiring the converter","text":"<ol> <li>Import the module before converting documents (e.g., in <code>docs/hooks/mkdocs_hooks.py</code>    or a standalone script).</li> <li>Reference the converter name inside handlers or templates. For example, add a    handler that detects <code>&lt;pre class=\"language-plantuml\"&gt;</code> blocks and calls    <code>registry.convert(\"plantuml\", ...)</code>.</li> <li>Ship optional dependencies (CLI tools, Docker images) alongside the template    README so users know how to enable the converter.</li> </ol>"},{"location":"api/custom-transformers/#handling-fallbacks","title":"Handling fallbacks","text":"<p>When TeXSmith cannot find a converter, it installs placeholder strategies that emit visible warnings and <code>TODO</code> boxes in the LATEX output. Use these helpers to control that behavior:</p> <ul> <li><code>texsmith.adapters.transformers.has_converter(\"mermaid\")</code> \u2013 check whether a   converter is registered before assuming the dependency exists.</li> <li><code>texsmith.core.conversion.attempt_transformer_fallback</code> \u2013 internal helper   the CLI uses to install placeholder converters when optional dependencies are   missing. Call this only if you need to mimic the CLI\u2019s resilience.</li> </ul>"},{"location":"api/custom-transformers/#further-reading","title":"Further reading","text":"<ul> <li><code>texsmith.adapters.transformers.base</code> \u2013 reference for   <code>CachedConversionStrategy</code>.</li> <li><code>texsmith.adapters.handlers.media</code> \u2013 real-world examples   of how converters integrate with handlers.</li> <li>Template Cookbook \u2013 packaging   recommendations so your templates document converter prerequisites.</li> </ul>"},{"location":"api/handlers/","title":"Handlers","text":"<p>Handlers convert BeautifulSoup nodes into LATEX fragments. They run inside the core renderer and are grouped by <code>RenderPhase</code> so transformations can hook into the DOM at the right point.</p>"},{"location":"api/handlers/#render-phases-at-a-glance","title":"Render phases at a glance","text":"Phase Purpose Typical consumers <code>RenderPhase.PRE</code> Normalise HTML before layout-sensitive transforms (unwrap unwanted tags, capture math spans, detect inline code). <code>basic.discard_unwanted</code>, <code>inline.inline_code</code>, diagram preprocessors. <code>RenderPhase.BLOCK</code> Manipulate block-level nodes when structure is stable (convert <code>&lt;figure&gt;</code>, extract tabbed content, manage slot boundaries). <code>blocks.tabbed_content</code>, <code>media.render_mermaid</code>. <code>RenderPhase.INLINE</code> Render inline formatting once blocks are resolved. <code>inline.inline_emphasis</code>, <code>links.links</code>, <code>inline.abbreviation</code>. <code>RenderPhase.POST</code> Finalisation pass after children are converted; ideal for numbering, bibliography hooks, or asset emission. <code>blocks.tables</code>, <code>admonitions.render_admonition</code>, <code>media.render_images</code>. <p>Handlers are regular Python callables decorated with <code>@renders(...)</code>. The decorator declares the HTML selectors, phase, and metadata such as priority, <code>nestable</code>, and whether TeXSmith should auto-mark the node as processed.</p>"},{"location":"api/handlers/#example-add-a-custom-inline-macro","title":"Example: add a custom inline macro","text":"<pre><code>from bs4 import Tag\n\nfrom texsmith.core.context import RenderContext\nfrom texsmith.core.rules import RenderPhase, renders\n\n\n@renders(\"span\", phase=RenderPhase.INLINE, priority=10, name=\"callout_chips\")\ndef render_callout_chips(element: Tag, context: RenderContext) -&gt; None:\n    if \"data-callout\" not in element.attrs:\n        return\n    label = element.get_text(strip=True)\n    latex = r\"\\CalloutChip{%s}\" % context.escape(label)\n    context.write(latex)\n    context.mark_processed(element)\n</code></pre> <p>Drop the module anywhere on <code>PYTHONPATH</code> and import it before calling <code>texsmith.render</code>. For MkDocs sites, add the import inside a <code>mkdocs</code> plugin or <code>docs/hooks/mkdocs_hooks.py</code>. For programmatic runs, import the module ahead of <code>convert_documents</code> so the decorator executes at import time.</p> <p>Tip</p> <p>Handlers should call <code>context.mark_processed(element)</code> when they fully consume a node. Leave the node untouched to let lower-priority handlers run.</p>"},{"location":"api/handlers/#reference","title":"Reference","text":"<p>Built-in handler collections.</p> <p>Internal helpers shared across handler modules.</p> <p>Handlers for generic admonition and callout markup.</p> <p>Built-in baseline handlers used by the renderer.</p> <p>Block-level handlers for structural HTML elements.</p>"},{"location":"api/handlers/#texsmith.adapters.handlers._helpers.coerce_attribute","title":"coerce_attribute","text":"<pre><code>coerce_attribute(value: Any) -&gt; str | None\n</code></pre> <p>Normalise a BeautifulSoup attribute value to a string when possible.</p> Source code in <code>src/texsmith/adapters/handlers/_helpers.py</code> <pre><code>def coerce_attribute(value: Any) -&gt; str | None:\n    \"\"\"Normalise a BeautifulSoup attribute value to a string when possible.\"\"\"\n    if isinstance(value, str):\n        return value\n    if isinstance(value, bytes):\n        try:\n            return value.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            return None\n    if isinstance(value, Iterable):\n        for item in value:\n            if isinstance(item, str):\n                return item\n    return None\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers._helpers.gather_classes","title":"gather_classes","text":"<pre><code>gather_classes(value: Any) -&gt; list[str]\n</code></pre> <p>Return a list of classes extracted from a BeautifulSoup attribute.</p> Source code in <code>src/texsmith/adapters/handlers/_helpers.py</code> <pre><code>def gather_classes(value: Any) -&gt; list[str]:\n    \"\"\"Return a list of classes extracted from a BeautifulSoup attribute.\"\"\"\n    if isinstance(value, str):\n        return [value]\n    if isinstance(value, Iterable) and not isinstance(value, (bytes, bytearray)):\n        return [cast(str, item) for item in value if isinstance(item, str)]\n    return []\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers._helpers.is_valid_url","title":"is_valid_url","text":"<pre><code>is_valid_url(url: str) -&gt; bool\n</code></pre> <p>Check whether a URL string has a valid scheme/netloc combination.</p> Source code in <code>src/texsmith/adapters/handlers/_helpers.py</code> <pre><code>def is_valid_url(url: str) -&gt; bool:\n    \"\"\"Check whether a URL string has a valid scheme/netloc combination.\"\"\"\n    try:\n        result = urlparse(url)\n    except ValueError:\n        return False\n    return bool(result.scheme and result.netloc)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers._helpers.mark_processed","title":"mark_processed","text":"<pre><code>mark_processed(node: NodeT) -&gt; NodeT\n</code></pre> <p>Mark a BeautifulSoup node as processed and return it for chaining.</p> Source code in <code>src/texsmith/adapters/handlers/_helpers.py</code> <pre><code>def mark_processed(node: NodeT) -&gt; NodeT:\n    \"\"\"Mark a BeautifulSoup node as processed and return it for chaining.\"\"\"\n    cast(Any, node).processed = True  # type: ignore[attr-defined]\n    return node\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers._helpers.resolve_asset_path","title":"resolve_asset_path","text":"<pre><code>resolve_asset_path(\n    file_path: Path, path: str | Path\n) -&gt; Path | None\n</code></pre> <p>Resolve an asset path relative to a Markdown source file.</p> Source code in <code>src/texsmith/adapters/handlers/_helpers.py</code> <pre><code>def resolve_asset_path(file_path: Path, path: str | Path) -&gt; Path | None:\n    \"\"\"Resolve an asset path relative to a Markdown source file.\"\"\"\n    origin = Path(file_path)\n    if origin.name == \"index.md\":\n        origin = origin.parent\n    target = (origin / path).resolve()\n    return target if target.exists() else None\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.admonitions.render_blockquote_callouts","title":"render_blockquote_callouts","text":"<pre><code>render_blockquote_callouts(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Handle Obsidian/Docusaurus style blockquote callouts.</p> Source code in <code>src/texsmith/adapters/handlers/admonitions.py</code> <pre><code>@renders(\n    \"blockquote\",\n    phase=RenderPhase.POST,\n    priority=15,\n    name=\"blockquote_callouts\",\n    nestable=True,\n    auto_mark=False,\n)\ndef render_blockquote_callouts(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Handle Obsidian/Docusaurus style blockquote callouts.\"\"\"\n    first_paragraph = element.find(\"p\")\n    if first_paragraph is None:\n        return\n\n    first_text_node = next(\n        (child for child in first_paragraph.contents if isinstance(child, NavigableString)),\n        None,\n    )\n    if first_text_node is None:\n        return\n\n    raw_text = str(first_text_node)\n    stripped = raw_text.lstrip()\n    offset = len(raw_text) - len(stripped)\n    match = CALLOUT_PATTERN.match(stripped)\n    if not match:\n        return\n\n    callout_type = match.group(\"kind\").lower()\n    remainder = match.group(\"content\") or \"\"\n    remainder = remainder.lstrip()\n\n    first_text_node.replace_with(NavigableString(raw_text[:offset] + remainder))\n\n    lines_with_endings = remainder.splitlines(keepends=True)\n    lines = [line.strip() for line in remainder.splitlines() if line.strip()]\n    title = lines[0] if lines else callout_type.capitalize()\n\n    if len(lines_with_endings) &gt; 1:\n        prefix_length = len(raw_text[:offset]) + len(lines_with_endings[0])\n        _trim_paragraph_prefix(first_paragraph, prefix_length)\n        first_text = next(\n            (child for child in first_paragraph.contents if isinstance(child, NavigableString)),\n            None,\n        )\n        if first_text is not None:\n            first_text.replace_with(NavigableString(str(first_text).lstrip()))\n    else:\n        first_paragraph.decompose()\n\n    classes = gather_classes(element.get(\"class\"))\n    preserved = [cls for cls in classes if cls != \"admonition\"]\n    new_classes = [\"admonition\", callout_type]\n    for cls in preserved:\n        if cls not in new_classes:\n            new_classes.append(cls)\n    element[\"class\"] = new_classes\n    _promote_callout(element, context, classes=new_classes, title=title)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.admonitions.render_details_admonitions","title":"render_details_admonitions","text":"<pre><code>render_details_admonitions(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Handle collapsible callouts converted from MkDocs Material's details blocks.</p> Source code in <code>src/texsmith/adapters/handlers/admonitions.py</code> <pre><code>@renders(\n    \"details\",\n    phase=RenderPhase.POST,\n    priority=55,\n    name=\"details_admonitions\",\n    nestable=True,\n    auto_mark=False,\n)\ndef render_details_admonitions(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Handle collapsible callouts converted from MkDocs Material's details blocks.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"exercise\" in classes:\n        return\n\n    title = \"\"\n    if summary := element.find(\"summary\"):\n        title = summary.get_text(strip=True)\n        summary.decompose()\n\n    _promote_callout(element, context, classes=classes, title=title or \"\")\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.admonitions.render_div_admonitions","title":"render_div_admonitions","text":"<pre><code>render_div_admonitions(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Handle MkDocs Material admonition blocks.</p> Source code in <code>src/texsmith/adapters/handlers/admonitions.py</code> <pre><code>@renders(\n    \"div\",\n    phase=RenderPhase.POST,\n    priority=50,\n    name=\"admonitions\",\n    nestable=True,\n    auto_mark=False,\n)\ndef render_div_admonitions(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Handle MkDocs Material admonition blocks.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"admonition\" not in classes:\n        return\n    if \"exercise\" in classes:\n        return\n\n    title = _extract_title(element.find(\"p\", class_=\"admonition-title\"))\n    _promote_callout(element, context, classes=classes, title=title)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.admonitions.render_texsmith_callouts","title":"render_texsmith_callouts","text":"<pre><code>render_texsmith_callouts(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Convert promoted callout nodes once their children have rendered.</p> Source code in <code>src/texsmith/adapters/handlers/admonitions.py</code> <pre><code>@renders(\n    \"texsmith-callout\",\n    phase=RenderPhase.POST,\n    priority=140,\n    name=\"finalize_callouts\",\n    nestable=False,\n    auto_mark=False,\n    after_children=True,\n)\ndef render_texsmith_callouts(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert promoted callout nodes once their children have rendered.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    title = element.attrs.pop(\"data-callout-title\", \"\")\n    _render_admonition(element, context, classes=classes, title=title)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.discard_unwanted","title":"discard_unwanted","text":"<pre><code>discard_unwanted(root: Tag, context: RenderContext) -&gt; None\n</code></pre> <p>Discard or unwrap nodes that must not reach later phases.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(phase=RenderPhase.PRE, auto_mark=False, name=\"discard_unwanted\")\ndef discard_unwanted(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Discard or unwrap nodes that must not reach later phases.\"\"\"\n    for tag_name, classes, mode in _merge_strip_rules(context):\n        class_filter = list(classes)\n        candidates = (\n            root.find_all(tag_name, class_=class_filter)\n            if class_filter\n            else root.find_all(tag_name)\n        )\n        for node in candidates:\n            if mode == \"unwrap\":\n                node.unwrap()\n            elif mode == \"extract\":\n                node.extract()\n            elif mode == \"decompose\":\n                node.decompose()\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_headings","title":"render_headings","text":"<pre><code>render_headings(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Convert HTML headings to LATEX sectioning commands.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    phase=RenderPhase.POST,\n    name=\"render_headings\",\n)\ndef render_headings(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert HTML headings to LaTeX sectioning commands.\"\"\"\n    # Drop anchor tags within headings\n    for anchor in element.find_all(\"a\"):\n        anchor.unwrap()\n\n    drop_title = context.runtime.get(\"drop_title\")\n    if drop_title:\n        context.runtime[\"drop_title\"] = False\n        latex = context.formatter.pagestyle(text=\"plain\")\n        element.replace_with(mark_processed(NavigableString(latex)))\n        return\n\n    raw_text = element.get_text(strip=False)\n    text = render_moving_text(\n        raw_text,\n        context,\n        legacy_accents=getattr(context.config, \"legacy_latex_accents\", False),\n        escape=\"\\\\\" not in raw_text,\n        wrap_scripts=True,\n    )\n    plain_text = element.get_text(strip=True)\n    level = int(element.name[1:])\n    base_level = context.runtime.get(\"base_level\", 0)\n    rendered_level = level + base_level - 1\n    ref = coerce_attribute(element.get(\"id\"))\n    if not ref:\n        slug = slugify(plain_text, separator=\"-\")\n        ref = slug or None\n    numbered = context.runtime.get(\"numbered\", True)\n\n    latex = context.formatter.heading(\n        text=text,\n        level=rendered_level,\n        ref=ref,\n        numbered=numbered,\n    )\n\n    element.replace_with(mark_processed(NavigableString(latex)))\n\n    context.state.add_heading(level=rendered_level, text=plain_text, ref=ref)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_horizontal_rule","title":"render_horizontal_rule","text":"<pre><code>render_horizontal_rule(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;hr&gt;</code> nodes as LATEX horizontal rules.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"hr\", phase=RenderPhase.BLOCK, name=\"render_horizontal_rule\")\ndef render_horizontal_rule(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;hr&gt;`` nodes as LaTeX horizontal rules.\"\"\"\n    latex = context.formatter.horizontal_rule()\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_deletion","title":"render_inline_deletion","text":"<pre><code>render_inline_deletion(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;del&gt;</code> tags using strikethrough template.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"del\", phase=RenderPhase.INLINE, name=\"inline_deletion\", after_children=True)\ndef render_inline_deletion(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;del&gt;`` tags using strikethrough template.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.strikethrough(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_emphasis","title":"render_inline_emphasis","text":"<pre><code>render_inline_emphasis(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;em&gt;</code> tags using emphasis template.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"em\", phase=RenderPhase.INLINE, name=\"inline_emphasis\", after_children=True)\ndef render_inline_emphasis(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;em&gt;`` tags using emphasis template.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.italic(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_mark","title":"render_inline_mark","text":"<pre><code>render_inline_mark(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;mark&gt;</code> tags using highlight template.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"mark\", phase=RenderPhase.INLINE, name=\"inline_mark\", after_children=True)\ndef render_inline_mark(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;mark&gt;`` tags using highlight template.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.highlight(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_quote","title":"render_inline_quote","text":"<pre><code>render_inline_quote(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render inline quotations using \\enquote{}.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"q\", phase=RenderPhase.INLINE, name=\"inline_quote\", after_children=True)\ndef render_inline_quote(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render inline quotations using \\\\enquote{}.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.enquote(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_smallcaps","title":"render_inline_smallcaps","text":"<pre><code>render_inline_smallcaps(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;span class=\"texsmith-smallcaps\"&gt;</code> nodes as small capitals.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"span\", phase=RenderPhase.INLINE, name=\"inline_smallcaps\", auto_mark=False)\ndef render_inline_smallcaps(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;span class=\\\"texsmith-smallcaps\\\"&gt;`` nodes as small capitals.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"texsmith-smallcaps\" not in classes:\n        return\n    text = element.get_text(strip=False)\n    latex = context.formatter.smallcaps(text=text)\n    element.replace_with(NavigableString(latex))\n    context.mark_processed(element)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_strong","title":"render_inline_strong","text":"<pre><code>render_inline_strong(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;strong&gt;</code> tags using bold template.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"strong\", phase=RenderPhase.INLINE, name=\"inline_strong\", after_children=True)\ndef render_inline_strong(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;strong&gt;`` tags using bold template.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.strong(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_subscript","title":"render_inline_subscript","text":"<pre><code>render_inline_subscript(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;sub&gt;</code> tags.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"sub\", phase=RenderPhase.INLINE, name=\"inline_subscript\", after_children=True)\ndef render_inline_subscript(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;sub&gt;`` tags.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.subscript(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_superscript","title":"render_inline_superscript","text":"<pre><code>render_inline_superscript(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;sup&gt;</code> tags, skipping footnote references.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"sup\", phase=RenderPhase.INLINE, name=\"inline_superscript\", after_children=True)\ndef render_inline_superscript(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;sup&gt;`` tags, skipping footnote references.\"\"\"\n    if element.get(\"id\"):\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.superscript(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.render_inline_underline","title":"render_inline_underline","text":"<pre><code>render_inline_underline(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <code>&lt;ins&gt;</code> tags using the formatter.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"ins\", phase=RenderPhase.INLINE, name=\"inline_underline\", after_children=True)\ndef render_inline_underline(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ``&lt;ins&gt;`` tags using the formatter.\"\"\"\n    text = element.get_text(strip=False)\n    latex = context.formatter.underline(text=text)\n    element.replace_with(NavigableString(latex))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.replace_line_breaks","title":"replace_line_breaks","text":"<pre><code>replace_line_breaks(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre> <p>Convert <code>&lt;br&gt;</code> tags into explicit LATEX line breaks.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"br\", phase=RenderPhase.INLINE, name=\"line_breaks\")\ndef replace_line_breaks(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Convert ``&lt;br&gt;`` tags into explicit LaTeX line breaks.\"\"\"\n    element.replace_with(mark_processed(NavigableString(\"\\\\\")))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.basic.unwrap_grid_cards","title":"unwrap_grid_cards","text":"<pre><code>unwrap_grid_cards(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre> <p>Unwrap <code>div.grid-cards</code> containers.</p> Source code in <code>src/texsmith/adapters/handlers/basic.py</code> <pre><code>@renders(\"div\", phase=RenderPhase.BLOCK, name=\"grid_cards\", auto_mark=False)\ndef unwrap_grid_cards(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Unwrap ``div.grid-cards`` containers.\"\"\"\n    classes = element.get(\"class\") or []\n    if \"grid-cards\" in classes:\n        element.unwrap()\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.cleanup_tabbed_content","title":"cleanup_tabbed_content","text":"<pre><code>cleanup_tabbed_content(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre> <p>Remove tabbed container wrappers after children are processed.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\n    \"div\",\n    phase=RenderPhase.PRE,\n    priority=130,\n    name=\"tabbed_cleanup\",\n    auto_mark=False,\n    after_children=True,\n)\ndef cleanup_tabbed_content(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Remove tabbed container wrappers after children are processed.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"tabbed-set\" not in classes:\n        return\n\n    containers = element.find_all(\"div\", class_=\"tabbed-content\", recursive=False)\n    if not containers:\n        containers = element.find_all(\"div\", class_=\"tabbed-content\")\n    if not containers:\n        element.unwrap()\n        return\n\n    for container in containers:\n        inner_blocks = container.find_all(\"div\", class_=\"tabbed-block\", recursive=False)\n        if inner_blocks:\n            for block in inner_blocks:\n                block.unwrap()\n        container.unwrap()\n    element.unwrap()\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_blockquotes","title":"render_blockquotes","text":"<pre><code>render_blockquotes(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Convert blockquote elements into LATEX blockquote environments.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\n    \"blockquote\",\n    phase=RenderPhase.POST,\n    priority=200,\n    name=\"blockquotes\",\n    nestable=False,\n    after_children=True,\n)\ndef render_blockquotes(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert blockquote elements into LaTeX blockquote environments.\"\"\"\n    classes = element.get(\"class\") or []\n    if \"epigraph\" in classes:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.blockquote(text)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_columns","title":"render_columns","text":"<pre><code>render_columns(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render lists specially marked as multi-column blocks.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\"div\", phase=RenderPhase.POST, priority=60, name=\"multicolumns\", nestable=False)\ndef render_columns(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render lists specially marked as multi-column blocks.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"two-column-list\" in classes:\n        columns = 2\n    elif \"three-column-list\" in classes:\n        columns = 3\n    else:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.multicolumn(text, columns=columns)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_description_lists","title":"render_description_lists","text":"<pre><code>render_description_lists(\n    root: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render  elements. Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(phase=RenderPhase.POST, priority=15, name=\"description_lists\", auto_mark=False)\ndef render_description_lists(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render &lt;dl&gt; elements.\"\"\"\n    for dl in _iter_reversed(root.find_all(\"dl\")):\n        _prepare_rich_text_content(dl, context)\n        items: list[tuple[str | None, str]] = []\n        current_term: str | None = None\n\n        for child in dl.find_all([\"dt\", \"dd\"], recursive=False):\n            if child.name == \"dt\":\n                term = child.get_text(strip=False).strip()\n                current_term = term or None\n            elif child.name == \"dd\":\n                content = child.get_text(strip=False).strip()\n                if not content and current_term is None:\n                    continue\n                items.append((current_term, content))\n\n        if not items:\n            warnings.warn(\"Discarding empty description list.\", stacklevel=2)\n            dl.decompose()\n            continue\n\n        latex = context.formatter.description_list(items=items)\n        dl.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_figures","title":"render_figures","text":"<pre><code>render_figures(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render  elements and manage associated assets. Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\"figure\", phase=RenderPhase.POST, priority=30, name=\"figures\", nestable=False)\ndef render_figures(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render &lt;figure&gt; elements and manage associated assets.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"mermaid-figure\" in classes:\n        return\n\n    image = element.find(\"img\")\n    if image is None:\n        table = element.find(\"table\")\n        if table is not None:\n            identifier = coerce_attribute(element.get(\"id\"))\n            if identifier and not table.get(\"id\"):\n                table[\"id\"] = identifier\n            figcaption = element.find(\"figcaption\")\n            if figcaption is not None and table.find(\"caption\") is None:\n                caption = context.document.new_tag(\"caption\")\n                _strip_caption_prefix(figcaption)\n                caption.string = figcaption.get_text(strip=False)\n                table.insert(0, caption)\n                figcaption.decompose()\n            render_tables(table, context)\n            element.unwrap()\n            return\n        raise InvalidNodeError(\"Figure missing &lt;img&gt; element\")\n\n    src = coerce_attribute(image.get(\"src\"))\n    if not src:\n        raise InvalidNodeError(\"Figure image missing 'src' attribute\")\n\n    width = coerce_attribute(image.get(\"width\")) or None\n    alt_text = coerce_attribute(image.get(\"alt\")) or None\n    if not context.runtime.get(\"copy_assets\", True):\n        caption_node = element.find(\"figcaption\")\n        caption_text = caption_node.get_text(strip=False).strip() if caption_node else None\n        placeholder = caption_text or alt_text or \"[figure]\"\n        element.replace_with(mark_processed(NavigableString(placeholder)))\n        return\n\n    if is_valid_url(src):\n        stored_path = store_remote_image_asset(context, src)\n    else:\n        resolved = _resolve_source_path(context, src)\n        if resolved is None:\n            raise AssetMissingError(f\"Unable to resolve figure asset '{src}'\")\n\n        stored_path = store_local_image_asset(context, resolved)\n\n    caption_text = None\n    short_caption = alt_text\n\n    if figcaption := element.find(\"figcaption\"):\n        _strip_caption_prefix(figcaption)\n        caption_text = figcaption.get_text(strip=False).strip()\n        figcaption.decompose()\n\n    if short_caption and caption_text and len(caption_text) &gt; len(short_caption):\n        short_caption = None\n\n    label = coerce_attribute(element.get(\"id\"))\n\n    template_name = _figure_template_for(element, context)\n    formatter = getattr(context.formatter, template_name)\n    asset_path = context.assets.latex_path(stored_path)\n    latex = formatter(\n        path=asset_path,\n        caption=caption_text or short_caption,\n        shortcaption=short_caption,\n        label=label,\n        width=width,\n    )\n\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre> <p>Code-related handlers for the LATEX renderer.</p>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_footnotes","title":"render_footnotes","text":"<pre><code>render_footnotes(root: Tag, context: RenderContext) -&gt; None\n</code></pre> <p>Extract and render footnote references.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(phase=RenderPhase.POST, priority=-10, name=\"footnotes\", auto_mark=False)\ndef render_footnotes(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Extract and render footnote references.\"\"\"\n    footnotes: dict[str, str] = {}\n    bibliography = context.state.bibliography\n\n    def _normalise_footnote_id(value: str | None) -&gt; str:\n        if not value:\n            return \"\"\n        text = str(value).strip()\n        if \":\" in text:\n            prefix, suffix = text.split(\":\", 1)\n            if prefix.startswith(\"fnref\") or prefix.startswith(\"fn\"):\n                return suffix\n        return text or \"\"\n\n    def _replace_with_latex(node: Tag, latex: str) -&gt; None:\n        replacement = mark_processed(NavigableString(latex))\n        node.replace_with(replacement)\n\n    _citation_payload_pattern = re.compile(\n        rf\"^\\s*({_CITATION_KEY_PATTERN}(?:\\s*,\\s*{_CITATION_KEY_PATTERN})*)\\s*$\"\n    )\n\n    def _citation_keys_from_payload(text: str | None) -&gt; list[str]:\n        if not text:\n            return []\n        match = _citation_payload_pattern.match(text)\n        if not match:\n            return []\n        keys = [part.strip() for part in match.group(1).split(\",\")]\n        return [key for key in keys if key]\n\n    def _render_citation(node: Tag, keys: list[str]) -&gt; bool:\n        if not keys:\n            return False\n        _ensure_doi_entries(keys, context)\n        missing = [key for key in keys if key not in bibliography]\n        if missing:\n            return False\n        for key in keys:\n            context.state.record_citation(key)\n        latex = context.formatter.citation(key=\",\".join(keys))\n        _replace_with_latex(node, latex)\n        return True\n\n    citation_footnotes: dict[str, list[str]] = {}\n    invalid_footnotes: set[str] = set()\n\n    for container in root.find_all(\"div\", class_=\"footnote\"):\n        for li in container.find_all(\"li\"):\n            footnote_id = _normalise_footnote_id(coerce_attribute(li.get(\"id\")))\n            if not footnote_id:\n                raise InvalidNodeError(\"Footnote item missing identifier\")\n            text = li.get_text(strip=False)\n            if _is_multiline_footnote(text):\n                warnings.warn(\n                    f\"Footnote '{footnote_id}' spans multiple lines and cannot be rendered; dropping it.\",\n                    stacklevel=2,\n                )\n                invalid_footnotes.add(footnote_id)\n                continue\n            text = text.strip()\n            footnotes[footnote_id] = text\n            recovered = _citation_keys_from_payload(text)\n            if recovered:\n                citation_footnotes[footnote_id] = recovered\n        container.decompose()\n\n    if footnotes:\n        context.state.footnotes.update(footnotes)\n\n    for sup in root.find_all(\"sup\", id=True):\n        footnote_id = _normalise_footnote_id(coerce_attribute(sup.get(\"id\")))\n        if footnote_id in invalid_footnotes:\n            sup.decompose()\n            continue\n        citation_keys = citation_footnotes.get(footnote_id)\n        if citation_keys and _render_citation(sup, citation_keys):\n            continue\n        payload = footnotes.get(footnote_id)\n        if payload is None:\n            payload = context.state.footnotes.get(footnote_id)\n        if payload is None:\n            citation_keys = _split_citation_keys(footnote_id)\n            if citation_keys and _render_citation(sup, citation_keys):\n                continue\n            # Fall back to default handling/warnings for unresolved citations.\n        if footnote_id and footnote_id in bibliography:\n            placeholder_note = bool(payload) and _is_bibliography_placeholder(payload)\n            if payload and not placeholder_note:\n                warnings.warn(\n                    f\"Conflicting bibliography definition for '{footnote_id}'.\",\n                    stacklevel=2,\n                )\n            context.state.record_citation(footnote_id)\n            latex = context.formatter.citation(key=footnote_id)\n            _replace_with_latex(sup, latex)\n            continue\n\n        if payload is None:\n            if footnote_id and footnote_id not in bibliography:\n                warnings.warn(\n                    f\"Reference to '{footnote_id}' is not in your bibliography...\",\n                    stacklevel=2,\n                )\n            continue\n\n        latex = context.formatter.footnote(payload)\n        _replace_with_latex(sup, latex)\n\n    for placeholder in root.find_all(\"texsmith-missing-footnote\"):\n        identifier_attr = coerce_attribute(placeholder.get(\"data-footnote-id\"))\n        identifier = identifier_attr or placeholder.get_text(strip=True)\n        footnote_id = identifier.strip() if identifier else \"\"\n        if not footnote_id:\n            placeholder.decompose()\n            continue\n        if footnote_id in invalid_footnotes:\n            placeholder.decompose()\n            continue\n\n        citation_keys = citation_footnotes.get(footnote_id)\n        if citation_keys and _render_citation(placeholder, citation_keys):\n            continue\n\n        citation_keys = _split_citation_keys(footnote_id)\n        if citation_keys and _render_citation(placeholder, citation_keys):\n            continue\n        # Fall back to default handling for unresolved citations.\n\n        if footnote_id in bibliography:\n            context.state.record_citation(footnote_id)\n            latex = context.formatter.citation(key=footnote_id)\n            _replace_with_latex(placeholder, latex)\n        else:\n            payload = context.state.footnotes.get(footnote_id)\n            if payload:\n                latex = context.formatter.footnote(payload)\n                _replace_with_latex(placeholder, latex)\n                continue\n            warnings.warn(\n                f\"Reference to '{footnote_id}' is not in your bibliography...\",\n                stacklevel=2,\n            )\n            replacement = mark_processed(NavigableString(footnote_id))\n            placeholder.replace_with(replacement)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_latex_raw","title":"render_latex_raw","text":"<pre><code>render_latex_raw(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre> <p>Preserve raw LATEX payloads embedded in hidden paragraphs.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\n    \"p\",\n    \"span\",\n    phase=RenderPhase.POST,\n    priority=100,\n    name=\"latex_raw\",\n    nestable=False,\n)\ndef render_latex_raw(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Preserve raw LaTeX payloads embedded in hidden paragraphs.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"latex-raw\" not in classes:\n        return\n\n    text = element.get_text(strip=False)\n    replacement = mark_processed(NavigableString(text))\n    element.replace_with(replacement)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_lists","title":"render_lists","text":"<pre><code>render_lists(root: Tag, context: RenderContext) -&gt; None\n</code></pre> <p>Render ordered and unordered lists.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(phase=RenderPhase.POST, name=\"lists\", auto_mark=False)\ndef render_lists(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render ordered and unordered lists.\"\"\"\n    for element in _iter_reversed(root.find_all([\"ol\", \"ul\"])):\n        _prepare_rich_text_content(element, context)\n        items: list[str] = []\n        checkboxes: list[int] = []\n\n        for li in element.find_all(\"li\", recursive=False):\n            checkbox_input = li.find(\"input\", attrs={\"type\": \"checkbox\"})\n            if checkbox_input is not None:\n                is_checked = checkbox_input.has_attr(\"checked\")\n                checkboxes.append(1 if is_checked else -1)\n                checkbox_input.extract()\n                text = li.get_text(strip=False).strip()\n            else:\n                text = li.get_text(strip=False).strip()\n                if text.startswith(\"[ ]\"):\n                    checkboxes.append(-1)\n                    text = text[3:].strip()\n                elif text.startswith(\"[x]\") or text.startswith(\"[X]\"):\n                    checkboxes.append(1)\n                    text = text[3:].strip()\n                else:\n                    checkboxes.append(0)\n            items.append(text)\n\n        has_checkbox = any(checkboxes) or bool(gather_classes(element.get(\"class\")))\n        latex: str\n\n        if element.name == \"ol\":\n            latex = context.formatter.ordered_list(items=items)\n        else:\n            if has_checkbox:\n                choices = list(zip((c &gt; 0 for c in checkboxes), items, strict=False))\n                latex = context.formatter.choices(items=choices)\n            else:\n                latex = context.formatter.unordered_list(items=items)\n\n        element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_paragraphs","title":"render_paragraphs","text":"<pre><code>render_paragraphs(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render plain paragraphs with script-aware wrapping.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\"p\", phase=RenderPhase.POST, priority=90, name=\"paragraphs\", nestable=False)\ndef render_paragraphs(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render plain paragraphs with script-aware wrapping.\"\"\"\n    if _render_script_paragraphs(element, context):\n        return\n    if element.get(\"data-texsmith-latex\") == \"true\":\n        content = element.get_text(strip=False)\n        element.replace_with(mark_processed(NavigableString(f\"{content}\\n\")))\n        return\n    if element.get(\"class\"):\n        return\n\n    raw_text = element.get_text(strip=False).strip(\"\\n\")\n    if not raw_text.strip():\n        element.decompose()\n        return\n\n    legacy_accents = getattr(context.config, \"legacy_latex_accents\", False)\n    contains_math = bool(_MATH_PAYLOAD_PATTERN.search(raw_text))\n    escape_text = \"\\\\\" not in raw_text and not contains_math\n    rendered = render_moving_text(\n        raw_text,\n        context,\n        legacy_accents=legacy_accents,\n        include_whitespace=True,\n        wrap_scripts=escape_text,\n        escape=escape_text,\n    )\n    element.replace_with(mark_processed(NavigableString(f\"{rendered}\\n\")))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_remaining_code_blocks","title":"render_remaining_code_blocks","text":"<pre><code>render_remaining_code_blocks(\n    root: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Convert any remaining MkDocs highlight blocks that escaped earlier passes.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(phase=RenderPhase.POST, priority=5, name=\"fallback_highlight_blocks\", auto_mark=False)\ndef render_remaining_code_blocks(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert any remaining MkDocs highlight blocks that escaped earlier passes.\"\"\"\n    for highlight in _iter_reversed(root.find_all(\"div\", class_=\"highlight\")):\n        if context.is_processed(highlight):\n            continue\n        _render_code_block(highlight, context)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_tabbed_content","title":"render_tabbed_content","text":"<pre><code>render_tabbed_content(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Unwrap MkDocs tabbed content structures.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\"div\", phase=RenderPhase.PRE, priority=120, name=\"tabbed_content\", auto_mark=False)\ndef render_tabbed_content(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Unwrap MkDocs tabbed content structures.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"tabbed-set\" not in classes:\n        return\n\n    titles: list[str] = []\n    if labels := element.find(\"div\", class_=\"tabbed-labels\"):\n        for label in labels.find_all(\"label\"):\n            titles.append(label.get_text(strip=True))\n        labels.extract()\n    else:\n        fallback_labels = element.find_all(\"label\", recursive=False)\n        for label in fallback_labels:\n            titles.append(label.get_text(strip=True))\n            label.extract()\n\n    for input_node in element.find_all(\"input\", recursive=False):\n        input_node.extract()\n\n    content_containers = element.find_all(\"div\", class_=\"tabbed-content\", recursive=False)\n    if not content_containers:\n        candidate = element.find(\"div\", class_=\"tabbed-content\")\n        if candidate is None:\n            raise InvalidNodeError(\"Missing tabbed-content container inside tabbed-set\")\n        content_containers = [candidate]\n\n    blocks: list[Tag] = []\n    for container in content_containers:\n        inner_blocks = container.find_all(\"div\", class_=\"tabbed-block\", recursive=False)\n        if inner_blocks:\n            blocks.extend(inner_blocks)\n        else:\n            blocks.append(container)\n\n    soup = element.soup\n\n    for index, block in enumerate(blocks):\n        title = titles[index] if index &lt; len(titles) else \"\"\n        if soup is None:\n            heading = mark_processed(NavigableString(f\"\\\\textbf{{{title}}}\\\\par\\n\"))\n        else:\n            heading = soup.new_tag(\"p\")\n            strong = soup.new_tag(\"strong\")\n            strong.string = title\n            heading.append(strong)\n        block.insert_before(heading)\n\n        for highlight in block.find_all(\"div\"):\n            highlight_classes = gather_classes(highlight.get(\"class\"))\n            if \"highlight\" not in highlight_classes:\n                continue\n            if context.is_processed(highlight):\n                continue\n            parent_before = highlight.parent\n            _render_code_block(highlight, context)\n            if highlight.parent is not None and highlight.parent is parent_before:\n                code_element = highlight.find(\"code\")\n                code_text = (\n                    code_element.get_text(strip=False)\n                    if code_element is not None\n                    else highlight.get_text(strip=False)\n                )\n                if code_text and not code_text.endswith(\"\\n\"):\n                    code_text += \"\\n\"\n                fallback = mark_processed(\n                    NavigableString(\n                        context.formatter.codeblock(\n                            code=code_text,\n                            language=\"text\",\n                            lineno=False,\n                            filename=None,\n                            highlight=[],\n                            baselinestretch=None,\n                        )\n                    )\n                )\n                highlight.replace_with(fallback)\n            context.mark_processed(highlight)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.blocks.render_tables","title":"render_tables","text":"<pre><code>render_tables(element: Tag, context: RenderContext) -&gt; None\n</code></pre> <p>Render HTML tables to LATEX.</p> Source code in <code>src/texsmith/adapters/handlers/blocks.py</code> <pre><code>@renders(\"table\", phase=RenderPhase.POST, priority=40, name=\"tables\", nestable=False)\ndef render_tables(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render HTML tables to LaTeX.\"\"\"\n    caption = None\n    if caption_node := element.find(\"caption\"):\n        _strip_caption_prefix(caption_node)\n        caption = caption_node.get_text(strip=False).strip()\n        caption_node.decompose()\n\n    label = coerce_attribute(element.get(\"id\"))\n\n    table_rows: list[list[str]] = []\n    styles: list[list[str]] = []\n    is_large = False\n\n    for row in element.find_all(\"tr\"):\n        row_values: list[str] = []\n        row_styles: list[str] = []\n        for cell in row.find_all([\"th\", \"td\"]):\n            content = cell.get_text(strip=False).strip()\n            row_values.append(content)\n            row_styles.append(_cell_alignment(cell))\n        table_rows.append(row_values)\n        styles.append(row_styles)\n\n        stripped = \"\".join(\n            re.sub(r\"\\\\href\\{[^\\}]+?\\}|\\\\\\w{3,}|[\\{\\}|]\", \"\", col) for col in row_values\n        )\n        if len(stripped) &gt; 50:\n            is_large = True\n\n    columns = styles[0] if styles else []\n    latex = context.formatter.table(\n        columns=columns,\n        rows=table_rows,\n        caption=caption,\n        label=label,\n        is_large=is_large,\n    )\n\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.code.render_code_blocks","title":"render_code_blocks","text":"<pre><code>render_code_blocks(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render MkDocs-highlighted code blocks.</p> Source code in <code>src/texsmith/adapters/handlers/code.py</code> <pre><code>@renders(\"div\", phase=RenderPhase.PRE, priority=40, name=\"code_blocks\", nestable=True)\ndef render_code_blocks(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render MkDocs-highlighted code blocks.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"highlight\" not in classes:\n        return\n    if \"mermaid\" in classes:\n        return\n\n    code_element = element.find(\"code\")\n    if code_element is None:\n        raise InvalidNodeError(\"Missing &lt;code&gt; element inside highlighted block\")\n    code_classes = gather_classes(code_element.get(\"class\"))\n    if any(cls in {\"language-mermaid\", \"mermaid\"} for cls in code_classes):\n        return\n\n    if _looks_like_mermaid(code_element.get_text(strip=False)):\n        return\n\n    language = _extract_language(code_element)\n    if language == \"text\":\n        language = _extract_language(element)\n    lineno = element.find(class_=\"linenos\") is not None\n\n    filename = None\n    if filename_el := element.find(class_=\"filename\"):\n        filename = filename_el.get_text(strip=True)\n\n    code_text, highlight = _collect_code_listing(code_element)\n\n    engine = _resolve_code_engine(context)\n    baselinestretch = 0.5 if _is_ascii_art(code_text) else None\n    if not code_text.endswith(\"\\n\"):\n        code_text += \"\\n\"\n\n    context.state.requires_shell_escape = context.state.requires_shell_escape or engine == \"minted\"\n    latex = context.formatter.codeblock(\n        code=code_text,\n        language=language,\n        lineno=lineno,\n        filename=filename,\n        highlight=highlight,\n        baselinestretch=baselinestretch,\n        engine=engine,\n        state=context.state,\n    )\n\n    context.suppress_children(element)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.code.render_pre_code_blocks","title":"render_pre_code_blocks","text":"<pre><code>render_pre_code_blocks(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render <pre><code> blocks that escaped earlier handlers.\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/code.py</code>\n              <pre><code>@renders(\"pre\", phase=RenderPhase.PRE, priority=38, name=\"pre_code_blocks\", nestable=False)\ndef render_pre_code_blocks(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render &lt;pre&gt;&lt;code&gt; blocks that escaped earlier handlers.\"\"\"\n    code_element = element.find(\"code\")\n    if code_element is None:\n        return\n\n    code_classes = gather_classes(code_element.get(\"class\"))\n    if any(cls in {\"language-mermaid\", \"mermaid\"} for cls in code_classes):\n        return\n\n    code_text, highlight = _collect_code_listing(code_element)\n    if _looks_like_mermaid(code_text):\n        return\n\n    language = _extract_language(code_element) or _extract_language(element)\n    engine = _resolve_code_engine(context)\n    baselinestretch = 0.5 if _is_ascii_art(code_text) else None\n    if not code_text.endswith(\"\\n\"):\n        code_text += \"\\n\"\n\n    context.state.requires_shell_escape = context.state.requires_shell_escape or engine == \"minted\"\n    latex = context.formatter.codeblock(\n        code=code_text,\n        language=language,\n        lineno=False,\n        filename=None,\n        highlight=highlight,\n        baselinestretch=baselinestretch,\n        engine=engine,\n        state=context.state,\n    )\n\n    context.mark_processed(element)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.code.render_preformatted_code","title":"render_preformatted_code","text":"<pre><code>render_preformatted_code(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render plain <pre> blocks that wrap a <code> element.\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/code.py</code>\n              <pre><code>@renders(\"pre\", phase=RenderPhase.PRE, priority=45, name=\"preformatted_code\", nestable=True)\ndef render_preformatted_code(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render plain &lt;pre&gt; blocks that wrap a &lt;code&gt; element.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"mermaid\" in classes:\n        return\n\n    parent = element.parent\n    parent_classes = gather_classes(getattr(parent, \"get\", lambda *_: None)(\"class\"))\n    if any(cls in {\"highlight\", \"codehilite\"} for cls in parent_classes):\n        return\n\n    code_element = element.find(\"code\", recursive=False)\n    code_classes = gather_classes(code_element.get(\"class\")) if code_element else []\n    if any(cls in {\"language-mermaid\", \"mermaid\"} for cls in code_classes):\n        return\n\n    if code_element is not None and _looks_like_mermaid(code_element.get_text(strip=False)):\n        return\n\n    language = _extract_language(code_element) if code_element else \"text\"\n    engine = _resolve_code_engine(context)\n    code_text = (\n        code_element.get_text(strip=False) if code_element else element.get_text(strip=False)\n    )\n\n    if not code_text.strip():\n        return\n\n    baselinestretch = 0.5 if _is_ascii_art(code_text) else None\n    if not code_text.endswith(\"\\n\"):\n        code_text += \"\\n\"\n\n    context.state.requires_shell_escape = context.state.requires_shell_escape or engine == \"minted\"\n    latex = context.formatter.codeblock(\n        code=code_text,\n        language=language,\n        lineno=False,\n        filename=None,\n        highlight=[],\n        baselinestretch=baselinestretch,\n        engine=engine,\n        state=context.state,\n    )\n\n    context.suppress_children(element)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.code.render_standalone_code_blocks","title":"render_standalone_code_blocks","text":"<pre><code>render_standalone_code_blocks(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render <code> elements that include multiline content as block code.\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/code.py</code>\n              <pre><code>@renders(\n    \"code\",\n    phase=RenderPhase.PRE,\n    priority=40,\n    name=\"standalone_code_blocks\",\n    auto_mark=False,\n)\ndef render_standalone_code_blocks(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render &lt;code&gt; elements that include multiline content as block code.\"\"\"\n    if element.find_parent(\"pre\"):\n        return\n\n    classes = element.get(\"class\") or []\n    if any(cls in {\"language-mermaid\", \"mermaid\"} for cls in classes):\n        return\n\n    code_text = element.get_text(strip=False)\n    if \"\\n\" not in code_text:\n        return\n\n    if _looks_like_mermaid(code_text):\n        return\n\n    language = _extract_language(element)\n    if language == \"text\":\n        hint, adjusted = _extract_language_hint(code_text)\n        if hint:\n            language = hint\n            code_text = adjusted\n\n    engine = _resolve_code_engine(context)\n    if engine == \"minted\":\n        code_text = code_text.replace(\"{\", r\"\\{\").replace(\"}\", r\"\\}\")\n    if not code_text.strip():\n        return\n    if not code_text.endswith(\"\\n\"):\n        code_text += \"\\n\"\n\n    baselinestretch = 0.5 if _is_ascii_art(code_text) else None\n\n    context.state.requires_shell_escape = context.state.requires_shell_escape or engine == \"minted\"\n    latex = context.formatter.codeblock(\n        code=code_text,\n        language=language,\n        lineno=False,\n        filename=None,\n        highlight=[],\n        baselinestretch=baselinestretch,\n        engine=engine,\n        state=context.state,\n    )\n\n    node = mark_processed(NavigableString(latex))\n\n    if element.parent and element.parent.name == \"p\" and _is_only_meaningful_child(element):\n        element.parent.replace_with(node)\n        context.mark_processed(element.parent)\n    else:\n        element.replace_with(node)\n    context.mark_processed(element)\n    context.suppress_children(element)\n</code></pre>\n            \n    \n\n\n\n\n\n  \n\n    \n\n\n\n\n\n\n\n\n    \n\n        <p>Advanced inline handlers ported from the legacy renderer.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n\n\n\n\n\n\n\n    \n\n        <p>Link handling utilities.</p>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.escape_plain_text","title":"escape_plain_text","text":"<pre><code>escape_plain_text(\n    root: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Escape LATEX characters on plain text nodes outside code blocks.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(phase=RenderPhase.PRE, name=\"escape_plain_text\", auto_mark=False)\ndef escape_plain_text(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Escape LaTeX characters on plain text nodes outside code blocks.\"\"\"\n    legacy_latex_accents = getattr(context.config, \"legacy_latex_accents\", False)\n    for node in list(root.find_all(string=True)):\n        if getattr(node, \"processed\", False):\n            continue\n        if _has_ancestor(node, \"code\", \"script\"):\n            continue\n        ancestor = getattr(node, \"parent\", None)\n        skip_plain_text = False\n        while ancestor is not None:\n            classes = gather_classes(getattr(ancestor, \"get\", lambda *_: None)(\"class\"))\n            if \"latex-raw\" in classes or \"arithmatex\" in classes:\n                skip_plain_text = True\n                break\n            ancestor = getattr(ancestor, \"parent\", None)\n        if skip_plain_text:\n            continue\n        text = str(node)\n        if not text:\n            continue\n        if \"\\\\keystroke{\" in text or \"\\\\keystrokes{\" in text:\n            node.replace_with(mark_processed(NavigableString(text)))\n            continue\n        matches = list(_MATH_PAYLOAD_PATTERN.finditer(text))\n        if not matches:\n            escaped = _escape_text_segment(text, context, legacy_latex_accents=legacy_latex_accents)\n            if escaped != text:\n                node.replace_with(mark_processed(NavigableString(escaped)))\n            continue\n\n        parts: list[str] = []\n        cursor = 0\n        for match in matches:\n            if match.start() &gt; cursor:\n                segment = text[cursor : match.start()]\n                if segment:\n                    escaped = _escape_text_segment(\n                        segment,\n                        context,\n                        legacy_latex_accents=legacy_latex_accents,\n                    )\n                    parts.append(escaped)\n            parts.append(match.group(0))\n            cursor = match.end()\n        if cursor &lt; len(text):\n            tail = text[cursor:]\n            if tail:\n                escaped = _escape_text_segment(\n                    tail,\n                    context,\n                    legacy_latex_accents=legacy_latex_accents,\n                )\n                parts.append(escaped)\n\n        replacement = mark_processed(NavigableString(\"\".join(parts)))\n        node.replace_with(replacement)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_abbreviation","title":"render_abbreviation","text":"<pre><code>render_abbreviation(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Register and render abbreviations.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"abbr\", phase=RenderPhase.INLINE, priority=30, name=\"abbreviation\", nestable=False)\ndef render_abbreviation(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Register and render abbreviations.\"\"\"\n    title_attr = element.get(\"title\")\n    description = title_attr.strip() if isinstance(title_attr, str) else \"\"\n    term = element.get_text(strip=True)\n\n    if not term:\n        return\n\n    if not description:\n        legacy_latex_accents = getattr(context.config, \"legacy_latex_accents\", False)\n        latex_text = escape_latex_chars(term, legacy_accents=legacy_latex_accents)\n        element.replace_with(mark_processed(NavigableString(latex_text)))\n        return\n\n    key = context.state.remember_abbreviation(term, description)\n    if not key:\n        key = term\n\n    latex = f\"\\\\acrshort{{{key}}}\"\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_critic_additions","title":"render_critic_additions","text":"<pre><code>render_critic_additions(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Convert critic-marked insertions into LATEX review macros.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"ins\",\n    phase=RenderPhase.INLINE,\n    priority=35,\n    name=\"critic_additions\",\n    auto_mark=False,\n)\ndef render_critic_additions(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert critic-marked insertions into LaTeX review macros.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"critic\" not in classes:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.addition(text=text)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_critic_comments","title":"render_critic_comments","text":"<pre><code>render_critic_comments(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render critic comments as inline LATEX annotations.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=35,\n    name=\"critic_comments\",\n    auto_mark=False,\n)\ndef render_critic_comments(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render critic comments as inline LaTeX annotations.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"critic\" not in classes or \"comment\" not in classes:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.comment(text=text)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_critic_deletions","title":"render_critic_deletions","text":"<pre><code>render_critic_deletions(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Convert critic-marked deletions into LATEX review macros.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"del\",\n    phase=RenderPhase.INLINE,\n    priority=35,\n    name=\"critic_deletions\",\n    auto_mark=False,\n)\ndef render_critic_deletions(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert critic-marked deletions into LaTeX review macros.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"critic\" not in classes:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.deletion(text=text)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_critic_highlight","title":"render_critic_highlight","text":"<pre><code>render_critic_highlight(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render critic highlights using the formatter highlighting helper.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"mark\",\n    phase=RenderPhase.INLINE,\n    priority=35,\n    name=\"critic_highlight\",\n    auto_mark=False,\n)\ndef render_critic_highlight(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render critic highlights using the formatter highlighting helper.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"critic\" not in classes:\n        return\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.highlight(text=text)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_critic_substitution","title":"render_critic_substitution","text":"<pre><code>render_critic_substitution(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render critic substitutions as paired deletion/addition markup.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=-10,\n    name=\"critic_substitution\",\n    auto_mark=False,\n)\ndef render_critic_substitution(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render critic substitutions as paired deletion/addition markup.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"critic\" not in classes or \"subst\" not in classes:\n        return\n\n    deleted = element.find(\"del\")\n    inserted = element.find(\"ins\")\n    if deleted is None or inserted is None:\n        raise InvalidNodeError(\"Critic substitution requires both &lt;del&gt; and &lt;ins&gt; children\")\n\n    original = deleted.get_text(strip=False)\n    replacement = inserted.get_text(strip=False)\n\n    latex = context.formatter.substitution(original=original, replacement=replacement)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_index_entry","title":"render_index_entry","text":"<pre><code>render_index_entry(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render inline index term annotations.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    \"a\",\n    phase=RenderPhase.INLINE,\n    priority=45,\n    name=\"index_entries\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_index_entry(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render inline index term annotations.\"\"\"\n    tag_name = coerce_attribute(element.get(\"data-tag-name\"))\n    if not tag_name:\n        return\n\n    raw_entry = str(tag_name)\n    parts = [segment.strip() for segment in raw_entry.split(\",\") if segment.strip()]\n    if not parts:\n        return\n\n    legacy_latex_accents = getattr(context.config, \"legacy_latex_accents\", False)\n    escaped_fragments = [\n        render_moving_text(part, context, legacy_accents=legacy_latex_accents, wrap_scripts=True)\n        or \"\"\n        for part in parts\n    ]\n    escaped_entry = \"!\".join(fragment for fragment in escaped_fragments if fragment)\n    style_value = coerce_attribute(element.get(\"data-tag-style\"))\n    style_key = style_value.strip().lower() if style_value else \"\"\n    if style_key not in {\"b\", \"i\", \"bi\"}:\n        style_key = \"\"\n\n    display_text = element.get_text(strip=False) or \"\"\n    escaped_text = (\n        render_moving_text(\n            display_text, context, legacy_accents=legacy_latex_accents, wrap_scripts=True\n        )\n        or \"\"\n    )\n\n    latex = context.formatter.index(escaped_text, entry=escaped_entry, style=style_key)\n    node = mark_processed(NavigableString(latex))\n    context.state.has_index_entries = True\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_inline_code","title":"render_inline_code","text":"<pre><code>render_inline_code(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render inline code elements using the formatter.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"code\", phase=RenderPhase.PRE, priority=50, name=\"inline_code\", nestable=False)\ndef render_inline_code(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render inline code elements using the formatter.\"\"\"\n    if element.find_parent(\"pre\"):\n        return\n\n    classes = gather_classes(element.get(\"class\"))\n    code = _extract_code_text(element)\n    if \"\\n\" in code:\n        return\n\n    engine = _resolve_code_engine(context)\n    language_hint = None\n    if code.startswith(\"#!\"):\n        shebang_parts = code[2:].strip().split(None, 1)\n        if shebang_parts:\n            language_hint = shebang_parts[0]\n            code = shebang_parts[1] if len(shebang_parts) &gt; 1 else \"\"\n\n    has_language = any(cls.startswith(\"language-\") for cls in classes)\n    language = None\n    if has_language or \"highlight\" in classes:\n        language = next(\n            (cls[len(\"language-\") :] or \"text\" for cls in classes if cls.startswith(\"language-\")),\n            \"text\",\n        )\n    if language_hint and not language:\n        language = language_hint\n\n    if language:\n        delimiter = _pick_mintinline_delimiter(code)\n        if delimiter and engine == \"minted\":\n            context.state.requires_shell_escape = (\n                context.state.requires_shell_escape or engine == \"minted\"\n            )\n            latex = context.formatter.codeinline(\n                language=language or \"text\",\n                text=code,\n                engine=engine,\n            )\n            element.replace_with(mark_processed(NavigableString(latex)))\n            return\n        latex = context.formatter.codeinline(\n            language=language or \"text\",\n            text=code,\n            engine=engine,\n            state=context.state,\n        )\n        element.replace_with(mark_processed(NavigableString(latex)))\n        return\n\n    latex = context.formatter.codeinlinett(code)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_inline_code_fallback","title":"render_inline_code_fallback","text":"<pre><code>render_inline_code_fallback(\n    root: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Convert lingering inline code nodes that escaped the PRE phase.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(phase=RenderPhase.POST, priority=5, name=\"inline_code_fallback\", auto_mark=False)\ndef render_inline_code_fallback(root: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert lingering inline code nodes that escaped the PRE phase.\"\"\"\n    for code in list(root.find_all(\"code\")):\n        if code.find_parent(\"pre\"):\n            continue\n        if context.is_processed(code):\n            continue\n        render_inline_code(code, context)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_keystrokes","title":"render_keystrokes","text":"<pre><code>render_keystrokes(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render keyboard shortcut markup.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"span\", phase=RenderPhase.INLINE, priority=40, name=\"keystrokes\", nestable=False)\ndef render_keystrokes(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render keyboard shortcut markup.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"keys\" not in classes:\n        return\n\n    keys: list[str] = []\n    for key in element.find_all(\"kbd\"):\n        key_classes = gather_classes(key.get(\"class\"))\n        matched: Iterable[str] = (cls[4:] for cls in key_classes if cls.startswith(\"key-\"))\n        value = next(matched, None)\n        if value:\n            keys.append(value)\n        else:\n            keys.append(key.get_text(strip=True))\n\n    latex = context.formatter.keystroke(keys)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_latex_text_span","title":"render_latex_text_span","text":"<pre><code>render_latex_text_span(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render the custom <code>latex-text</code> span into canonical LATEX.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=30,\n    name=\"latex_text\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_latex_text_span(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render the custom ``latex-text`` span into canonical LaTeX.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"latex-text\" not in classes:\n        return\n\n    latex = mark_processed(NavigableString(r\"\\LaTeX{}\"))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(latex)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_math_block","title":"render_math_block","text":"<pre><code>render_math_block(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Preserve block math payloads.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"div\",\n    phase=RenderPhase.PRE,\n    priority=30,\n    name=\"math_block\",\n    auto_mark=False,\n)\ndef render_math_block(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Preserve block math payloads.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"arithmatex\" not in classes:\n        return\n    text = element.get_text(strip=False)\n    stripped = text.strip()\n\n    match = _DISPLAY_MATH_PATTERN.match(stripped)\n    if match:\n        inner = match.group(1)\n        if _payload_is_block_environment(inner):\n            # align/equation environments already provide display math.\n            latex = f\"\\n{inner.strip()}\\n\"\n            element.replace_with(mark_processed(NavigableString(latex)))\n            return\n\n    element.replace_with(mark_processed(NavigableString(f\"\\n{text}\\n\")))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_math_inline","title":"render_math_inline","text":"<pre><code>render_math_inline(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Preserve inline math payloads untouched.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.PRE,\n    priority=60,\n    name=\"inline_math\",\n    auto_mark=False,\n)\ndef render_math_inline(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Preserve inline math payloads untouched.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"arithmatex\" not in classes:\n        return\n    text = element.get_text(strip=False)\n    element.replace_with(mark_processed(NavigableString(text)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_math_script","title":"render_math_script","text":"<pre><code>render_math_script(\n    element: Tag, _context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Preserve math payloads generated via script tags (e.g. mdx_math).</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"script\",\n    phase=RenderPhase.PRE,\n    priority=65,\n    name=\"math_script\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_math_script(element: Tag, _context: RenderContext) -&gt; None:\n    \"\"\"Preserve math payloads generated via script tags (e.g. mdx_math).\"\"\"\n    type_attr = coerce_attribute(element.get(\"type\"))\n    if type_attr is None:\n        return\n    if not type_attr.startswith(\"math/tex\"):\n        return\n\n    payload = element.get_text(strip=False)\n    if payload is None:\n        payload = \"\"\n    payload = payload.strip()\n    is_display = \"mode=display\" in type_attr\n\n    if not payload:\n        node = NavigableString(\"\")\n    elif is_display:\n        if _payload_is_block_environment(payload):\n            node = NavigableString(f\"\\n{payload}\\n\")\n        else:\n            node = NavigableString(f\"\\n$$\\n{payload}\\n$$\\n\")\n    else:\n        node = NavigableString(f\"${payload}$\")\n\n    element.replace_with(mark_processed(node))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_regex_link","title":"render_regex_link","text":"<pre><code>render_regex_link(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render custom regex helper links.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"a\", phase=RenderPhase.PRE, priority=70, name=\"regex_links\", nestable=False)\ndef render_regex_link(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render custom regex helper links.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"ycr-regex\" not in classes:\n        return\n\n    code = element.get_text(strip=False)\n    if code_tag := element.find(\"code\"):\n        code = code_tag.get_text(strip=False)\n    code = code.replace(\"&amp;\", \"\\\\&amp;\").replace(\"#\", \"\\\\#\")\n\n    href = coerce_attribute(element.get(\"href\")) or \"\"\n    latex = context.formatter.regex(code, url=requote_url(href))\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_script_spans","title":"render_script_spans","text":"<pre><code>render_script_spans(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render spans tagged with data-script into explicit text commands.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=30,\n    name=\"script_spans\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_script_spans(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render spans tagged with data-script into explicit text commands.\"\"\"\n    slug = coerce_attribute(element.get(\"data-script\"))\n    if not slug:\n        return\n\n    raw_text = element.get_text(strip=False)\n    if not raw_text:\n        element.decompose()\n        return\n\n    record_script_usage_for_slug(slug, raw_text, context)\n    legacy_accents = getattr(context.config, \"legacy_latex_accents\", False)\n    payload = escape_latex_chars(raw_text, legacy_accents=legacy_accents)\n    latex = f\"\\\\text{slug}{{{payload}}}\"\n    parent = element.parent\n    if parent is not None and getattr(parent, \"attrs\", None) is not None:\n        parent.attrs[\"data-texsmith-latex\"] = \"true\"\n    context.mark_processed(element)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_twemoji_image","title":"render_twemoji_image","text":"<pre><code>render_twemoji_image(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render Twitter emoji images as inline icons.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"img\", phase=RenderPhase.INLINE, priority=20, name=\"twemoji_images\", nestable=False)\ndef render_twemoji_image(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render Twitter emoji images as inline icons.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if not {\"twemoji\", \"emojione\"}.intersection(classes):\n        return\n    emoji_mode = _get_emoji_mode(context)\n    if emoji_mode != \"artifact\":\n        token = _extract_emoji_token(element)\n        latex = _render_font_emoji(token, _get_emoji_command(context))\n        element.replace_with(mark_processed(NavigableString(latex)))\n        return\n    if not context.runtime.get(\"copy_assets\", True):\n        placeholder = (\n            coerce_attribute(element.get(\"alt\")) or coerce_attribute(element.get(\"title\")) or \"\"\n        )\n        element.replace_with(mark_processed(NavigableString(placeholder)))\n        return\n\n    src = coerce_attribute(element.get(\"src\"))\n    if not src:\n        raise InvalidNodeError(\"Twemoji image without 'src' attribute\")\n    if not is_valid_url(src):\n        raise InvalidNodeError(\"Twemoji images must reference remote assets\")\n\n    user_agent = _resolve_http_user_agent(context)\n    options = {\"user_agent\": user_agent} if user_agent else {}\n    artefact = fetch_image(src, output_dir=context.assets.output_root, **options)\n    stored_path = context.assets.register(src, artefact)\n    asset_path = context.assets.latex_path(stored_path)\n\n    latex = context.formatter.icon(asset_path)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_twemoji_span","title":"render_twemoji_span","text":"<pre><code>render_twemoji_span(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render inline SVG emoji payloads.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=25,\n    name=\"twemoji_svg\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_twemoji_span(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render inline SVG emoji payloads.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"twemoji\" not in classes:\n        return\n    emoji_mode = _get_emoji_mode(context)\n    if emoji_mode != \"artifact\":\n        token = _extract_emoji_token(element)\n        latex = _render_font_emoji(token, _get_emoji_command(context))\n        element.replace_with(mark_processed(NavigableString(latex)))\n        return\n    if not context.runtime.get(\"copy_assets\", True):\n        placeholder = coerce_attribute(element.get(\"title\")) or element.get_text(strip=True) or \"\"\n        element.replace_with(mark_processed(NavigableString(placeholder)))\n        return\n\n    svg = element.find(\"svg\")\n    if svg is None:\n        raise InvalidNodeError(\"Expected inline SVG inside span.twemoji\")\n\n    svg_payload = str(svg)\n    artefact = svg2pdf(svg_payload, output_dir=context.assets.output_root)\n    digest = hashlib.sha256(svg_payload.encode(\"utf-8\")).hexdigest()\n    stored_path = context.assets.register(f\"twemoji::{digest}\", artefact)\n    asset_path = context.assets.latex_path(stored_path)\n\n    latex = context.formatter.icon(asset_path)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.inline.render_unicode_link","title":"render_unicode_link","text":"<pre><code>render_unicode_link(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render Unicode helper links.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/inline.py</code>\n              <pre><code>@renders(\"a\", phase=RenderPhase.PRE, priority=80, name=\"unicode_links\", nestable=False)\ndef render_unicode_link(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render Unicode helper links.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"ycr-unicode\" not in classes:\n        return\n\n    code = element.get_text(strip=True)\n    href = coerce_attribute(element.get(\"href\")) or \"\"\n    latex = context.formatter.href(text=f\"U+{code}\", url=requote_url(href))\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.links.render_autoref","title":"render_autoref","text":"<pre><code>render_autoref(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render  custom tags.\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/links.py</code>\n              <pre><code>@renders(\n    \"autoref\",\n    phase=RenderPhase.INLINE,\n    priority=10,\n    name=\"autoref_tags\",\n    nestable=False,\n)\ndef render_autoref(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render &lt;autoref&gt; custom tags.\"\"\"\n    identifier = coerce_attribute(element.get(\"identifier\"))\n    if not identifier:\n        legacy_latex_accents = getattr(context.config, \"legacy_latex_accents\", False)\n        literal = f\"&lt;{element.name}&gt;\"\n        latex = escape_latex_chars(literal, legacy_accents=legacy_latex_accents)\n        element.replace_with(mark_processed(NavigableString(latex)))\n        return\n    text = element.get_text(strip=False)\n\n    latex = context.formatter.ref(text, ref=identifier)\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>\n            \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n    \n\n\n\n\n\n\n\n\n    \n\n        <p>Handlers responsible for assets such as images and diagrams.</p>"},{"location":"api/handlers/#texsmith.adapters.handlers.links.render_autoref_spans","title":"render_autoref_spans","text":"<pre><code>render_autoref_spans(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render MkDocs autoref span placeholders.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/links.py</code>\n              <pre><code>@renders(\n    \"span\",\n    phase=RenderPhase.INLINE,\n    priority=15,\n    name=\"autoref_spans\",\n    nestable=False,\n    auto_mark=False,\n)\ndef render_autoref_spans(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render MkDocs autoref span placeholders.\"\"\"\n    identifier = coerce_attribute(element.get(\"data-autorefs-identifier\"))\n    if not identifier:\n        return\n    text = element.get_text(strip=False)\n\n    latex = context.formatter.ref(text, ref=identifier)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.links.render_links","title":"render_links","text":"<pre><code>render_links(element: Tag, context: RenderContext) -&gt; None\n</code></pre>\n\n    \n\n        <p>Render hyperlinks and internal references.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/links.py</code>\n              <pre><code>@renders(\"a\", phase=RenderPhase.INLINE, priority=60, name=\"links\", nestable=False)\ndef render_links(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render hyperlinks and internal references.\"\"\"\n    href = coerce_attribute(element.get(\"href\")) or \"\"\n    element_id = coerce_attribute(element.get(\"id\"))\n    text = element.get_text(strip=False)\n\n    # Already handled in preprocessing modules\n    if element.name != \"a\":\n        return\n\n    parsed_href = urlparse(href)\n    scheme = (parsed_href.scheme or \"\").lower()\n    fragment = parsed_href.fragment.strip() if parsed_href.fragment else \"\"\n\n    if scheme in {\"http\", \"https\"}:\n        latex = context.formatter.href(text=text, url=requote_url(href))\n    elif scheme:\n        raise InvalidNodeError(f\"Unsupported link scheme '{scheme}' for '{href}'.\")\n    elif href.startswith(\"#\"):\n        latex = context.formatter.ref(text, ref=href[1:])\n    elif href == \"\" and element_id:\n        latex = context.formatter.label(element_id)\n    elif href:\n        resolved = _resolve_local_target(context, href)\n        if resolved is None:\n            raise AssetMissingError(f\"Unable to resolve link target '{href}'\")\n        target_ref = fragment or _infer_heading_reference(resolved)\n        if target_ref:\n            latex = context.formatter.ref(text or \"\", ref=target_ref)\n        else:\n            content = resolved.read_bytes()\n            digest = sha256(content).hexdigest()\n            reference = f\"snippet:{digest}\"\n            context.state.register_snippet(\n                reference,\n                {\n                    \"path\": resolved,\n                    \"content\": content,\n                    \"format\": resolved.suffix[1:] if resolved.suffix else \"\",\n                },\n            )\n            latex = context.formatter.ref(text or \"extrait\", ref=reference)\n    else:\n        legacy_latex_accents = getattr(context.config, \"legacy_latex_accents\", False)\n        latex = escape_latex_chars(text, legacy_accents=legacy_latex_accents)\n\n    element.replace_with(mark_processed(NavigableString(latex)))\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.media.render_images","title":"render_images","text":"<pre><code>render_images(element: Tag, context: RenderContext) -&gt; None\n</code></pre>\n\n    \n\n        <p>Convert  nodes into LATEX figures and manage assets.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/media.py</code>\n              <pre><code>@renders(\"img\", phase=RenderPhase.BLOCK, name=\"render_images\", nestable=False)\ndef render_images(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert &lt;img&gt; nodes into LaTeX figures and manage assets.\"\"\"\n    if not context.runtime.get(\"copy_assets\", True):\n        alt_text = (\n            coerce_attribute(element.get(\"alt\")) or coerce_attribute(element.get(\"title\")) or \"\"\n        )\n        placeholder = alt_text.strip() or \"[image]\"\n        element.replace_with(mark_processed(NavigableString(placeholder)))\n        return\n\n    src = coerce_attribute(element.get(\"src\"))\n    if not src:\n        raise InvalidNodeError(\"Image tag without 'src' attribute\")\n\n    src = _strip_mkdocs_theme_variant(src)\n\n    classes = gather_classes(element.get(\"class\"))\n    if {\"twemoji\", \"emojione\"}.intersection(classes):\n        return\n\n    if element.find_parent(\"figure\"):\n        return\n\n    raw_alt = coerce_attribute(element.get(\"alt\"))\n    alt_text = raw_alt.strip() if raw_alt else None\n    raw_title = coerce_attribute(element.get(\"title\"))\n    caption_text = raw_title.strip() if raw_title else None\n    width = coerce_attribute(element.get(\"width\")) or None\n    template = _figure_template_for(element)\n\n    link_wrapper = None\n    link_target = None\n    parent = element.parent\n    if isinstance(parent, Tag) and parent.name == \"a\":\n        candidates = [\n            child\n            for child in parent.contents\n            if not (isinstance(child, NavigableString) and not child.strip())\n        ]\n        if len(candidates) == 1 and candidates[0] is element:\n            link_wrapper = parent\n            link_target = coerce_attribute(parent.get(\"href\"))\n\n    mermaid_payload = _load_mermaid_diagram(context, src)\n    if mermaid_payload is not None:\n        diagram, _ = mermaid_payload\n        figure_node = _render_mermaid_diagram(\n            context,\n            diagram,\n            template=template,\n            caption=caption_text,\n        )\n        if figure_node is None:\n            raise InvalidNodeError(f\"Mermaid source '{src}' does not contain a valid diagram\")\n        element.replace_with(figure_node)\n        return\n\n    if not caption_text:\n        caption_text = alt_text\n\n    if is_valid_url(src):\n        stored_path = store_remote_image_asset(context, src)\n    else:\n        resolved = _resolve_source_path(context, src)\n        if resolved is None:\n            raise AssetMissingError(f\"Unable to resolve image asset '{src}'\")\n\n        stored_path = store_local_image_asset(context, resolved)\n\n    figure_node = _apply_figure_template(\n        context,\n        path=stored_path,\n        caption=caption_text,\n        alt=alt_text,\n        label=None,\n        width=width,\n        template=template,\n        adjustbox=False,\n        link=link_target,\n    )\n    if link_wrapper:\n        link_wrapper.replace_with(figure_node)\n    else:\n        element.replace_with(figure_node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.media.render_mermaid","title":"render_mermaid","text":"<pre><code>render_mermaid(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Convert Mermaid code blocks inside highlight containers.</p>\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/media.py</code>\n              <pre><code>@renders(\"div\", phase=RenderPhase.BLOCK, name=\"render_mermaid\", nestable=False)\ndef render_mermaid(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Convert Mermaid code blocks inside highlight containers.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"highlight\" not in classes and \"mermaid\" not in classes:\n        return\n\n    code = element.find(\"code\")\n    if code is None:\n        return\n\n    diagram = code.get_text()\n    width = coerce_attribute(code.get(\"width\") or element.get(\"width\"))\n    template = _figure_template_for(element)\n    figure_node = _render_mermaid_diagram(context, diagram, template=template, width=width)\n    if figure_node is None:\n        return\n\n    element.replace_with(figure_node)\n</code></pre>"},{"location":"api/handlers/#texsmith.adapters.handlers.media.render_mermaid_pre","title":"render_mermaid_pre","text":"<pre><code>render_mermaid_pre(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre>\n\n    \n\n        <p>Handle <pre> blocks.\n\n\n            \n              Source code in <code>src/texsmith/adapters/handlers/media.py</code>\n              <pre><code>@renders(\"pre\", phase=RenderPhase.BLOCK, name=\"render_mermaid_pre\", nestable=False)\ndef render_mermaid_pre(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Handle &lt;pre class=\\\"mermaid\\\"&gt; blocks.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"mermaid\" not in classes:\n        return\n\n    diagram: str | None = None\n    source_hint = coerce_attribute(element.get(\"data-mermaid-source\"))\n    if source_hint:\n        payload = _load_mermaid_diagram(context, source_hint)\n        if payload is not None:\n            diagram, _ = payload\n    if diagram is None:\n        diagram = element.get_text()\n    width = coerce_attribute(element.get(\"width\"))\n\n    template = _figure_template_for(element)\n    figure_node = _render_mermaid_diagram(context, diagram, template=template, width=width)\n    if figure_node is None:\n        return\n\n    element.replace_with(figure_node)\n</code></pre>"},{"location":"api/high-level/","title":"High-Level Workflows","text":"<p>TeXSmith exposes a thin, expressive fa\u00e7ade over the lower-level conversion primitives. Mix and match Markdown, HTML, and template-aware documents without touching the CLI or re-implementing glue code.</p> <p>This page showcases the building blocks you are most likely to use in scripts, services, or notebooks. All examples assume <code>pip install texsmith</code> (or <code>uv tool install texsmith</code>) plus any template packages you rely on.</p> <p>Run the snippets</p> <p>Save the examples into a file and execute them with <code>uv run python example.py</code>. The snippets rely only on fixtures you create alongside the script.</p>"},{"location":"api/high-level/#convert-a-handful-of-documents","title":"Convert a handful of documents","text":"<p>Use <code>Document.from_markdown</code> / <code>Document.from_html</code> to normalise inputs, then hand everything to <code>convert_documents</code>. The bundle returned by <code>convert_documents</code> keeps every fragment, output path, and the raw LATEX handy:</p> <pre><code>from pathlib import Path\n\nfrom texsmith import Document, convert_documents\n\ndocs = [\n    Document.from_markdown(\n        Path(\"foo.md\"),\n        heading=\"section\",  # named levels map to LaTeX sectioning commands\n    ),\n    Document.from_markdown(Path(\"bar.md\"), heading=0),\n    Document.from_html(Path(\"baz.html\"), selector=\"main.article__content\"),\n]\n\nbundle = convert_documents(docs, output_dir=Path(\"build\"))\n\nprint(\"Combined LaTeX:\\n\", bundle.combined_output())\nfor fragment in bundle.fragments:\n    print(\"Rendered fragment\", fragment.stem, \"\u2192\", fragment.output_path)\n</code></pre> <p><code>ConversionRequest</code> carries conversion settings (parser, fallbacks, manifest emission, etc.) in addition to document inputs. When you omit <code>output_dir</code>, the bundle stays in memory\u2014perfect for unit tests or further processing.</p> <p>Use it to opt into legacy LATEX accent macros (default is Unicode output):</p> <pre><code>from pathlib import Path\n\nfrom texsmith import ConversionRequest, convert_documents, Document\n\nsettings = ConversionRequest(legacy_latex_accents=True)\nbundle = convert_documents([Document.from_markdown(Path(\"intro.md\"))], settings=settings)\n</code></pre>"},{"location":"api/high-level/#drive-the-pipeline-with-conversionservice","title":"Drive the pipeline with <code>ConversionService</code>","text":"<p>If you need the exact orchestration used by the CLI, rely on <code>ConversionService</code>. It exposes two steps:</p> <ol> <li><code>prepare_documents(request)</code> splits inputs, normalises Markdown/HTML, applies slot assignments, and returns a <code>ConversionPrepared</code> payload.</li> <li><code>execute(request, prepared=...)</code> renders the documents, optionally through a template, and produces a <code>ConversionResponse</code> with the bundle plus emitted diagnostics.</li> </ol> <pre><code>from pathlib import Path\n\nfrom texsmith import ConversionRequest, ConversionService\n\nservice = ConversionService()\nrequest = ConversionRequest(\n    documents=[Path(\"index.html\")],\n    selector=\"article.md-content__inner\",\n    template=\"article\",\n    render_dir=Path(\"build\"),\n    bibliography_files=[Path(\"refs.bib\")],\n    debug=True,\n)\nprepared = service.prepare_documents(request)\nresponse = service.execute(request, prepared=prepared)\n\nfor event in response.diagnostics:\n    print(event.name, event.payload)\n</code></pre> <p>The CLI passes a <code>CliEmitter</code> via <code>ConversionRequest.emitter</code> so warnings surface nicely. Library callers can supply their own emitter or accept the default <code>NullEmitter</code>.</p>"},{"location":"api/high-level/#work-with-templates-programmatically","title":"Work with templates programmatically","text":"<p><code>TemplateSession</code> wraps template discovery, option management, slot assignments, and final rendering (the heavy lifting lives in <code>texsmith.core.conversion.TemplateRenderer</code>).  Anything you can do from the CLI works here too, but you get a richer, Pythonic surface:</p> <pre><code>from pathlib import Path\n\nfrom texsmith import Document, TemplateSession, get_template\n\nsession = get_template(\"article\")\n\n# Configure template defaults (auto-completion friendly)\noptions = session.get_default_options()\noptions[\"title\"] = \"A Binder of Multiple Files\"\noptions[\"author\"] = \"Your Name\"\noptions[\"date\"] = \"2024-06-01\"\nsession.set_options(options)\n\n# Prepare documents\ndefault_extensions = None  # use built-in defaults\nfoo = Document.from_markdown(Path(\"foo.md\"), extensions=default_extensions)\nabstract = Document.from_markdown(Path(\"abstract.md\"), extensions=default_extensions)\nabstract.drop_title = True\n\nsession.add_document(foo)\nsession.add_document(abstract, slot=\"abstract\")\n\nresult = session.render(Path(\"outdir\"))\nprint(\"Main TeX file:\", result.main_tex_path)\nprint(\"LaTeX fragments:\", result.fragment_paths)\nprint(\"Template engine:\", result.template_engine)\n</code></pre> <p>Need bibliography support? Register <code>.bib</code> files with <code>session.add_bibliography(...)</code> before calling <code>render</code>. Every slot override (<code>Document.assign_slot</code>) and metadata tweak flows straight through to the template runtime.</p> <p>Note</p> <p>For practical slot recipes (front matter/main matter splits, appendix routing, overrides) see the Template Cookbook.</p>"},{"location":"api/high-level/#reuse-the-same-plumbing-as-the-cli","title":"Reuse the same plumbing as the CLI","text":"<p><code>texsmith</code> relies on these high-level primitives. Inspect the CLI command and you will notice the same API surface shown above. Scripts and command-line invocations stay aligned, and new features land in one place.</p> <p>For a complete reference, browse the API browser or explore the source directly in <code>src/texsmith/core/</code>.</p> <p>Seealso</p> <ul> <li>Command-line Overview explains how these APIs surface through Typer commands.</li> <li>Core Engine documents the lower-level modules if you need to plug into diagnostics or templating internals.</li> </ul>"},{"location":"api/latex/","title":"LATEX","text":"<p>LATEX-specific utilities exposed by Texsmith.</p> <p>Utilities for rendering LATEX partials (snippets).</p> <p>High-level HTML to LATEX renderer based on the modular pipeline.</p> <p>Utilities for parsing and presenting output from LATEX engine builds.</p> <p>Utility helpers specific to LATEX rendering.</p> <p>Public template helpers shared across the conversion pipeline.</p> <p>Core classes used to load and wrap LATEX templates.</p> <p>Helpers for loading template instances from disk or entry points.</p> <p>Pydantic models describing LATEX template manifests.</p> <p>Runtime helpers for binding LATEX templates to rendered documents.</p>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter","title":"LaTeXFormatter","text":"<pre><code>LaTeXFormatter(template_dir: Path = TEMPLATE_DIR)\n</code></pre> <p>Render LATEX templates using Jinja2 with custom delimiters.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def __init__(self, template_dir: Path = TEMPLATE_DIR) -&gt; None:\n    self.env = Environment(\n        block_start_string=r\"\\BLOCK{\",\n        block_end_string=r\"}\",\n        variable_start_string=r\"\\VAR{\",\n        variable_end_string=r\"}\",\n        comment_start_string=r\"\\COMMENT{\",\n        comment_end_string=r\"}\",\n        loader=FileSystemLoader(template_dir),\n    )\n    self.legacy_latex_accents: bool = False\n    self.env.filters.setdefault(\"latex_escape\", self._escape_latex)\n    self.env.filters.setdefault(\"escape_latex\", self._escape_latex)\n\n    template_paths: list[Path] = []\n    for ext in (\".tex\", \".cls\"):\n        template_paths.extend(template_dir.glob(f\"**/*{ext}\"))\n\n    self._template_names: dict[str, str] = {}\n    for path in template_paths:\n        relative = path.relative_to(template_dir)\n        key = self._normalise_key(relative.with_suffix(\"\").as_posix())\n        self._template_names[key] = relative.as_posix()\n\n    self.templates: dict[str, Template] = {}\n    self.default_code_engine = \"pygments\"\n    self.default_code_style = \"bw\"\n    self._pygments: PygmentsLatexHighlighter | None = None\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.template_names","title":"template_names  <code>property</code>","text":"<pre><code>template_names: set[str]\n</code></pre> <p>Return the set of available template identifiers.</p>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(method: str) -&gt; Callable[..., str]\n</code></pre> <p>Proxy calls to templates or custom handlers.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def __getattr__(self, method: str) -&gt; Callable[..., str]:\n    \"\"\"Proxy calls to templates or custom handlers.\"\"\"\n    mangled = f\"handle_{method}\"\n    try:\n        handler = object.__getattribute__(self, mangled)\n    except AttributeError:\n        handler = None\n    if handler is not None:\n        return handler  # type: ignore[return-value]\n\n    try:\n        template = self._get_template(method)\n    except KeyError:\n        raise AttributeError(f\"Object has no template for '{method}'\") from None\n\n    def render_template(*args: Any, **kwargs: Any) -&gt; str:\n        \"\"\"Render the template with optional positional shorthand.\"\"\"\n        if len(args) &gt; 1:\n            msg = f\"Expected at most 1 argument, got {len(args)}, use keyword arguments instead\"\n            raise ValueError(msg)\n        if args:\n            kwargs[\"text\"] = args[0]\n        return template.render(**kwargs)\n\n    return render_template\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.get_cover","title":"get_cover","text":"<pre><code>get_cover(name: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Render a named cover template populated with book metadata.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def get_cover(self, name: str, **kwargs: Any) -&gt; str:\n    \"\"\"Render a named cover template populated with book metadata.\"\"\"\n    template = self._get_template(f\"cover/{name}\")\n    return template.render(\n        title=self.config.title,  # type: ignore[attr-defined]\n        author=self.config.author,  # type: ignore[attr-defined]\n        subtitle=self.config.subtitle,  # type: ignore[attr-defined]\n        email=self.config.email,  # type: ignore[attr-defined]\n        year=self.config.year,  # type: ignore[attr-defined]\n        **self.config.cover.model_dump(),  # type: ignore[attr-defined]\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.handle_codeblock","title":"handle_codeblock","text":"<pre><code>handle_codeblock(\n    code: str,\n    language: str = \"text\",\n    filename: str | None = None,\n    lineno: bool = False,\n    highlight: Iterable[int] | None = None,\n    baselinestretch: float | None = None,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    **_: Any,\n) -&gt; str\n</code></pre> <p>Render code blocks with optional line numbers and highlights.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeblock(\n    self,\n    code: str,\n    language: str = \"text\",\n    filename: str | None = None,\n    lineno: bool = False,\n    highlight: Iterable[int] | None = None,\n    baselinestretch: float | None = None,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    **_: Any,\n) -&gt; str:\n    \"\"\"Render code blocks with optional line numbers and highlights.\"\"\"\n    highlight = list(highlight or [])\n    optimized_highlight = optimize_list(highlight)\n    normalized_engine = (engine or self.default_code_engine or \"pygments\").lower()\n    if normalized_engine not in {\"minted\", \"listings\", \"verbatim\", \"pygments\"}:\n        normalized_engine = \"pygments\"\n\n    if normalized_engine == \"pygments\":\n        style_name = str(self.default_code_style or \"bw\").strip() or \"bw\"\n        if self._pygments is None or self._pygments.style != style_name:\n            self._pygments = PygmentsLatexHighlighter(style=style_name)\n        latex_code, style_defs = self._pygments.render(\n            code,\n            language,\n            linenos=lineno,\n            highlight_lines=highlight,\n        )\n        if state is not None and style_defs:\n            state.pygments_styles.setdefault(self._pygments.style_key, style_defs)\n        return self._get_template(\"codeblock_pygments\").render(\n            code=latex_code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    if normalized_engine == \"listings\":\n        return self._get_template(\"codeblock_listings\").render(\n            code=code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    if normalized_engine == \"verbatim\":\n        return self._get_template(\"codeblock_verbatim\").render(\n            code=code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    return self._get_template(\"codeblock\").render(\n        code=code,\n        language=language,\n        linenos=lineno,\n        filename=filename,\n        baselinestretch=baselinestretch,\n        highlight=optimized_highlight,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.handle_codeinline","title":"handle_codeinline","text":"<pre><code>handle_codeinline(\n    *,\n    language: str = \"text\",\n    text: str,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    delimiter: str | None = None,\n) -&gt; str\n</code></pre> <p>Render inline code with engine-specific highlighting.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeinline(\n    self,\n    *,\n    language: str = \"text\",\n    text: str,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    delimiter: str | None = None,\n) -&gt; str:\n    \"\"\"Render inline code with engine-specific highlighting.\"\"\"\n    normalized_engine = (engine or self.default_code_engine or \"pygments\").lower()\n    if normalized_engine == \"minted\":\n        delimiter = delimiter or \"|\"\n        return self._get_template(\"codeinline\").render(\n            language=language or \"text\",\n            text=text,\n            delimiter=delimiter,\n        )\n\n    if normalized_engine == \"pygments\":\n        style_name = str(self.default_code_style or \"bw\").strip() or \"bw\"\n        if self._pygments is None or self._pygments.style != style_name:\n            self._pygments = PygmentsLatexHighlighter(style=style_name)\n        latex_code, style_defs = self._pygments.render_inline(text, language)\n        if state is not None and style_defs:\n            state.pygments_styles.setdefault(self._pygments.style_key, style_defs)\n        return r\"{\\ttfamily \" + latex_code + \"}\"\n\n    # listings/verbatim fallback to plain typewriter\n    return self.handle_codeinlinett(text)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.handle_codeinlinett","title":"handle_codeinlinett","text":"<pre><code>handle_codeinlinett(text: str) -&gt; str\n</code></pre> <p>Render plain inline code inside \\texttt.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeinlinett(self, text: str) -&gt; str:\n    \"\"\"Render plain inline code inside \\\\texttt.\"\"\"\n    escaped = escape_latex_chars(text, legacy_accents=self.legacy_latex_accents)\n    escaped = escaped.replace(\"-\", \"-\\\\allowbreak{}\")\n    return self._get_template(\"codeinlinett\").render(text=escaped)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.handle_href","title":"handle_href","text":"<pre><code>handle_href(text: str, url: str) -&gt; str\n</code></pre> <p>Render \\href links with escaped URLs.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_href(self, text: str, url: str) -&gt; str:\n    \"\"\"Render \\\\href links with escaped URLs.\"\"\"\n    return self._get_template(\"href\").render(text=text, url=self._escape_url(url))\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.handle_regex","title":"handle_regex","text":"<pre><code>handle_regex(text: str, url: str) -&gt; str\n</code></pre> <p>Render regex helper links with escaped URLs.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_regex(self, text: str, url: str) -&gt; str:\n    \"\"\"Render regex helper links with escaped URLs.\"\"\"\n    return self._get_template(\"regex\").render(text=text, url=self._escape_url(url))\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.normalise_key","title":"normalise_key  <code>classmethod</code>","text":"<pre><code>normalise_key(name: str) -&gt; str\n</code></pre> <p>Public wrapper for normalising template identifiers.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>@classmethod\ndef normalise_key(cls, name: str) -&gt; str:\n    \"\"\"Public wrapper for normalising template identifiers.\"\"\"\n    return cls._normalise_key(name)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.override_template","title":"override_template","text":"<pre><code>override_template(name: str, source: str | Path) -&gt; None\n</code></pre> <p>Override a built-in template snippet using an external payload.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def override_template(self, name: str, source: str | Path) -&gt; None:\n    \"\"\"Override a built-in template snippet using an external payload.\"\"\"\n    if isinstance(source, Path):\n        template_source = source.read_text(encoding=\"utf-8\")\n        template_name = source.as_posix()\n    else:\n        template_source = source\n        template_name = name\n\n    template = self.env.from_string(template_source)\n    template.name = template_name\n    normalised = self._normalise_key(name)\n    self.templates[normalised] = template\n    self._template_names[normalised] = template_name\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.svg","title":"svg","text":"<pre><code>svg(svg: str | Path) -&gt; str\n</code></pre> <p>Render an SVG image by converting it to PDF first.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def svg(self, svg: str | Path) -&gt; str:\n    \"\"\"Render an SVG image by converting it to PDF first.\"\"\"\n    from ..transformers import svg2pdf\n\n    pdfpath = svg2pdf(svg, self.output_path)  # type: ignore[attr-defined]\n    return f\"\\\\includegraphics[width=1em]{{{pdfpath}}}\"\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXFormatter.url","title":"url","text":"<pre><code>url(text: str, url: str) -&gt; str\n</code></pre> <p>Render a URL, escaping special LATEX characters.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def url(self, text: str, url: str) -&gt; str:\n    \"\"\"Render a URL, escaping special LaTeX characters.\"\"\"\n    safe_url = self._escape_url(url)\n    return self._get_template(\"url\").render(text=text, url=safe_url)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXRenderer","title":"LaTeXRenderer","text":"<pre><code>LaTeXRenderer(\n    config: BookConfig | None = None,\n    formatter: LaTeXFormatter | None = None,\n    output_root: Path | str = Path(\"build\"),\n    parser: str = \"lxml\",\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n)\n</code></pre> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def __init__(\n    self,\n    config: BookConfig | None = None,\n    formatter: LaTeXFormatter | None = None,\n    output_root: Path | str = Path(\"build\"),\n    parser: str = \"lxml\",\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n) -&gt; None:\n    self.config = config or BookConfig()\n    self.formatter = formatter or LaTeXFormatter()\n    self.parser_backend = parser\n    self.copy_assets = copy_assets\n    self.convert_assets = convert_assets\n    self.hash_assets = hash_assets\n\n    self.output_root = Path(output_root)\n    self.assets_root = (self.output_root / \"assets\").resolve()\n\n    self.assets = AssetRegistry(self.assets_root, copy_assets=self.copy_assets)\n\n    # Keep formatter in sync with runtime environment\n    self.formatter.config = self.config  # type: ignore[assignment]\n    self.formatter.output_path = self.assets_root  # type: ignore[assignment]\n    self.formatter.legacy_latex_accents = self.config.legacy_latex_accents\n\n    self.engine = RenderEngine()\n    self._register_builtin_handlers()\n    self._register_entry_point_handlers()\n    register_all_renderers(self)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXRenderer.describe_registered_rules","title":"describe_registered_rules","text":"<pre><code>describe_registered_rules() -&gt; list[dict[str, object]]\n</code></pre> <p>Return detailed metadata about registered rules.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def describe_registered_rules(self) -&gt; list[dict[str, object]]:\n    \"\"\"Return detailed metadata about registered rules.\"\"\"\n    return self.engine.registry.describe()\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXRenderer.iter_registered_rules","title":"iter_registered_rules","text":"<pre><code>iter_registered_rules() -&gt; Iterable[\n    tuple[RenderPhase, str]\n]\n</code></pre> <p>Expose currently registered rules for debugging/reporting.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def iter_registered_rules(self) -&gt; Iterable[tuple[RenderPhase, str]]:\n    \"\"\"Expose currently registered rules for debugging/reporting.\"\"\"\n    for phase in RenderPhase:\n        for rule in self.engine.registry.iter_phase(phase):\n            yield phase, rule.name\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXRenderer.register","title":"register","text":"<pre><code>register(handler: Any) -&gt; None\n</code></pre> <p>Register additional handlers on demand.</p> <p>Arguments can be callables decorated with :func:<code>renders</code> or modules/classes exposing decorated attributes.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def register(self, handler: Any) -&gt; None:\n    \"\"\"Register additional handlers on demand.\n\n    Arguments can be callables decorated with :func:`renders` or modules/classes\n    exposing decorated attributes.\n    \"\"\"\n    definition = getattr(handler, \"__render_rule__\", None)\n    if definition is not None:\n        self.engine.register(handler)\n        return\n\n    self.engine.collect_from(handler)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.LaTeXRenderer.render","title":"render","text":"<pre><code>render(\n    html: str,\n    *,\n    runtime: Mapping[str, Any] | None = None,\n    state: DocumentState | None = None,\n    emitter: DiagnosticEmitter | None = None,\n) -&gt; str\n</code></pre> <p>Render an HTML fragment into LATEX.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def render(\n    self,\n    html: str,\n    *,\n    runtime: Mapping[str, Any] | None = None,\n    state: DocumentState | None = None,\n    emitter: DiagnosticEmitter | None = None,\n) -&gt; str:\n    \"\"\"Render an HTML fragment into LaTeX.\"\"\"\n    active_emitter = emitter or NullEmitter()\n    try:\n        soup = BeautifulSoup(html, self.parser_backend)\n    except FeatureNotFound:\n        if self.parser_backend == \"html.parser\":\n            raise\n        # Fall back to the built-in parser when the preferred backend is missing.\n        from texsmith.core.conversion.debug import record_event\n\n        record_event(\n            active_emitter,\n            \"parser_fallback\",\n            {\"preferred\": self.parser_backend, \"fallback\": \"html.parser\"},\n        )\n        soup = BeautifulSoup(html, \"html.parser\")\n        self.parser_backend = \"html.parser\"\n    document_state = state or DocumentState()\n\n    context = RenderContext(\n        config=self.config,\n        formatter=self.formatter,\n        document=soup,\n        assets=self.assets,\n        state=document_state,\n    )\n\n    context.attach_runtime(\n        copy_assets=self.copy_assets,\n        convert_assets=self.convert_assets,\n        hash_assets=self.hash_assets,\n        emitter=active_emitter,\n    )\n    if runtime:\n        context.attach_runtime(**runtime)\n\n    try:\n        self.engine.run(soup, context)\n    except Exception as exc:  # pragma: no cover - defensive\n        raise LatexRenderingError(\"LaTeX rendering failed\") from exc\n\n    return self._collect_output(soup)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.escape_latex_chars","title":"escape_latex_chars","text":"<pre><code>escape_latex_chars(\n    text: str, *, legacy_accents: bool = False\n) -&gt; str\n</code></pre> <p>Escape LATEX special characters leveraging pylatexenc.</p> Source code in <code>src/texsmith/adapters/latex/utils.py</code> <pre><code>def escape_latex_chars(text: str, *, legacy_accents: bool = False) -&gt; str:\n    \"\"\"Escape LaTeX special characters leveraging pylatexenc.\"\"\"\n    if not text:\n        return text\n    parts: list[str] = []\n    buffer: list[str] = []\n\n    def _encode_chunk(chunk: str) -&gt; str:\n        escaped = \"\".join(_BASIC_LATEX_ESCAPE_MAP.get(char, char) for char in chunk)\n        if legacy_accents:\n            encoded = unicode_to_latex(escaped, non_ascii_only=True, unknown_char_warning=False)\n            return _wrap_latex_output(encoded)\n        return escaped\n\n    def _should_skip_encoding(char: str) -&gt; bool:\n        try:\n            name = unicodedata.name(char)\n        except ValueError:\n            return False\n        if \"SUPERSCRIPT\" in name or \"SUBSCRIPT\" in name:\n            return True\n        return \"MODIFIER LETTER\" in name and (\"SMALL\" in name or \"CAPITAL\" in name)\n\n    for char in text:\n        replacement = _COMMON_SYMBOL_MAP.get(char)\n        if replacement is not None:\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(replacement)\n            continue\n        if _should_skip_encoding(char):\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(char)\n        else:\n            buffer.append(char)\n\n    if buffer:\n        parts.append(_encode_chunk(\"\".join(buffer)))\n\n    return \"\".join(parts)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.optimize_list","title":"optimize_list","text":"<pre><code>optimize_list(numbers: Iterable[int]) -&gt; list[str]\n</code></pre> <p>Merge consecutive integers into human-readable ranges.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def optimize_list(numbers: Iterable[int]) -&gt; list[str]:\n    \"\"\"Merge consecutive integers into human-readable ranges.\"\"\"\n    values = sorted(numbers)\n    if not values:\n        return []\n\n    optimized: list[str] = []\n    start = end = values[0]\n\n    for num in values[1:]:\n        if num == end + 1:\n            end = num\n        else:\n            optimized.append(f\"{start}-{end}\" if start != end else str(start))\n            start = end = num\n\n    optimized.append(f\"{start}-{end}\" if start != end else str(start))\n    return optimized\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter","title":"LaTeXFormatter","text":"<pre><code>LaTeXFormatter(template_dir: Path = TEMPLATE_DIR)\n</code></pre> <p>Render LATEX templates using Jinja2 with custom delimiters.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def __init__(self, template_dir: Path = TEMPLATE_DIR) -&gt; None:\n    self.env = Environment(\n        block_start_string=r\"\\BLOCK{\",\n        block_end_string=r\"}\",\n        variable_start_string=r\"\\VAR{\",\n        variable_end_string=r\"}\",\n        comment_start_string=r\"\\COMMENT{\",\n        comment_end_string=r\"}\",\n        loader=FileSystemLoader(template_dir),\n    )\n    self.legacy_latex_accents: bool = False\n    self.env.filters.setdefault(\"latex_escape\", self._escape_latex)\n    self.env.filters.setdefault(\"escape_latex\", self._escape_latex)\n\n    template_paths: list[Path] = []\n    for ext in (\".tex\", \".cls\"):\n        template_paths.extend(template_dir.glob(f\"**/*{ext}\"))\n\n    self._template_names: dict[str, str] = {}\n    for path in template_paths:\n        relative = path.relative_to(template_dir)\n        key = self._normalise_key(relative.with_suffix(\"\").as_posix())\n        self._template_names[key] = relative.as_posix()\n\n    self.templates: dict[str, Template] = {}\n    self.default_code_engine = \"pygments\"\n    self.default_code_style = \"bw\"\n    self._pygments: PygmentsLatexHighlighter | None = None\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.template_names","title":"template_names  <code>property</code>","text":"<pre><code>template_names: set[str]\n</code></pre> <p>Return the set of available template identifiers.</p>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(method: str) -&gt; Callable[..., str]\n</code></pre> <p>Proxy calls to templates or custom handlers.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def __getattr__(self, method: str) -&gt; Callable[..., str]:\n    \"\"\"Proxy calls to templates or custom handlers.\"\"\"\n    mangled = f\"handle_{method}\"\n    try:\n        handler = object.__getattribute__(self, mangled)\n    except AttributeError:\n        handler = None\n    if handler is not None:\n        return handler  # type: ignore[return-value]\n\n    try:\n        template = self._get_template(method)\n    except KeyError:\n        raise AttributeError(f\"Object has no template for '{method}'\") from None\n\n    def render_template(*args: Any, **kwargs: Any) -&gt; str:\n        \"\"\"Render the template with optional positional shorthand.\"\"\"\n        if len(args) &gt; 1:\n            msg = f\"Expected at most 1 argument, got {len(args)}, use keyword arguments instead\"\n            raise ValueError(msg)\n        if args:\n            kwargs[\"text\"] = args[0]\n        return template.render(**kwargs)\n\n    return render_template\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.get_cover","title":"get_cover","text":"<pre><code>get_cover(name: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Render a named cover template populated with book metadata.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def get_cover(self, name: str, **kwargs: Any) -&gt; str:\n    \"\"\"Render a named cover template populated with book metadata.\"\"\"\n    template = self._get_template(f\"cover/{name}\")\n    return template.render(\n        title=self.config.title,  # type: ignore[attr-defined]\n        author=self.config.author,  # type: ignore[attr-defined]\n        subtitle=self.config.subtitle,  # type: ignore[attr-defined]\n        email=self.config.email,  # type: ignore[attr-defined]\n        year=self.config.year,  # type: ignore[attr-defined]\n        **self.config.cover.model_dump(),  # type: ignore[attr-defined]\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.handle_codeblock","title":"handle_codeblock","text":"<pre><code>handle_codeblock(\n    code: str,\n    language: str = \"text\",\n    filename: str | None = None,\n    lineno: bool = False,\n    highlight: Iterable[int] | None = None,\n    baselinestretch: float | None = None,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    **_: Any,\n) -&gt; str\n</code></pre> <p>Render code blocks with optional line numbers and highlights.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeblock(\n    self,\n    code: str,\n    language: str = \"text\",\n    filename: str | None = None,\n    lineno: bool = False,\n    highlight: Iterable[int] | None = None,\n    baselinestretch: float | None = None,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    **_: Any,\n) -&gt; str:\n    \"\"\"Render code blocks with optional line numbers and highlights.\"\"\"\n    highlight = list(highlight or [])\n    optimized_highlight = optimize_list(highlight)\n    normalized_engine = (engine or self.default_code_engine or \"pygments\").lower()\n    if normalized_engine not in {\"minted\", \"listings\", \"verbatim\", \"pygments\"}:\n        normalized_engine = \"pygments\"\n\n    if normalized_engine == \"pygments\":\n        style_name = str(self.default_code_style or \"bw\").strip() or \"bw\"\n        if self._pygments is None or self._pygments.style != style_name:\n            self._pygments = PygmentsLatexHighlighter(style=style_name)\n        latex_code, style_defs = self._pygments.render(\n            code,\n            language,\n            linenos=lineno,\n            highlight_lines=highlight,\n        )\n        if state is not None and style_defs:\n            state.pygments_styles.setdefault(self._pygments.style_key, style_defs)\n        return self._get_template(\"codeblock_pygments\").render(\n            code=latex_code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    if normalized_engine == \"listings\":\n        return self._get_template(\"codeblock_listings\").render(\n            code=code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    if normalized_engine == \"verbatim\":\n        return self._get_template(\"codeblock_verbatim\").render(\n            code=code,\n            language=language,\n            linenos=lineno,\n            filename=filename,\n            baselinestretch=baselinestretch,\n            highlight=optimized_highlight,\n        )\n\n    return self._get_template(\"codeblock\").render(\n        code=code,\n        language=language,\n        linenos=lineno,\n        filename=filename,\n        baselinestretch=baselinestretch,\n        highlight=optimized_highlight,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.handle_codeinline","title":"handle_codeinline","text":"<pre><code>handle_codeinline(\n    *,\n    language: str = \"text\",\n    text: str,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    delimiter: str | None = None,\n) -&gt; str\n</code></pre> <p>Render inline code with engine-specific highlighting.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeinline(\n    self,\n    *,\n    language: str = \"text\",\n    text: str,\n    engine: str | None = None,\n    state: DocumentState | None = None,\n    delimiter: str | None = None,\n) -&gt; str:\n    \"\"\"Render inline code with engine-specific highlighting.\"\"\"\n    normalized_engine = (engine or self.default_code_engine or \"pygments\").lower()\n    if normalized_engine == \"minted\":\n        delimiter = delimiter or \"|\"\n        return self._get_template(\"codeinline\").render(\n            language=language or \"text\",\n            text=text,\n            delimiter=delimiter,\n        )\n\n    if normalized_engine == \"pygments\":\n        style_name = str(self.default_code_style or \"bw\").strip() or \"bw\"\n        if self._pygments is None or self._pygments.style != style_name:\n            self._pygments = PygmentsLatexHighlighter(style=style_name)\n        latex_code, style_defs = self._pygments.render_inline(text, language)\n        if state is not None and style_defs:\n            state.pygments_styles.setdefault(self._pygments.style_key, style_defs)\n        return r\"{\\ttfamily \" + latex_code + \"}\"\n\n    # listings/verbatim fallback to plain typewriter\n    return self.handle_codeinlinett(text)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.handle_codeinlinett","title":"handle_codeinlinett","text":"<pre><code>handle_codeinlinett(text: str) -&gt; str\n</code></pre> <p>Render plain inline code inside \\texttt.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_codeinlinett(self, text: str) -&gt; str:\n    \"\"\"Render plain inline code inside \\\\texttt.\"\"\"\n    escaped = escape_latex_chars(text, legacy_accents=self.legacy_latex_accents)\n    escaped = escaped.replace(\"-\", \"-\\\\allowbreak{}\")\n    return self._get_template(\"codeinlinett\").render(text=escaped)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.handle_href","title":"handle_href","text":"<pre><code>handle_href(text: str, url: str) -&gt; str\n</code></pre> <p>Render \\href links with escaped URLs.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_href(self, text: str, url: str) -&gt; str:\n    \"\"\"Render \\\\href links with escaped URLs.\"\"\"\n    return self._get_template(\"href\").render(text=text, url=self._escape_url(url))\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.handle_regex","title":"handle_regex","text":"<pre><code>handle_regex(text: str, url: str) -&gt; str\n</code></pre> <p>Render regex helper links with escaped URLs.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def handle_regex(self, text: str, url: str) -&gt; str:\n    \"\"\"Render regex helper links with escaped URLs.\"\"\"\n    return self._get_template(\"regex\").render(text=text, url=self._escape_url(url))\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.normalise_key","title":"normalise_key  <code>classmethod</code>","text":"<pre><code>normalise_key(name: str) -&gt; str\n</code></pre> <p>Public wrapper for normalising template identifiers.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>@classmethod\ndef normalise_key(cls, name: str) -&gt; str:\n    \"\"\"Public wrapper for normalising template identifiers.\"\"\"\n    return cls._normalise_key(name)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.override_template","title":"override_template","text":"<pre><code>override_template(name: str, source: str | Path) -&gt; None\n</code></pre> <p>Override a built-in template snippet using an external payload.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def override_template(self, name: str, source: str | Path) -&gt; None:\n    \"\"\"Override a built-in template snippet using an external payload.\"\"\"\n    if isinstance(source, Path):\n        template_source = source.read_text(encoding=\"utf-8\")\n        template_name = source.as_posix()\n    else:\n        template_source = source\n        template_name = name\n\n    template = self.env.from_string(template_source)\n    template.name = template_name\n    normalised = self._normalise_key(name)\n    self.templates[normalised] = template\n    self._template_names[normalised] = template_name\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.svg","title":"svg","text":"<pre><code>svg(svg: str | Path) -&gt; str\n</code></pre> <p>Render an SVG image by converting it to PDF first.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def svg(self, svg: str | Path) -&gt; str:\n    \"\"\"Render an SVG image by converting it to PDF first.\"\"\"\n    from ..transformers import svg2pdf\n\n    pdfpath = svg2pdf(svg, self.output_path)  # type: ignore[attr-defined]\n    return f\"\\\\includegraphics[width=1em]{{{pdfpath}}}\"\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.LaTeXFormatter.url","title":"url","text":"<pre><code>url(text: str, url: str) -&gt; str\n</code></pre> <p>Render a URL, escaping special LATEX characters.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def url(self, text: str, url: str) -&gt; str:\n    \"\"\"Render a URL, escaping special LaTeX characters.\"\"\"\n    safe_url = self._escape_url(url)\n    return self._get_template(\"url\").render(text=text, url=safe_url)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.formatter.optimize_list","title":"optimize_list","text":"<pre><code>optimize_list(numbers: Iterable[int]) -&gt; list[str]\n</code></pre> <p>Merge consecutive integers into human-readable ranges.</p> Source code in <code>src/texsmith/adapters/latex/formatter.py</code> <pre><code>def optimize_list(numbers: Iterable[int]) -&gt; list[str]:\n    \"\"\"Merge consecutive integers into human-readable ranges.\"\"\"\n    values = sorted(numbers)\n    if not values:\n        return []\n\n    optimized: list[str] = []\n    start = end = values[0]\n\n    for num in values[1:]:\n        if num == end + 1:\n            end = num\n        else:\n            optimized.append(f\"{start}-{end}\" if start != end else str(start))\n            start = end = num\n\n    optimized.append(f\"{start}-{end}\" if start != end else str(start))\n    return optimized\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.renderer.LaTeXRenderer","title":"LaTeXRenderer","text":"<pre><code>LaTeXRenderer(\n    config: BookConfig | None = None,\n    formatter: LaTeXFormatter | None = None,\n    output_root: Path | str = Path(\"build\"),\n    parser: str = \"lxml\",\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n)\n</code></pre> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def __init__(\n    self,\n    config: BookConfig | None = None,\n    formatter: LaTeXFormatter | None = None,\n    output_root: Path | str = Path(\"build\"),\n    parser: str = \"lxml\",\n    copy_assets: bool = True,\n    convert_assets: bool = False,\n    hash_assets: bool = False,\n) -&gt; None:\n    self.config = config or BookConfig()\n    self.formatter = formatter or LaTeXFormatter()\n    self.parser_backend = parser\n    self.copy_assets = copy_assets\n    self.convert_assets = convert_assets\n    self.hash_assets = hash_assets\n\n    self.output_root = Path(output_root)\n    self.assets_root = (self.output_root / \"assets\").resolve()\n\n    self.assets = AssetRegistry(self.assets_root, copy_assets=self.copy_assets)\n\n    # Keep formatter in sync with runtime environment\n    self.formatter.config = self.config  # type: ignore[assignment]\n    self.formatter.output_path = self.assets_root  # type: ignore[assignment]\n    self.formatter.legacy_latex_accents = self.config.legacy_latex_accents\n\n    self.engine = RenderEngine()\n    self._register_builtin_handlers()\n    self._register_entry_point_handlers()\n    register_all_renderers(self)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.renderer.LaTeXRenderer.describe_registered_rules","title":"describe_registered_rules","text":"<pre><code>describe_registered_rules() -&gt; list[dict[str, object]]\n</code></pre> <p>Return detailed metadata about registered rules.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def describe_registered_rules(self) -&gt; list[dict[str, object]]:\n    \"\"\"Return detailed metadata about registered rules.\"\"\"\n    return self.engine.registry.describe()\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.renderer.LaTeXRenderer.iter_registered_rules","title":"iter_registered_rules","text":"<pre><code>iter_registered_rules() -&gt; Iterable[\n    tuple[RenderPhase, str]\n]\n</code></pre> <p>Expose currently registered rules for debugging/reporting.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def iter_registered_rules(self) -&gt; Iterable[tuple[RenderPhase, str]]:\n    \"\"\"Expose currently registered rules for debugging/reporting.\"\"\"\n    for phase in RenderPhase:\n        for rule in self.engine.registry.iter_phase(phase):\n            yield phase, rule.name\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.renderer.LaTeXRenderer.register","title":"register","text":"<pre><code>register(handler: Any) -&gt; None\n</code></pre> <p>Register additional handlers on demand.</p> <p>Arguments can be callables decorated with :func:<code>renders</code> or modules/classes exposing decorated attributes.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def register(self, handler: Any) -&gt; None:\n    \"\"\"Register additional handlers on demand.\n\n    Arguments can be callables decorated with :func:`renders` or modules/classes\n    exposing decorated attributes.\n    \"\"\"\n    definition = getattr(handler, \"__render_rule__\", None)\n    if definition is not None:\n        self.engine.register(handler)\n        return\n\n    self.engine.collect_from(handler)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.renderer.LaTeXRenderer.render","title":"render","text":"<pre><code>render(\n    html: str,\n    *,\n    runtime: Mapping[str, Any] | None = None,\n    state: DocumentState | None = None,\n    emitter: DiagnosticEmitter | None = None,\n) -&gt; str\n</code></pre> <p>Render an HTML fragment into LATEX.</p> Source code in <code>src/texsmith/adapters/latex/renderer.py</code> <pre><code>def render(\n    self,\n    html: str,\n    *,\n    runtime: Mapping[str, Any] | None = None,\n    state: DocumentState | None = None,\n    emitter: DiagnosticEmitter | None = None,\n) -&gt; str:\n    \"\"\"Render an HTML fragment into LaTeX.\"\"\"\n    active_emitter = emitter or NullEmitter()\n    try:\n        soup = BeautifulSoup(html, self.parser_backend)\n    except FeatureNotFound:\n        if self.parser_backend == \"html.parser\":\n            raise\n        # Fall back to the built-in parser when the preferred backend is missing.\n        from texsmith.core.conversion.debug import record_event\n\n        record_event(\n            active_emitter,\n            \"parser_fallback\",\n            {\"preferred\": self.parser_backend, \"fallback\": \"html.parser\"},\n        )\n        soup = BeautifulSoup(html, \"html.parser\")\n        self.parser_backend = \"html.parser\"\n    document_state = state or DocumentState()\n\n    context = RenderContext(\n        config=self.config,\n        formatter=self.formatter,\n        document=soup,\n        assets=self.assets,\n        state=document_state,\n    )\n\n    context.attach_runtime(\n        copy_assets=self.copy_assets,\n        convert_assets=self.convert_assets,\n        hash_assets=self.hash_assets,\n        emitter=active_emitter,\n    )\n    if runtime:\n        context.attach_runtime(**runtime)\n\n    try:\n        self.engine.run(soup, context)\n    except Exception as exc:  # pragma: no cover - defensive\n        raise LatexRenderingError(\"LaTeX rendering failed\") from exc\n\n    return self._collect_output(soup)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogParser","title":"LatexLogParser","text":"<pre><code>LatexLogParser()\n</code></pre> <p>Incrementally parse LATEX output into structured messages.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._current: LatexMessage | None = None\n    self._messages: list[LatexMessage] = []\n    self._depth: int = 0\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogParser.messages","title":"messages  <code>property</code>","text":"<pre><code>messages: Sequence[LatexMessage]\n</code></pre> <p>Return the messages accumulated so far.</p>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogParser.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; list[LatexMessage]\n</code></pre> <p>Flush any pending message.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def finalize(self) -&gt; list[LatexMessage]:\n    \"\"\"Flush any pending message.\"\"\"\n    return self._finalize_current()\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogParser.process_line","title":"process_line","text":"<pre><code>process_line(line: str) -&gt; list[LatexMessage]\n</code></pre> <p>Process a log line and return messages that have just completed.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def process_line(self, line: str) -&gt; list[LatexMessage]:\n    \"\"\"Process a log line and return messages that have just completed.\"\"\"\n    completed: list[LatexMessage] = []\n    segments = self._consume_structure(line)\n    if not segments:\n        return completed\n\n    for indent_level, payload in segments:\n        if not payload or self._should_ignore(payload):\n            continue\n\n        severity, summary = self._match_message(payload)\n        if severity is not None:\n            message_summary = summary if summary else payload\n            if (\n                severity is LatexMessageSeverity.ERROR\n                and message_summary in _ERROR_CONTINUATIONS\n                and self._current\n                and self._current.severity is LatexMessageSeverity.ERROR\n            ):\n                self._current.details.append(message_summary)\n                continue\n            completed.extend(self._finalize_current())\n            self._current = LatexMessage(\n                severity=severity,\n                summary=message_summary,\n                indent=indent_level,\n            )\n            continue\n\n        if self._current and self._is_detail_line(payload):\n            self._current.details.append(payload)\n            continue\n\n        if self._current and self._merge_path_continuation(payload):\n            continue\n\n        if self._current and self._merge_text_continuation(payload, indent_level):\n            continue\n\n        completed.extend(self._finalize_current())\n        self._current = LatexMessage(\n            severity=LatexMessageSeverity.INFO,\n            summary=payload,\n            indent=indent_level,\n        )\n\n    return completed\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogRenderer","title":"LatexLogRenderer","text":"<pre><code>LatexLogRenderer(console: Console)\n</code></pre> <p>Render structured LATEX messages to a Rich console.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def __init__(self, console: Console) -&gt; None:\n    self.console = console\n    self.messages: list[LatexMessage] = []\n    self._current_messages: list[LatexMessage] = []\n    self._pending: LatexMessage | None = None\n    self._pending_heading: bool = False\n    self._branch_stack: list[bool] = []\n    self._heading_open = False\n    self._heading_next_bold = False\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogRenderer.consume","title":"consume","text":"<pre><code>consume(message: LatexMessage) -&gt; None\n</code></pre> <p>Display a single message, queueing it for tree-aware formatting.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def consume(self, message: LatexMessage) -&gt; None:\n    \"\"\"Display a single message, queueing it for tree-aware formatting.\"\"\"\n    heading_for_message = False\n    heading_state = self._split_heading_line(message.summary)\n    if heading_state is not None:\n        kind, remainder = heading_state\n        if kind == \"rule\":\n            self._heading_open = not self._heading_open\n            self._heading_next_bold = self._heading_open\n            return\n        if remainder:\n            heading_for_message = True\n            message = replace(message, summary=remainder)\n            if not self._heading_open:\n                self._heading_open = True\n        self._heading_next_bold = False\n\n    if self._heading_next_bold:\n        heading_for_message = True\n        self._heading_next_bold = False\n\n    if self._is_run_boundary(message):\n        self._current_messages.clear()\n    self.messages.append(message)\n    self._current_messages.append(message)\n    next_indent = message.indent\n    self._emit_pending(next_indent)\n    self._pending = message\n    self._pending_heading = heading_for_message\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexLogRenderer.summarize","title":"summarize","text":"<pre><code>summarize() -&gt; None\n</code></pre> <p>Print a summary of processed messages grouped by severity.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def summarize(self) -&gt; None:\n    \"\"\"Print a summary of processed messages grouped by severity.\"\"\"\n    self._emit_pending(None)\n    warnings = sum(\n        1 for msg in self._current_messages if msg.severity is LatexMessageSeverity.WARNING\n    )\n    errors = sum(\n        1 for msg in self._current_messages if msg.severity is LatexMessageSeverity.ERROR\n    )\n    info = sum(1 for msg in self._current_messages if msg.severity is LatexMessageSeverity.INFO)\n    summary_parts = [\n        f\"errors: {errors}\",\n        f\"warnings: {warnings}\",\n    ]\n    if info:\n        summary_parts.append(f\"info: {info}\")\n    style = \"green\" if errors == 0 else \"bold red\"\n    self.console.print(Text(\"Summary \u2014 \" + \", \".join(summary_parts), style=style))\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexMessage","title":"LatexMessage  <code>dataclass</code>","text":"<pre><code>LatexMessage(\n    severity: LatexMessageSeverity,\n    summary: str,\n    details: list[str] = list(),\n    indent: int = 0,\n)\n</code></pre> <p>Structured LATEX message extracted from the build log.</p>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexMessageSeverity","title":"LatexMessageSeverity","text":"<p>               Bases: <code>Enum</code></p> <p>Classification severity extracted from LATEX output.</p>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.LatexStreamResult","title":"LatexStreamResult  <code>dataclass</code>","text":"<pre><code>LatexStreamResult(\n    returncode: int, messages: list[LatexMessage]\n)\n</code></pre> <p>Result of streaming LATEX engine output.</p>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.parse_latex_log","title":"parse_latex_log","text":"<pre><code>parse_latex_log(log_path: Path) -&gt; list[LatexMessage]\n</code></pre> <p>Parse a LATEX log file into structured messages.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def parse_latex_log(log_path: Path) -&gt; list[LatexMessage]:\n    \"\"\"Parse a LaTeX log file into structured messages.\"\"\"\n    if not log_path.exists():\n        return []\n    parser = LatexLogParser()\n    with log_path.open(\"r\", encoding=\"utf-8\", errors=\"replace\") as handle:\n        for line in handle:\n            parser.process_line(line)\n    parser.finalize()\n    return list(parser.messages)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.engines.latex.log.stream_latexmk_output","title":"stream_latexmk_output","text":"<pre><code>stream_latexmk_output(\n    command: Sequence[str],\n    *,\n    cwd: str,\n    env: Mapping[str, str],\n    console: Console,\n    verbosity: int = 0,\n) -&gt; LatexStreamResult\n</code></pre> <p>Execute a LATEX engine command and render output incrementally.</p> Source code in <code>src/texsmith/adapters/latex/engines/latex/log.py</code> <pre><code>def stream_latexmk_output(\n    command: Sequence[str],\n    *,\n    cwd: str,\n    env: Mapping[str, str],\n    console: Console,\n    verbosity: int = 0,\n) -&gt; LatexStreamResult:\n    \"\"\"Execute a LaTeX engine command and render output incrementally.\"\"\"\n    parser = LatexLogParser()\n    renderer = LatexLogRenderer(console)\n\n    with subprocess.Popen(\n        command,\n        cwd=cwd,\n        env=dict(env),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n        bufsize=1,\n        encoding=\"utf-8\",\n        errors=\"replace\",\n    ) as process:\n        selector = selectors.DefaultSelector()\n        if process.stdout:\n            selector.register(process.stdout, selectors.EVENT_READ)\n        if process.stderr:\n            selector.register(process.stderr, selectors.EVENT_READ)\n\n        while selector.get_map():\n            for key, _ in selector.select():\n                stream_obj = key.fileobj\n                if isinstance(stream_obj, int) or not hasattr(stream_obj, \"readline\"):\n                    selector.unregister(stream_obj)\n                    continue\n                stream = cast(TextIO, stream_obj)\n                chunk = stream.readline()\n                if chunk:\n                    for completed in parser.process_line(chunk):\n                        if _should_emit_message(completed, verbosity):\n                            renderer.consume(completed)\n                else:\n                    selector.unregister(stream)\n\n        for completed in parser.finalize():\n            if _should_emit_message(completed, verbosity):\n                renderer.consume(completed)\n\n        returncode = process.wait()\n\n    renderer.summarize()\n    return LatexStreamResult(returncode=returncode, messages=renderer.messages)\n</code></pre>"},{"location":"api/latex/#texsmith.adapters.latex.utils.escape_latex_chars","title":"escape_latex_chars","text":"<pre><code>escape_latex_chars(\n    text: str, *, legacy_accents: bool = False\n) -&gt; str\n</code></pre> <p>Escape LATEX special characters leveraging pylatexenc.</p> Source code in <code>src/texsmith/adapters/latex/utils.py</code> <pre><code>def escape_latex_chars(text: str, *, legacy_accents: bool = False) -&gt; str:\n    \"\"\"Escape LaTeX special characters leveraging pylatexenc.\"\"\"\n    if not text:\n        return text\n    parts: list[str] = []\n    buffer: list[str] = []\n\n    def _encode_chunk(chunk: str) -&gt; str:\n        escaped = \"\".join(_BASIC_LATEX_ESCAPE_MAP.get(char, char) for char in chunk)\n        if legacy_accents:\n            encoded = unicode_to_latex(escaped, non_ascii_only=True, unknown_char_warning=False)\n            return _wrap_latex_output(encoded)\n        return escaped\n\n    def _should_skip_encoding(char: str) -&gt; bool:\n        try:\n            name = unicodedata.name(char)\n        except ValueError:\n            return False\n        if \"SUPERSCRIPT\" in name or \"SUBSCRIPT\" in name:\n            return True\n        return \"MODIFIER LETTER\" in name and (\"SMALL\" in name or \"CAPITAL\" in name)\n\n    for char in text:\n        replacement = _COMMON_SYMBOL_MAP.get(char)\n        if replacement is not None:\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(replacement)\n            continue\n        if _should_skip_encoding(char):\n            if buffer:\n                parts.append(_encode_chunk(\"\".join(buffer)))\n                buffer.clear()\n            parts.append(char)\n        else:\n            buffer.append(char)\n\n    if buffer:\n        parts.append(_encode_chunk(\"\".join(buffer)))\n\n    return \"\".join(parts)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.BaseTemplate","title":"BaseTemplate","text":"<pre><code>BaseTemplate(root: Path)\n</code></pre> <p>Base class shared by template implementations.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def __init__(self, root: Path) -&gt; None:\n    self.root = root.resolve()\n    if not self.root.exists():\n        raise TemplateError(f\"Template root does not exist: {self.root}\")\n\n    manifest_path = _resolve_manifest_path(self.root)\n    self.manifest = TemplateManifest.load(manifest_path)\n    self.info = self.manifest.latex.template\n    self.environment = _build_environment(self.root)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.BaseTemplate.default_context","title":"default_context","text":"<pre><code>default_context() -&gt; dict[str, Any]\n</code></pre> <p>Return a shallow copy of the manifest default attributes.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def default_context(self) -&gt; dict[str, Any]:\n    \"\"\"Return a shallow copy of the manifest default attributes.\"\"\"\n    defaults = self.info.attribute_defaults()\n    defaults.update(self.info.emit_defaults())\n    return defaults\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.BaseTemplate.render_template","title":"render_template","text":"<pre><code>render_template(template_name: str, **context: Any) -&gt; str\n</code></pre> <p>Render a template using the configured Jinja environment.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def render_template(self, template_name: str, **context: Any) -&gt; str:\n    \"\"\"Render a template using the configured Jinja environment.\"\"\"\n    try:\n        template = self.environment.get_template(template_name)\n    except TemplateNotFound as exc:\n        raise TemplateError(\n            f\"Template entry '{template_name}' is missing in {self.root}\"\n        ) from exc\n    return template.render(context)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.ResolvedAsset","title":"ResolvedAsset  <code>dataclass</code>","text":"<pre><code>ResolvedAsset(\n    source: Path,\n    destination: Path,\n    template: bool = False,\n    encoding: str | None = None,\n    template_name: str | None = None,\n)\n</code></pre> <p>Resolved template asset ready to be materialised.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateAsset","title":"TemplateAsset","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of individual template assets.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateAttributeSpec","title":"TemplateAttributeSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>Typed attribute definition used to build template defaults.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateAttributeSpec.default_value","title":"default_value","text":"<pre><code>default_value() -&gt; Any\n</code></pre> <p>Return a deep copy of the attribute default.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def default_value(self) -&gt; Any:\n    \"\"\"Return a deep copy of the attribute default.\"\"\"\n    return copy.deepcopy(self._default_cache)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateBinding","title":"TemplateBinding  <code>dataclass</code>","text":"<pre><code>TemplateBinding(\n    runtime: TemplateRuntime | None,\n    instance: WrappableTemplate | None,\n    name: str | None,\n    engine: str | None,\n    requires_shell_escape: bool,\n    formatter_overrides: dict[str, Path],\n    slots: dict[str, TemplateSlot],\n    default_slot: str,\n    base_level: int | None,\n    required_partials: set[str] = set(),\n)\n</code></pre> <p>Binding between slot requests and a LATEX template.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateBinding.apply_formatter_overrides","title":"apply_formatter_overrides","text":"<pre><code>apply_formatter_overrides(\n    formatter: \"LaTeXFormatter\",\n) -&gt; None\n</code></pre> <p>Apply template-provided overrides to a formatter.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def apply_formatter_overrides(self, formatter: \"LaTeXFormatter\") -&gt; None:\n    \"\"\"Apply template-provided overrides to a formatter.\"\"\"\n    for key, override_path in self.formatter_overrides.items():\n        formatter.override_template(key, override_path)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateBinding.slot_levels","title":"slot_levels","text":"<pre><code>slot_levels(*, offset: int = 0) -&gt; dict[str, int]\n</code></pre> <p>Return the resolved base level for each slot.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def slot_levels(self, *, offset: int = 0) -&gt; dict[str, int]:\n    \"\"\"Return the resolved base level for each slot.\"\"\"\n    base = (self.base_level or 0) + offset\n    return {name: slot.resolve_level(base) for name, slot in self.slots.items()}\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateError","title":"TemplateError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when a LATEX template cannot be loaded or rendered.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo","title":"TemplateInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata describing the LATEX template payload.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo.attribute_defaults","title":"attribute_defaults","text":"<pre><code>attribute_defaults() -&gt; dict[str, Any]\n</code></pre> <p>Return a deep copy of template attribute defaults.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def attribute_defaults(self) -&gt; dict[str, Any]:\n    \"\"\"Return a deep copy of template attribute defaults.\"\"\"\n    return copy.deepcopy(self._attribute_defaults)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo.attribute_owners","title":"attribute_owners","text":"<pre><code>attribute_owners() -&gt; dict[str, str]\n</code></pre> <p>Return attribute ownership map (name -&gt; owner).</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def attribute_owners(self) -&gt; dict[str, str]:\n    \"\"\"Return attribute ownership map (name -&gt; owner).\"\"\"\n    return dict(self._attribute_owners)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo.emit_defaults","title":"emit_defaults","text":"<pre><code>emit_defaults() -&gt; dict[str, Any]\n</code></pre> <p>Return default attributes emitted by the template.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def emit_defaults(self) -&gt; dict[str, Any]:\n    \"\"\"Return default attributes emitted by the template.\"\"\"\n    return copy.deepcopy(self.emit)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo.resolve_attributes","title":"resolve_attributes","text":"<pre><code>resolve_attributes(\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Return defaults merged with overrides using the attribute specification.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_attributes(self, overrides: Mapping[str, Any] | None = None) -&gt; dict[str, Any]:\n    \"\"\"Return defaults merged with overrides using the attribute specification.\"\"\"\n    return self._attribute_resolver.merge(overrides)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateInfo.resolve_slots","title":"resolve_slots","text":"<pre><code>resolve_slots() -&gt; tuple[dict[str, TemplateSlot], str]\n</code></pre> <p>Return declared slots ensuring a single default sink exists.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_slots(self) -&gt; tuple[dict[str, TemplateSlot], str]:\n    \"\"\"Return declared slots ensuring a single default sink exists.\"\"\"\n    resolved = {\n        name: slot if isinstance(slot, TemplateSlot) else TemplateSlot.model_validate(slot)\n        for name, slot in self.slots.items()\n    }\n\n    if \"mainmatter\" not in resolved:\n        resolved[\"mainmatter\"] = TemplateSlot(default=True)\n\n    defaults = [name for name, slot in resolved.items() if slot.default]\n    if not defaults:\n        resolved[\"mainmatter\"] = resolved[\"mainmatter\"].model_copy(update={\"default\": True})\n        defaults = [\"mainmatter\"]\n    elif len(defaults) &gt; 1:\n        formatted = \", \".join(defaults)\n        raise TemplateError(f\"Multiple default slots declared: {formatted}\")\n\n    return resolved, defaults[0]\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateManifest","title":"TemplateManifest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured manifest describing a LATEX template.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateManifest.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(manifest_path: Path) -&gt; TemplateManifest\n</code></pre> <p>Load and validate a manifest from disk.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>@classmethod\ndef load(cls, manifest_path: Path) -&gt; TemplateManifest:\n    \"\"\"Load and validate a manifest from disk.\"\"\"\n    try:\n        content = tomllib.loads(manifest_path.read_text(encoding=\"utf-8\"))\n    except FileNotFoundError as exc:  # pragma: no cover - sanity check\n        raise TemplateError(f\"Template manifest is missing: {manifest_path}\") from exc\n    except OSError as exc:  # pragma: no cover - IO failure\n        raise TemplateError(f\"Failed to read template manifest: {exc}\") from exc\n    except tomllib.TOMLDecodeError as exc:\n        raise TemplateError(f\"Invalid template manifest: {exc}\") from exc\n\n    try:\n        return cls.model_validate(content)\n    except ValidationError as exc:\n        raise TemplateError(f\"Template manifest validation failed: {exc}\") from exc\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateRuntime","title":"TemplateRuntime  <code>dataclass</code>","text":"<pre><code>TemplateRuntime(\n    instance: WrappableTemplate,\n    name: str,\n    engine: str | None,\n    requires_shell_escape: bool,\n    slots: dict[str, TemplateSlot],\n    default_slot: str,\n    formatter_overrides: dict[str, Path],\n    base_level: int | None,\n    required_partials: set[str] = set(),\n    extras: dict[str, Any] = dict(),\n)\n</code></pre> <p>Resolved template metadata reused across conversions.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateSlot","title":"TemplateSlot","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration describing how content is injected into a template slot.</p>"},{"location":"api/latex/#texsmith.core.templates.TemplateSlot.resolve_level","title":"resolve_level","text":"<pre><code>resolve_level(fallback: int) -&gt; int\n</code></pre> <p>Return the base level applied to rendered headings for this slot.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_level(self, fallback: int) -&gt; int:\n    \"\"\"Return the base level applied to rendered headings for this slot.\"\"\"\n    base = fallback\n    if self.base_level is not None:\n        base = self.base_level\n    elif self.depth is not None:\n        base = fallback + LATEX_HEADING_LEVELS[self.depth]\n    return base + self.offset\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.TemplateWrapResult","title":"TemplateWrapResult  <code>dataclass</code>","text":"<pre><code>TemplateWrapResult(\n    latex_output: str,\n    template_context: dict[str, Any],\n    output_path: Path | None,\n    asset_paths: list[Path] = list(),\n    asset_pairs: list[tuple[Path, Path]] = list(),\n    rendered_fragments: list[str] = list(),\n)\n</code></pre> <p>Result artefacts produced after wrapping LATEX with a template.</p>"},{"location":"api/latex/#texsmith.core.templates.WrappableTemplate","title":"WrappableTemplate","text":"<pre><code>WrappableTemplate(root: Path)\n</code></pre> <p>               Bases: <code>BaseTemplate</code></p> <p>Template capable of wrapping a generated LATEX fragment.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def __init__(self, root: Path) -&gt; None:\n    self.root = root.resolve()\n    if not self.root.exists():\n        raise TemplateError(f\"Template root does not exist: {self.root}\")\n\n    manifest_path = _resolve_manifest_path(self.root)\n    self.manifest = TemplateManifest.load(manifest_path)\n    self.info = self.manifest.latex.template\n    self.environment = _build_environment(self.root)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.WrappableTemplate.iter_assets","title":"iter_assets","text":"<pre><code>iter_assets() -&gt; Iterable['ResolvedAsset']\n</code></pre> <p>Yield declared template assets.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def iter_assets(self) -&gt; Iterable[\"ResolvedAsset\"]:\n    \"\"\"Yield declared template assets.\"\"\"\n    for destination, asset in self.info.assets.items():\n        dest_path = Path(destination)\n        if dest_path.is_absolute():\n            raise TemplateError(\n                f\"Template asset destination must be relative, got '{destination}'.\"\n            )\n\n        source_path = Path(asset.source)\n        if not source_path.is_absolute():\n            source_path = (self.root / source_path).resolve()\n        if not source_path.exists():\n            raise TemplateError(\n                f\"Declared template asset '{asset.source}' is missing under {self.root}.\"\n            )\n\n        template_name: str | None = None\n        if asset.template:\n            if source_path.is_dir():\n                raise TemplateError(\n                    f\"Templated assets must reference files, got directory '{asset.source}'.\"\n                )\n            try:\n                relative = source_path.relative_to(self.root)\n            except ValueError as exc:  # pragma: no cover - defensive\n                common_dir = self.root.parent / \"common\"\n                try:\n                    relative = source_path.relative_to(common_dir)\n                except ValueError as nested_exc:\n                    raise TemplateError(\n                        f\"Templated asset '{asset.source}' must live inside the template root \"\n                        \"or the shared 'common' directory.\"\n                    ) from nested_exc\n            template_name = relative.as_posix()\n\n        yield ResolvedAsset(\n            source=source_path,\n            destination=dest_path,\n            template=asset.template,\n            encoding=asset.encoding,\n            template_name=template_name,\n        )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.WrappableTemplate.iter_formatter_overrides","title":"iter_formatter_overrides","text":"<pre><code>iter_formatter_overrides() -&gt; Iterable[tuple[str, Path]]\n</code></pre> <p>Yield formatter override templates declared by the manifest.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def iter_formatter_overrides(self) -&gt; Iterable[tuple[str, Path]]:\n    \"\"\"Yield formatter override templates declared by the manifest.\"\"\"\n    if not self.info.override:\n        return ()\n\n    search_roots = [\n        self.root / \"overrides\",\n        self.root / \"template\" / \"overrides\",\n        self.root,\n        self.root.parent / \"overrides\",\n    ]\n\n    seen: set[str] = set()\n    overrides: list[tuple[str, Path]] = []\n\n    for entry in self.info.override:\n        if not isinstance(entry, str):\n            raise TemplateError(\"Formatter override entries must be provided as string paths.\")\n        candidate = entry.strip()\n        if not candidate:\n            continue\n\n        relative_path = Path(candidate)\n        if relative_path.is_absolute() or any(part == \"..\" for part in relative_path.parts):\n            raise TemplateError(\n                f\"Formatter override '{entry}' must be a relative path without '..'.\"\n            )\n\n        resolved_path: Path | None = None\n        for root in search_roots:\n            if not root.exists():\n                continue\n            probe = (root / relative_path).resolve()\n            if probe.exists():\n                resolved_path = probe\n                break\n\n        if resolved_path is None:\n            raise TemplateError(f\"Formatter override '{entry}' is missing under '{self.root}'.\")\n\n        key = relative_path.with_suffix(\"\").as_posix().replace(\"/\", \"_\")\n        if key in seen:\n            continue\n        seen.add(key)\n        overrides.append((key, resolved_path))\n\n    return overrides\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.WrappableTemplate.prepare_context","title":"prepare_context","text":"<pre><code>prepare_context(\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build the rendering context shared by the template and its assets.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def prepare_context(\n    self,\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Build the rendering context shared by the template and its assets.\"\"\"\n    attribute_context = self.info.resolve_attributes(overrides)\n    context = dict(attribute_context)\n    for key, value in self.info.emit_defaults().items():\n        context.setdefault(key, value)\n    if overrides:\n        for key, value in overrides.items():\n            if key in context and key not in self.info.emit:\n                continue\n            context[key] = value\n\n    context.setdefault(\"frontmatter\", \"\")\n    context.setdefault(\"backmatter\", \"\")\n    context.setdefault(\"index_entries\", False)\n    context.setdefault(\"has_index\", False)\n    context.setdefault(\"index_terms\", [])\n    context.setdefault(\"index_registry\", [])\n    context.setdefault(\"index_engine\", \"auto\")\n    context.setdefault(\"acronyms\", {})\n    context.setdefault(\"citations\", [])\n    context.setdefault(\"bibliography_entries\", {})\n    context.setdefault(\"bibliography_resource\", None)\n\n    slots, default_slot = self.info.resolve_slots()\n    for name in slots:\n        context.setdefault(name, \"\")\n\n    if default_slot == \"mainmatter\":\n        context[\"mainmatter\"] = latex_body\n    else:\n        context.setdefault(\"mainmatter\", \"\")\n        context[default_slot] = latex_body\n\n    return context\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.WrappableTemplate.wrap_document","title":"wrap_document","text":"<pre><code>wrap_document(\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n    context: Mapping[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Render the template entry point using the provided LATEX payload.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def wrap_document(\n    self,\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n    context: Mapping[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Render the template entry point using the provided LaTeX payload.\"\"\"\n    if context is None:\n        context = self.prepare_context(latex_body, overrides=overrides)\n    else:\n        context = dict(context)\n        context.setdefault(\"frontmatter\", \"\")\n        context.setdefault(\"backmatter\", \"\")\n        slots, default_slot = self.info.resolve_slots()\n        for name in slots:\n            context.setdefault(name, \"\")\n        if default_slot == \"mainmatter\":\n            context[\"mainmatter\"] = latex_body\n        else:\n            context.setdefault(\"mainmatter\", \"\")\n            context[default_slot] = latex_body\n\n    engine = str(context.get(\"index_engine\") or \"\").strip().lower()\n    if not engine or engine == \"auto\":\n        context[\"index_engine\"] = _detect_index_engine()\n    else:\n        context[\"index_engine\"] = engine\n\n    return self.render_template(self.info.entrypoint, **context)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.build_template_overrides","title":"build_template_overrides","text":"<pre><code>build_template_overrides(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build template overrides from front matter while preserving metadata.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def build_template_overrides(front_matter: Mapping[str, Any] | None) -&gt; dict[str, Any]:\n    \"\"\"Build template overrides from front matter while preserving metadata.\"\"\"\n    if not front_matter or not isinstance(front_matter, Mapping):\n        return {}\n\n    overrides = dict(front_matter)\n    press_section = overrides.get(\"press\")\n    if isinstance(press_section, Mapping):\n        overrides[\"press\"] = dict(press_section)\n\n    fragments = overrides.get(\"fragments\")\n    if fragments is None and isinstance(press_section, Mapping):\n        fragments = press_section.get(\"fragments\")\n    if isinstance(fragments, list):\n        overrides[\"fragments\"] = list(fragments)\n\n    callouts_section = overrides.get(\"callouts\")\n    if callouts_section is None and isinstance(press_section, Mapping):\n        callouts_section = press_section.get(\"callouts\")\n    if isinstance(callouts_section, Mapping):\n        overrides[\"callouts\"] = dict(callouts_section)\n\n    callouts_style = overrides.get(\"callouts_style\")\n    if callouts_style is None and isinstance(press_section, Mapping):\n        callouts_style = press_section.get(\"callouts_style\")\n    if callouts_style is not None:\n        overrides[\"callout_style\"] = callouts_style\n\n    base_override = overrides.get(\"base_level\")\n    if base_override is None and isinstance(press_section, Mapping):\n        base_override = press_section.get(\"base_level\")\n    if base_override is not None:\n        try:\n            overrides[\"base_level\"] = coerce_base_level(base_override)\n        except TemplateError:\n            overrides[\"base_level\"] = base_override\n\n    return overrides\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.coerce_base_level","title":"coerce_base_level","text":"<pre><code>coerce_base_level(\n    value: Any, *, allow_none: bool = True\n) -&gt; int | None\n</code></pre> <p>Normalise base-level metadata to an integer or <code>None</code>.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def coerce_base_level(value: Any, *, allow_none: bool = True) -&gt; int | None:\n    \"\"\"Normalise base-level metadata to an integer or ``None``.\"\"\"\n    if value is None:\n        if allow_none:\n            return None\n        raise TemplateError(\"Base level value is missing.\")\n\n    if isinstance(value, bool):\n        raise TemplateError(\"Base level must be an integer, booleans are not supported.\")\n\n    if isinstance(value, (int, float)):\n        return int(value)\n\n    if isinstance(value, str):\n        candidate = value.strip().lower()\n        if not candidate:\n            if allow_none:\n                return None\n            raise TemplateError(\"Base level value cannot be empty.\")\n        alias_map = {\n            \"part\": -1,\n            \"chapter\": 0,\n            \"section\": 1,\n            \"subsection\": 2,\n        }\n        if candidate in alias_map:\n            return alias_map[candidate]\n        try:\n            return int(candidate)\n        except ValueError as exc:  # pragma: no cover - defensive\n            raise TemplateError(\n                f\"Invalid base level '{value}'. Expected an integer value or one of \"\n                f\"{', '.join(alias_map)}.\"\n            ) from exc\n\n    raise TemplateError(\n        f\"Base level should be provided as an integer value, got type '{type(value).__name__}'.\"\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.copy_template_assets","title":"copy_template_assets","text":"<pre><code>copy_template_assets(\n    template: WrappableTemplate,\n    output_dir: Path,\n    *,\n    context: Mapping[str, Any] | None = None,\n    overrides: Mapping[str, Any] | None = None,\n    assets: Iterable[\"ResolvedAsset\"] | None = None,\n) -&gt; list[Path]\n</code></pre> <p>Copy the template declared assets into the selected output directory.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def copy_template_assets(\n    template: WrappableTemplate,\n    output_dir: Path,\n    *,\n    context: Mapping[str, Any] | None = None,\n    overrides: Mapping[str, Any] | None = None,\n    assets: Iterable[\"ResolvedAsset\"] | None = None,\n) -&gt; list[Path]:\n    \"\"\"Copy the template declared assets into the selected output directory.\"\"\"\n    output_dir = Path(output_dir).resolve()\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    if context is None:\n        render_context = template.prepare_context(\"\", overrides=overrides)\n    else:\n        render_context = dict(context)\n\n    written: list[Path] = []\n    asset_entries = list(assets) if assets is not None else list(template.iter_assets())\n    for asset in asset_entries:\n        destination_path = (output_dir / asset.destination).resolve()\n\n        if asset.template:\n            if asset.template_name is None:  # pragma: no cover - defensive\n                raise TemplateError(\n                    f\"Templated asset '{asset.source}' is missing template metadata.\"\n                )\n            destination_path.parent.mkdir(parents=True, exist_ok=True)\n            rendered = template.render_template(asset.template_name, **render_context)\n            destination_path.write_text(\n                rendered,\n                encoding=asset.encoding or \"utf-8\",\n            )\n        elif asset.source.is_dir():\n            shutil.copytree(asset.source, destination_path, dirs_exist_ok=True)\n        else:\n            destination_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy2(asset.source, destination_path)\n\n        written.append(destination_path)\n\n    return written\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.discover_templates","title":"discover_templates","text":"<pre><code>discover_templates() -&gt; list[dict[str, str]]\n</code></pre> <p>Return available templates in discovery order.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def discover_templates() -&gt; list[dict[str, str]]:\n    \"\"\"Return available templates in discovery order.\"\"\"\n    entries: list[dict[str, str]] = []\n\n    def _record(origin: str, name: str, root: Path) -&gt; None:\n        entries.append({\"name\": name, \"origin\": origin, \"root\": str(root.resolve())})\n\n    for slug in iter_builtin_templates():\n        try:\n            template = load_builtin_template(slug)\n        except TemplateError:\n            continue\n        if template is not None:\n            _record(\"builtin\", slug, template.root)\n\n    try:\n        for dist in metadata.distributions():\n            name = dist.metadata.get(\"Name\", \"\")\n            if not name.lower().startswith(\"texsmith-template-\"):\n                continue\n            slug = name[len(\"texsmith-template-\") :]\n            root = _resolve_packaged_template_root(slug)\n            if root is None:\n                continue\n            _record(\"package\", slug, root)\n    except Exception:\n        pass\n\n    seen_locals: set[str] = set()\n    for candidate in _iter_local_candidates(\"\"):\n        if not _looks_like_template_root(candidate):\n            continue\n        key = str(candidate.resolve())\n        if key in seen_locals:\n            continue\n        seen_locals.add(key)\n        _record(\"local\", candidate.name, candidate)\n\n    home_root = get_user_dir().data_dir(\"templates\", create=False)\n    if home_root.exists():\n        for child in sorted(home_root.iterdir()):\n            if child.is_dir() and _looks_like_template_root(child):\n                _record(\"home\", child.name, child)\n\n    return sorted(entries, key=lambda entry: (entry[\"origin\"], entry[\"name\"]))\n\n    for candidate in _iter_local_candidates(\"*placeholder*\"):\n        pass\n\n    local_candidates: list[Path] = []\n    for slug in set():\n        pass\n\n    for candidate in _iter_local_candidates(\"*placeholder*\"):\n        pass\n\n    def _record(origin: str, name: str, root: Path) -&gt; None:\n        key = (name, str(root))\n        if key in seen_paths:\n            return\n        seen_paths.add(key)\n        entries.append({\"name\": name, \"origin\": origin, \"root\": str(root)})\n\n    # Re-run local with concrete names.\n    visited: set[str] = set()\n    cwd = Path.cwd().resolve()\n    for candidate in _iter_local_candidates(\"\"):\n        if _looks_like_template_root(candidate):\n            _record(\"local\", candidate.name, candidate)\n\n    home_root = get_user_dir().data_dir(\"templates\", create=False)\n    if home_root.exists():\n        for child in home_root.iterdir():\n            if child.is_dir() and _looks_like_template_root(child):\n                _record(\"home\", child.name, child)\n\n    return sorted(entries, key=lambda entry: (entry[\"origin\"], entry[\"name\"]))\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.extract_base_level_override","title":"extract_base_level_override","text":"<pre><code>extract_base_level_override(\n    overrides: Mapping[str, Any] | None,\n) -&gt; Any\n</code></pre> <p>Extract a base level override from template metadata overrides.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def extract_base_level_override(overrides: Mapping[str, Any] | None) -&gt; Any:\n    \"\"\"Extract a base level override from template metadata overrides.\"\"\"\n    if not overrides:\n        return None\n\n    press_section = overrides.get(\"press\")\n    direct_candidate = overrides.get(\"base_level\")\n    if direct_candidate is not None:\n        return direct_candidate\n    if isinstance(press_section, Mapping):\n        return press_section.get(\"base_level\")\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.extract_language_from_front_matter","title":"extract_language_from_front_matter","text":"<pre><code>extract_language_from_front_matter(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str | None\n</code></pre> <p>Inspect front matter for language hints.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def extract_language_from_front_matter(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str | None:\n    \"\"\"Inspect front matter for language hints.\"\"\"\n    if not isinstance(front_matter, Mapping):\n        return None\n\n    for key in (\"language\", \"lang\"):\n        value = front_matter.get(key)\n        if isinstance(value, str):\n            stripped = value.strip()\n            if stripped:\n                return stripped\n\n    press_entry = front_matter.get(\"press\")\n    if isinstance(press_entry, Mapping):\n        for key in (\"language\", \"lang\"):\n            value = press_entry.get(key)\n            if isinstance(value, str):\n                stripped = value.strip()\n                if stripped:\n                    return stripped\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.load_template","title":"load_template","text":"<pre><code>load_template(identifier: str) -&gt; WrappableTemplate\n</code></pre> <p>Load a template selected by name or filesystem path.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def load_template(identifier: str) -&gt; WrappableTemplate:\n    \"\"\"Load a template selected by name or filesystem path.\"\"\"\n    path_candidate = Path(identifier).expanduser()\n    looks_like_path = (\n        path_candidate.is_absolute()\n        or \"/\" in identifier\n        or \"\\\\\" in identifier\n        or identifier.startswith(\".\")\n    )\n    if looks_like_path and path_candidate.exists():\n        return _load_path_template(path_candidate)\n\n    slug = _slug_from_identifier(identifier)\n\n    builtin = load_builtin_template(identifier)\n    if builtin is not None:\n        return builtin\n\n    packaged_root = _resolve_packaged_template_root(slug)\n    if packaged_root is not None:\n        return _load_path_template(packaged_root)\n\n    for candidate in _iter_local_candidates(slug):\n        if _looks_like_template_root(candidate):\n            return _load_path_template(candidate)\n\n    home_candidate = _home_template_candidate(slug)\n    if home_candidate is not None and _looks_like_template_root(home_candidate):\n        return _load_path_template(home_candidate)\n\n    raise TemplateError(\n        f\"Unable to load template '{identifier}'. Provide a valid path or \"\n        \"install a package exposing a 'texsmith.templates' entry point.\"\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.load_template_runtime","title":"load_template_runtime","text":"<pre><code>load_template_runtime(template: str) -&gt; TemplateRuntime\n</code></pre> <p>Resolve template metadata for repeated conversions.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def load_template_runtime(template: str) -&gt; TemplateRuntime:\n    \"\"\"Resolve template metadata for repeated conversions.\"\"\"\n    template_instance = load_template(template)\n\n    template_base = coerce_base_level(\n        template_instance.info.get_attribute_default(\"base_level\"),\n    )\n\n    slots, default_slot = template_instance.info.resolve_slots()\n    formatter_overrides = dict(template_instance.iter_formatter_overrides())\n    extras_payload = getattr(template_instance, \"extras\", {}) or {}\n    extras = {key: value for key, value in extras_payload.items()}\n    declared_fragments = (\n        list(template_instance.info.fragments) if template_instance.info.fragments is not None else None\n    )\n    extras.setdefault(\n        \"fragments\",\n        declared_fragments if declared_fragments is not None else [],\n    )\n\n    return TemplateRuntime(\n        instance=template_instance,\n        name=template_instance.info.name,\n        engine=template_instance.info.engine,\n        requires_shell_escape=bool(template_instance.info.shell_escape),\n        slots=slots,\n        default_slot=default_slot,\n        formatter_overrides=formatter_overrides,\n        base_level=template_base,\n        required_partials=set(template_instance.info.required_partials or []),\n        extras=extras,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.normalise_template_language","title":"normalise_template_language","text":"<pre><code>normalise_template_language(\n    value: str | None,\n) -&gt; str | None\n</code></pre> <p>Normalise language codes and map them through babel aliases when available.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def normalise_template_language(value: str | None) -&gt; str | None:\n    \"\"\"Normalise language codes and map them through babel aliases when available.\"\"\"\n    if value is None:\n        return None\n\n    stripped = value.strip()\n    if not stripped:\n        return None\n\n    lowered = stripped.lower().replace(\"_\", \"-\")\n    alias = _BABEL_LANGUAGE_ALIASES.get(lowered)\n    if alias:\n        return alias\n\n    primary = lowered.split(\"-\", 1)[0]\n    alias = _BABEL_LANGUAGE_ALIASES.get(primary)\n    if alias:\n        return alias\n\n    if lowered.isalpha():\n        return lowered\n\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.resolve_template_binding","title":"resolve_template_binding","text":"<pre><code>resolve_template_binding(\n    *,\n    template: str | None,\n    template_runtime: TemplateRuntime | None,\n    template_overrides: Mapping[str, Any],\n    slot_requests: Mapping[str, str],\n    warn: Callable[[str], None] | None = None,\n) -&gt; tuple[TemplateBinding, dict[str, str]]\n</code></pre> <p>Resolve template runtime metadata and apply slot overrides.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def resolve_template_binding(\n    *,\n    template: str | None,\n    template_runtime: TemplateRuntime | None,\n    template_overrides: Mapping[str, Any],\n    slot_requests: Mapping[str, str],\n    warn: Callable[[str], None] | None = None,\n) -&gt; tuple[TemplateBinding, dict[str, str]]:\n    \"\"\"Resolve template runtime metadata and apply slot overrides.\"\"\"\n    runtime = template_runtime\n    if runtime is None and template:\n        runtime = load_template_runtime(template)\n\n    if runtime is not None:\n        # Adjust base level for book parts when requested via overrides.\n        binding_base_level = runtime.base_level\n        part_flag = None\n        press_section = template_overrides.get(\"press\")\n        if isinstance(template_overrides.get(\"part\"), bool):\n            part_flag = template_overrides.get(\"part\")\n        elif isinstance(press_section, Mapping) and isinstance(press_section.get(\"part\"), bool):\n            part_flag = press_section.get(\"part\")\n        if part_flag and runtime.name == \"book\":\n            binding_base_level = coerce_base_level(\"part\")\n\n        binding = TemplateBinding(\n            runtime=runtime,\n            instance=runtime.instance,\n            name=runtime.name,\n            engine=runtime.engine,\n            requires_shell_escape=runtime.requires_shell_escape,\n            formatter_overrides=dict(runtime.formatter_overrides),\n            slots=runtime.slots,\n            default_slot=runtime.default_slot,\n            base_level=binding_base_level,\n            required_partials=set(runtime.required_partials),\n        )\n    else:\n        binding = TemplateBinding(\n            runtime=None,\n            instance=None,\n            name=None,\n            engine=None,\n            requires_shell_escape=False,\n            formatter_overrides={},\n            slots={\"mainmatter\": TemplateSlot(default=True)},\n            default_slot=\"mainmatter\",\n            base_level=None,\n            required_partials=set(),\n        )\n\n    base_override = coerce_base_level(extract_base_level_override(template_overrides))\n    if base_override is not None:\n        binding.base_level = base_override\n\n    filtered: dict[str, str] = {}\n    for slot_name, selector in slot_requests.items():\n        if slot_name not in binding.slots:\n            if warn is not None:\n                template_hint = f\"template '{binding.name}'\" if binding.name else \"the template\"\n                warn(\n                    f\"slot '{slot_name}' is not defined by {template_hint}; \"\n                    f\"content will remain in '{binding.default_slot}'.\"\n                )\n            continue\n        if binding.runtime is None:\n            if warn is not None:\n                warn(f\"slot '{slot_name}' was requested but no template is selected; ignoring.\")\n            continue\n        filtered[slot_name] = selector\n\n    return binding, filtered\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.resolve_template_language","title":"resolve_template_language","text":"<pre><code>resolve_template_language(\n    explicit: str | None,\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str\n</code></pre> <p>Resolve the effective template language from CLI and front matter inputs.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def resolve_template_language(\n    explicit: str | None,\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str:\n    \"\"\"Resolve the effective template language from CLI and front matter inputs.\"\"\"\n    candidates = (\n        normalise_template_language(explicit),\n        normalise_template_language(extract_language_from_front_matter(front_matter)),\n    )\n\n    for candidate in candidates:\n        if candidate:\n            return candidate\n\n    return DEFAULT_TEMPLATE_LANGUAGE\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.wrap_template_document","title":"wrap_template_document","text":"<pre><code>wrap_template_document(\n    *,\n    template: WrappableTemplate,\n    default_slot: str,\n    slot_outputs: Mapping[str, str],\n    slot_output_overrides: Mapping[str, str] | None = None,\n    document_state: DocumentState,\n    template_overrides: Mapping[str, Any] | None,\n    output_dir: Path,\n    copy_assets: bool = True,\n    output_name: str | None = None,\n    bibliography_path: Path | None = None,\n    emitter: DiagnosticEmitter | None = None,\n    fragments: list[str] | None = None,\n    template_runtime: TemplateRuntime | None = None,\n) -&gt; TemplateWrapResult\n</code></pre> <p>Wrap LATEX content using a template and optional asset copying.</p> Source code in <code>src/texsmith/core/templates/wrapper.py</code> <pre><code>def wrap_template_document(\n    *,\n    template: WrappableTemplate,\n    default_slot: str,\n    slot_outputs: Mapping[str, str],\n    slot_output_overrides: Mapping[str, str] | None = None,\n    document_state: DocumentState,\n    template_overrides: Mapping[str, Any] | None,\n    output_dir: Path,\n    copy_assets: bool = True,\n    output_name: str | None = None,\n    bibliography_path: Path | None = None,\n    emitter: DiagnosticEmitter | None = None,\n    fragments: list[str] | None = None,\n    template_runtime: TemplateRuntime | None = None,\n) -&gt; TemplateWrapResult:\n    \"\"\"Wrap LaTeX content using a template and optional asset copying.\"\"\"\n    output_dir = Path(output_dir).resolve()\n    resolved_slots = {name: value for name, value in slot_outputs.items()}\n    override_slots = (\n        {name: value for name, value in slot_output_overrides.items()}\n        if slot_output_overrides\n        else None\n    )\n    def _process_slot(value: Any) -&gt; Any:\n        return value\n\n    main_slot_content = _process_slot(resolved_slots.get(default_slot, \"\"))\n    resolved_slots[default_slot] = main_slot_content\n    resolved_slots.setdefault(default_slot, main_slot_content)\n    processed_override_slots: dict[str, Any] | None = None\n    if override_slots is not None:\n        processed_override_slots = {\n            name: _process_slot(value) for name, value in override_slots.items()\n        }\n        processed_override_slots.setdefault(\n            default_slot, resolved_slots.get(default_slot, \"\")\n        )\n\n    overrides_payload = dict(template_overrides) if template_overrides else None\n    source_dir = None\n    overrides_press = overrides_payload.get(\"press\") if overrides_payload else None\n    if isinstance(overrides_payload, Mapping):\n        raw_source_dir = overrides_payload.get(\"_source_dir\") or overrides_payload.get(\"source_dir\")\n        if isinstance(raw_source_dir, (str, Path)) and str(raw_source_dir):\n            source_dir = Path(raw_source_dir)\n    if source_dir is None and isinstance(overrides_press, Mapping):\n        source_dir_raw = overrides_press.get(\"_source_dir\") or overrides_press.get(\"source_dir\")\n        if source_dir_raw:\n            source_dir = Path(source_dir_raw)\n    fragment_names = list(fragments or [])\n    if not fragment_names:\n        if template_runtime is not None:\n            fragment_names = list(template_runtime.extras.get(\"fragments\") or [])\n        else:\n            manifest_fragments = getattr(template.info, \"fragments\", None)\n            fragment_names = list(manifest_fragments or [])\n\n    template_context = template.prepare_context(\n        main_slot_content,\n        overrides=overrides_payload,\n    )\n    engine = str(template_context.get(\"index_engine\") or \"\").strip().lower()\n    if not engine or engine == \"auto\":\n        template_context[\"index_engine\"] = _detect_index_engine()\n    else:\n        template_context[\"index_engine\"] = engine\n    if isinstance(overrides_press, Mapping):\n        template_context.setdefault(\"press\", overrides_press)\n    root_name: str | None = None\n    if output_name:\n        root_name = Path(output_name).stem\n    if root_name:\n        template_context.setdefault(\"root_filename\", root_name)\n\n    for slot_name, raw_content in resolved_slots.items():\n        if slot_name == default_slot:\n            continue\n        processed_content = _process_slot(raw_content)\n        resolved_slots[slot_name] = processed_content\n        template_context[slot_name] = processed_content\n\n    template_context[\"index_entries\"] = document_state.has_index_entries\n    index_terms = list(dict.fromkeys(getattr(document_state, \"index_entries\", [])))\n    template_context[\"has_index\"] = bool(index_terms)\n    template_context[\"index_terms\"] = [tuple(term) for term in index_terms]\n\n    registry_entries = index_terms\n    try:  # pragma: no cover - optional dependency\n        from texsmith.index import get_registry\n    except ModuleNotFoundError:\n        template_context[\"index_registry\"] = [tuple(term) for term in registry_entries]\n    else:\n        snapshot = sorted(get_registry().snapshot())\n        template_context[\"index_registry\"] = [tuple(term) for term in snapshot]\n    template_context[\"acronyms\"] = document_state.acronyms.copy()\n    template_context[\"citations\"] = list(document_state.citations)\n    template_context[\"bibliography_entries\"] = document_state.bibliography\n\n    fragment_attributes: dict[str, Any] = {}\n    if fragment_names:\n        fragment_attributes = inject_fragment_attributes(\n            fragment_names,\n            context=template_context,\n            overrides=overrides_payload,\n            source_dir=source_dir,\n            declared_attribute_owners=(\n                template.info.attribute_owners() if hasattr(template, \"info\") else {}\n            ),\n        )\n\n    code_section = template_context.get(\"code\")\n    code_engine = None\n    code_style = \"bw\"\n    if isinstance(code_section, Mapping):\n        raw_engine = code_section.get(\"engine\")\n        code_engine = raw_engine if isinstance(raw_engine, str) else None\n        raw_style = code_section.get(\"style\")\n        if isinstance(raw_style, str) and raw_style.strip():\n            code_style = raw_style.strip()\n    elif isinstance(code_section, str):\n        code_engine = code_section\n    code_engine = (code_engine or \"pygments\").strip().lower()\n    template_context[\"code_engine\"] = code_engine or \"pygments\"\n    template_context.setdefault(\"code_style\", code_style)\n    if \"code\" not in template_context:\n        template_context[\"code\"] = {\n            \"engine\": template_context[\"code_engine\"],\n            \"style\": template_context[\"code_style\"],\n        }\n    elif isinstance(template_context[\"code\"], dict):\n        template_context[\"code\"].setdefault(\"style\", template_context[\"code_style\"])\n    if code_engine == \"pygments\" and getattr(document_state, \"pygments_styles\", {}):\n        styles = getattr(document_state, \"pygments_styles\", {})\n        template_context[\"pygments_style_defs\"] = \"\\n\".join(styles.values())\n\n    template_context[\"requires_shell_escape\"] = bool(\n        template_context.get(\"requires_shell_escape\", False)\n        or getattr(document_state, \"requires_shell_escape\", False)\n        or (template_runtime.requires_shell_escape if template_runtime else False)\n        or code_engine == \"minted\"\n    )\n    if template_runtime and template_runtime.engine:\n        template_context.setdefault(\"latex_engine\", template_runtime.engine)\n\n    emitter_obj = ensure_emitter(emitter)\n\n    if document_state.citations and bibliography_path is not None:\n        template_context[\"bibliography\"] = bibliography_path.stem\n        template_context[\"bibliography_resource\"] = bibliography_path.name\n        template_context.setdefault(\"bibliography_style\", \"numeric\")\n\n    template_context[\"ts_uses_callouts\"] = bool(getattr(document_state, \"callouts_used\", False))\n\n    # Render fragments and inject declarations into template variables.\n    requested_fragments = list(fragment_names)\n    callout_overrides = overrides_payload.get(\"callouts\") if overrides_payload else None\n    callouts_defs = normalise_callouts(\n        merge_callouts(\n            DEFAULT_CALLOUTS, callout_overrides if isinstance(callout_overrides, Mapping) else None\n        )\n    )\n    template_context.setdefault(\"callouts_definitions\", callouts_defs)\n    variable_injections: dict[str, list[str]] = {}\n    fragment_providers: dict[str, list[str]] = {}\n    declared_slots, _default_slot = template.info.resolve_slots()\n    declared_slot_names = set(declared_slots.keys())\n    declared_vars = _discover_template_variables(template)\n    rendered_fragments: set[str] = set()\n    if fragment_names:\n        fragment_context: dict[str, Any] = template_context\n\n        def _reassert_effective_emoji_mode(target: dict[str, Any]) -&gt; None:\n            effective_mode = target.get(\"_texsmith_effective_emoji_mode\")\n            if not effective_mode:\n                return\n            target[\"emoji\"] = effective_mode\n            target[\"emoji_mode\"] = effective_mode\n            fonts_section = target.get(\"fonts\")\n            if isinstance(fonts_section, Mapping):\n                if isinstance(fonts_section, dict):\n                    fonts_section[\"emoji\"] = effective_mode\n                else:\n                    updated_fonts = dict(fonts_section)\n                    updated_fonts[\"emoji\"] = effective_mode\n                    target[\"fonts\"] = updated_fonts\n\n        if overrides_payload:\n            for key, value in overrides_payload.items():\n                if key in fragment_attributes:\n                    continue\n                fragment_context.setdefault(key, value)\n            press_section = overrides_payload.get(\"press\")\n            if isinstance(press_section, Mapping):\n                for key, value in press_section.items():\n                    fragment_context.setdefault(key, value)\n            _reassert_effective_emoji_mode(fragment_context)\n        else:\n            _reassert_effective_emoji_mode(fragment_context)\n        fragment_result = render_fragments(\n            fragment_names,\n            context=fragment_context,\n            output_dir=output_dir,\n            source_dir=source_dir,\n            overrides=overrides_payload,\n            declared_slots=declared_slot_names,\n            declared_variables=declared_vars,\n            template_name=template.info.name,\n        )\n        variable_injections = fragment_result.variable_injections\n        fragment_providers = fragment_result.providers\n        for provider_list in fragment_providers.values():\n            rendered_fragments.update(provider_list)\n    template_context[\"requested_fragments\"] = requested_fragments\n    template_context[\"fragments\"] = sorted(rendered_fragments)\n\n    if variable_injections:\n        for variable_name, injections in variable_injections.items():\n            base = template_context.get(variable_name, \"\")\n            parts: list[str] = [base] if base else []\n            parts.extend(injections)\n            template_context[variable_name] = \"\\n\".join(part for part in parts if part)\n\n    script_macros = render_script_macros(getattr(document_state, \"script_usage\", []))\n    if script_macros:\n        existing_extra = template_context.get(\"extra_packages\", \"\")\n        template_context[\"extra_packages\"] = \"\\n\".join(\n            part for part in (existing_extra, script_macros) if part\n        )\n        template_context[\"script_macros\"] = script_macros\n\n    final_slots = processed_override_slots if processed_override_slots is not None else resolved_slots\n    for slot_name, value in final_slots.items():\n        template_context[slot_name] = value\n    main_slot_content = final_slots.get(default_slot, main_slot_content)\n\n    # Append pdfLaTeX-specific packages when not using LuaLaTeX.\n    extra_lines = [line for line in template_context.get(\"extra_packages\", \"\").splitlines() if line]\n    engine = str(template_context.get(\"latex_engine\") or \"\").strip().lower()\n    if engine and engine != \"lualatex\":\n        for package in template_context.get(\"pdflatex_extra_packages\") or []:\n            if package:\n                extra_lines.append(f\"\\\\usepackage{{{package}}}\")\n    template_context[\"extra_packages\"] = \"\\n\".join(extra_lines)\n\n    if document_state.citations and bibliography_path is not None:\n        template_context[\"bibliography\"] = bibliography_path.stem\n        template_context[\"bibliography_resource\"] = bibliography_path.name\n        template_context.setdefault(\"bibliography_style\", \"plain\")\n\n    latex_output = template.wrap_document(\n        main_slot_content,\n        context=template_context,\n    )\n    latex_output = _squash_blank_lines(latex_output)\n\n    asset_paths: list[Path] = []\n    asset_pairs: list[tuple[Path, Path]] = []\n    if copy_assets:\n        declared_assets = list(template.iter_assets())\n        asset_paths = copy_template_assets(\n            template,\n            output_dir,\n            context=template_context,\n            overrides=overrides_payload,\n            assets=declared_assets,\n        )\n        asset_pairs = [(entry.source, dest) for entry, dest in zip(declared_assets, asset_paths)]\n\n    output_path: Path | None = None\n    if output_name:\n        output_dir.mkdir(parents=True, exist_ok=True)\n        output_path = output_dir / output_name\n        output_path.write_text(latex_output, encoding=\"utf-8\")\n        template_context.setdefault(\"root_filename\", output_path.stem)\n\n    return TemplateWrapResult(\n        latex_output=latex_output,\n        template_context=template_context,\n        output_path=output_path,\n        asset_paths=asset_paths,\n        asset_pairs=asset_pairs,\n        rendered_fragments=sorted(rendered_fragments),\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.BaseTemplate","title":"BaseTemplate","text":"<pre><code>BaseTemplate(root: Path)\n</code></pre> <p>Base class shared by template implementations.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def __init__(self, root: Path) -&gt; None:\n    self.root = root.resolve()\n    if not self.root.exists():\n        raise TemplateError(f\"Template root does not exist: {self.root}\")\n\n    manifest_path = _resolve_manifest_path(self.root)\n    self.manifest = TemplateManifest.load(manifest_path)\n    self.info = self.manifest.latex.template\n    self.environment = _build_environment(self.root)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.BaseTemplate.default_context","title":"default_context","text":"<pre><code>default_context() -&gt; dict[str, Any]\n</code></pre> <p>Return a shallow copy of the manifest default attributes.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def default_context(self) -&gt; dict[str, Any]:\n    \"\"\"Return a shallow copy of the manifest default attributes.\"\"\"\n    defaults = self.info.attribute_defaults()\n    defaults.update(self.info.emit_defaults())\n    return defaults\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.BaseTemplate.render_template","title":"render_template","text":"<pre><code>render_template(template_name: str, **context: Any) -&gt; str\n</code></pre> <p>Render a template using the configured Jinja environment.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def render_template(self, template_name: str, **context: Any) -&gt; str:\n    \"\"\"Render a template using the configured Jinja environment.\"\"\"\n    try:\n        template = self.environment.get_template(template_name)\n    except TemplateNotFound as exc:\n        raise TemplateError(\n            f\"Template entry '{template_name}' is missing in {self.root}\"\n        ) from exc\n    return template.render(context)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.ResolvedAsset","title":"ResolvedAsset  <code>dataclass</code>","text":"<pre><code>ResolvedAsset(\n    source: Path,\n    destination: Path,\n    template: bool = False,\n    encoding: str | None = None,\n    template_name: str | None = None,\n)\n</code></pre> <p>Resolved template asset ready to be materialised.</p>"},{"location":"api/latex/#texsmith.core.templates.base.TemplateError","title":"TemplateError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when a LATEX template cannot be loaded or rendered.</p>"},{"location":"api/latex/#texsmith.core.templates.base.WrappableTemplate","title":"WrappableTemplate","text":"<pre><code>WrappableTemplate(root: Path)\n</code></pre> <p>               Bases: <code>BaseTemplate</code></p> <p>Template capable of wrapping a generated LATEX fragment.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def __init__(self, root: Path) -&gt; None:\n    self.root = root.resolve()\n    if not self.root.exists():\n        raise TemplateError(f\"Template root does not exist: {self.root}\")\n\n    manifest_path = _resolve_manifest_path(self.root)\n    self.manifest = TemplateManifest.load(manifest_path)\n    self.info = self.manifest.latex.template\n    self.environment = _build_environment(self.root)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.WrappableTemplate.iter_assets","title":"iter_assets","text":"<pre><code>iter_assets() -&gt; Iterable['ResolvedAsset']\n</code></pre> <p>Yield declared template assets.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def iter_assets(self) -&gt; Iterable[\"ResolvedAsset\"]:\n    \"\"\"Yield declared template assets.\"\"\"\n    for destination, asset in self.info.assets.items():\n        dest_path = Path(destination)\n        if dest_path.is_absolute():\n            raise TemplateError(\n                f\"Template asset destination must be relative, got '{destination}'.\"\n            )\n\n        source_path = Path(asset.source)\n        if not source_path.is_absolute():\n            source_path = (self.root / source_path).resolve()\n        if not source_path.exists():\n            raise TemplateError(\n                f\"Declared template asset '{asset.source}' is missing under {self.root}.\"\n            )\n\n        template_name: str | None = None\n        if asset.template:\n            if source_path.is_dir():\n                raise TemplateError(\n                    f\"Templated assets must reference files, got directory '{asset.source}'.\"\n                )\n            try:\n                relative = source_path.relative_to(self.root)\n            except ValueError as exc:  # pragma: no cover - defensive\n                common_dir = self.root.parent / \"common\"\n                try:\n                    relative = source_path.relative_to(common_dir)\n                except ValueError as nested_exc:\n                    raise TemplateError(\n                        f\"Templated asset '{asset.source}' must live inside the template root \"\n                        \"or the shared 'common' directory.\"\n                    ) from nested_exc\n            template_name = relative.as_posix()\n\n        yield ResolvedAsset(\n            source=source_path,\n            destination=dest_path,\n            template=asset.template,\n            encoding=asset.encoding,\n            template_name=template_name,\n        )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.WrappableTemplate.iter_formatter_overrides","title":"iter_formatter_overrides","text":"<pre><code>iter_formatter_overrides() -&gt; Iterable[tuple[str, Path]]\n</code></pre> <p>Yield formatter override templates declared by the manifest.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def iter_formatter_overrides(self) -&gt; Iterable[tuple[str, Path]]:\n    \"\"\"Yield formatter override templates declared by the manifest.\"\"\"\n    if not self.info.override:\n        return ()\n\n    search_roots = [\n        self.root / \"overrides\",\n        self.root / \"template\" / \"overrides\",\n        self.root,\n        self.root.parent / \"overrides\",\n    ]\n\n    seen: set[str] = set()\n    overrides: list[tuple[str, Path]] = []\n\n    for entry in self.info.override:\n        if not isinstance(entry, str):\n            raise TemplateError(\"Formatter override entries must be provided as string paths.\")\n        candidate = entry.strip()\n        if not candidate:\n            continue\n\n        relative_path = Path(candidate)\n        if relative_path.is_absolute() or any(part == \"..\" for part in relative_path.parts):\n            raise TemplateError(\n                f\"Formatter override '{entry}' must be a relative path without '..'.\"\n            )\n\n        resolved_path: Path | None = None\n        for root in search_roots:\n            if not root.exists():\n                continue\n            probe = (root / relative_path).resolve()\n            if probe.exists():\n                resolved_path = probe\n                break\n\n        if resolved_path is None:\n            raise TemplateError(f\"Formatter override '{entry}' is missing under '{self.root}'.\")\n\n        key = relative_path.with_suffix(\"\").as_posix().replace(\"/\", \"_\")\n        if key in seen:\n            continue\n        seen.add(key)\n        overrides.append((key, resolved_path))\n\n    return overrides\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.WrappableTemplate.prepare_context","title":"prepare_context","text":"<pre><code>prepare_context(\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build the rendering context shared by the template and its assets.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def prepare_context(\n    self,\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Build the rendering context shared by the template and its assets.\"\"\"\n    attribute_context = self.info.resolve_attributes(overrides)\n    context = dict(attribute_context)\n    for key, value in self.info.emit_defaults().items():\n        context.setdefault(key, value)\n    if overrides:\n        for key, value in overrides.items():\n            if key in context and key not in self.info.emit:\n                continue\n            context[key] = value\n\n    context.setdefault(\"frontmatter\", \"\")\n    context.setdefault(\"backmatter\", \"\")\n    context.setdefault(\"index_entries\", False)\n    context.setdefault(\"has_index\", False)\n    context.setdefault(\"index_terms\", [])\n    context.setdefault(\"index_registry\", [])\n    context.setdefault(\"index_engine\", \"auto\")\n    context.setdefault(\"acronyms\", {})\n    context.setdefault(\"citations\", [])\n    context.setdefault(\"bibliography_entries\", {})\n    context.setdefault(\"bibliography_resource\", None)\n\n    slots, default_slot = self.info.resolve_slots()\n    for name in slots:\n        context.setdefault(name, \"\")\n\n    if default_slot == \"mainmatter\":\n        context[\"mainmatter\"] = latex_body\n    else:\n        context.setdefault(\"mainmatter\", \"\")\n        context[default_slot] = latex_body\n\n    return context\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.WrappableTemplate.wrap_document","title":"wrap_document","text":"<pre><code>wrap_document(\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n    context: Mapping[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Render the template entry point using the provided LATEX payload.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def wrap_document(\n    self,\n    latex_body: str,\n    *,\n    overrides: Mapping[str, Any] | None = None,\n    context: Mapping[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Render the template entry point using the provided LaTeX payload.\"\"\"\n    if context is None:\n        context = self.prepare_context(latex_body, overrides=overrides)\n    else:\n        context = dict(context)\n        context.setdefault(\"frontmatter\", \"\")\n        context.setdefault(\"backmatter\", \"\")\n        slots, default_slot = self.info.resolve_slots()\n        for name in slots:\n            context.setdefault(name, \"\")\n        if default_slot == \"mainmatter\":\n            context[\"mainmatter\"] = latex_body\n        else:\n            context.setdefault(\"mainmatter\", \"\")\n            context[default_slot] = latex_body\n\n    engine = str(context.get(\"index_engine\") or \"\").strip().lower()\n    if not engine or engine == \"auto\":\n        context[\"index_engine\"] = _detect_index_engine()\n    else:\n        context[\"index_engine\"] = engine\n\n    return self.render_template(self.info.entrypoint, **context)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.base.load_specialised_template","title":"load_specialised_template","text":"<pre><code>load_specialised_template(\n    path: Path,\n) -&gt; WrappableTemplate | None\n</code></pre> <p>Import a template-specific module to retrieve a specialised implementation.</p> Source code in <code>src/texsmith/core/templates/base.py</code> <pre><code>def load_specialised_template(path: Path) -&gt; WrappableTemplate | None:\n    \"\"\"Import a template-specific module to retrieve a specialised implementation.\"\"\"\n    init_path = path / \"__init__.py\"\n    if not init_path.exists():\n        return None\n\n    resolved_init = init_path.resolve()\n    module_name = f\"_texsmith_template_{hash(resolved_init) &amp; 0xFFFFFFFF:x}\"\n    spec = importlib.util.spec_from_file_location(\n        module_name,\n        resolved_init,\n        submodule_search_locations=[str(path.resolve())],\n    )\n    if spec is None or spec.loader is None:  # pragma: no cover - defensive\n        return None\n\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[module_name] = module\n    try:\n        spec.loader.exec_module(module)\n    except Exception as exc:  # pragma: no cover - surface import errors\n        sys.modules.pop(module_name, None)\n        raise TemplateError(f\"Failed to import template module at '{path}': {exc}\") from exc\n\n    for attribute in (\"Template\", \"template\", \"load_template\", \"get_template\"):\n        candidate = getattr(module, attribute, None)\n        if candidate is None:\n            continue\n        specialised = _coerce_template(candidate)\n        if specialised is not None:\n            return specialised\n\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.loader.copy_template_assets","title":"copy_template_assets","text":"<pre><code>copy_template_assets(\n    template: WrappableTemplate,\n    output_dir: Path,\n    *,\n    context: Mapping[str, Any] | None = None,\n    overrides: Mapping[str, Any] | None = None,\n    assets: Iterable[\"ResolvedAsset\"] | None = None,\n) -&gt; list[Path]\n</code></pre> <p>Copy the template declared assets into the selected output directory.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def copy_template_assets(\n    template: WrappableTemplate,\n    output_dir: Path,\n    *,\n    context: Mapping[str, Any] | None = None,\n    overrides: Mapping[str, Any] | None = None,\n    assets: Iterable[\"ResolvedAsset\"] | None = None,\n) -&gt; list[Path]:\n    \"\"\"Copy the template declared assets into the selected output directory.\"\"\"\n    output_dir = Path(output_dir).resolve()\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    if context is None:\n        render_context = template.prepare_context(\"\", overrides=overrides)\n    else:\n        render_context = dict(context)\n\n    written: list[Path] = []\n    asset_entries = list(assets) if assets is not None else list(template.iter_assets())\n    for asset in asset_entries:\n        destination_path = (output_dir / asset.destination).resolve()\n\n        if asset.template:\n            if asset.template_name is None:  # pragma: no cover - defensive\n                raise TemplateError(\n                    f\"Templated asset '{asset.source}' is missing template metadata.\"\n                )\n            destination_path.parent.mkdir(parents=True, exist_ok=True)\n            rendered = template.render_template(asset.template_name, **render_context)\n            destination_path.write_text(\n                rendered,\n                encoding=asset.encoding or \"utf-8\",\n            )\n        elif asset.source.is_dir():\n            shutil.copytree(asset.source, destination_path, dirs_exist_ok=True)\n        else:\n            destination_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy2(asset.source, destination_path)\n\n        written.append(destination_path)\n\n    return written\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.loader.discover_templates","title":"discover_templates","text":"<pre><code>discover_templates() -&gt; list[dict[str, str]]\n</code></pre> <p>Return available templates in discovery order.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def discover_templates() -&gt; list[dict[str, str]]:\n    \"\"\"Return available templates in discovery order.\"\"\"\n    entries: list[dict[str, str]] = []\n\n    def _record(origin: str, name: str, root: Path) -&gt; None:\n        entries.append({\"name\": name, \"origin\": origin, \"root\": str(root.resolve())})\n\n    for slug in iter_builtin_templates():\n        try:\n            template = load_builtin_template(slug)\n        except TemplateError:\n            continue\n        if template is not None:\n            _record(\"builtin\", slug, template.root)\n\n    try:\n        for dist in metadata.distributions():\n            name = dist.metadata.get(\"Name\", \"\")\n            if not name.lower().startswith(\"texsmith-template-\"):\n                continue\n            slug = name[len(\"texsmith-template-\") :]\n            root = _resolve_packaged_template_root(slug)\n            if root is None:\n                continue\n            _record(\"package\", slug, root)\n    except Exception:\n        pass\n\n    seen_locals: set[str] = set()\n    for candidate in _iter_local_candidates(\"\"):\n        if not _looks_like_template_root(candidate):\n            continue\n        key = str(candidate.resolve())\n        if key in seen_locals:\n            continue\n        seen_locals.add(key)\n        _record(\"local\", candidate.name, candidate)\n\n    home_root = get_user_dir().data_dir(\"templates\", create=False)\n    if home_root.exists():\n        for child in sorted(home_root.iterdir()):\n            if child.is_dir() and _looks_like_template_root(child):\n                _record(\"home\", child.name, child)\n\n    return sorted(entries, key=lambda entry: (entry[\"origin\"], entry[\"name\"]))\n\n    for candidate in _iter_local_candidates(\"*placeholder*\"):\n        pass\n\n    local_candidates: list[Path] = []\n    for slug in set():\n        pass\n\n    for candidate in _iter_local_candidates(\"*placeholder*\"):\n        pass\n\n    def _record(origin: str, name: str, root: Path) -&gt; None:\n        key = (name, str(root))\n        if key in seen_paths:\n            return\n        seen_paths.add(key)\n        entries.append({\"name\": name, \"origin\": origin, \"root\": str(root)})\n\n    # Re-run local with concrete names.\n    visited: set[str] = set()\n    cwd = Path.cwd().resolve()\n    for candidate in _iter_local_candidates(\"\"):\n        if _looks_like_template_root(candidate):\n            _record(\"local\", candidate.name, candidate)\n\n    home_root = get_user_dir().data_dir(\"templates\", create=False)\n    if home_root.exists():\n        for child in home_root.iterdir():\n            if child.is_dir() and _looks_like_template_root(child):\n                _record(\"home\", child.name, child)\n\n    return sorted(entries, key=lambda entry: (entry[\"origin\"], entry[\"name\"]))\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.loader.load_template","title":"load_template","text":"<pre><code>load_template(identifier: str) -&gt; WrappableTemplate\n</code></pre> <p>Load a template selected by name or filesystem path.</p> Source code in <code>src/texsmith/core/templates/loader.py</code> <pre><code>def load_template(identifier: str) -&gt; WrappableTemplate:\n    \"\"\"Load a template selected by name or filesystem path.\"\"\"\n    path_candidate = Path(identifier).expanduser()\n    looks_like_path = (\n        path_candidate.is_absolute()\n        or \"/\" in identifier\n        or \"\\\\\" in identifier\n        or identifier.startswith(\".\")\n    )\n    if looks_like_path and path_candidate.exists():\n        return _load_path_template(path_candidate)\n\n    slug = _slug_from_identifier(identifier)\n\n    builtin = load_builtin_template(identifier)\n    if builtin is not None:\n        return builtin\n\n    packaged_root = _resolve_packaged_template_root(slug)\n    if packaged_root is not None:\n        return _load_path_template(packaged_root)\n\n    for candidate in _iter_local_candidates(slug):\n        if _looks_like_template_root(candidate):\n            return _load_path_template(candidate)\n\n    home_candidate = _home_template_candidate(slug)\n    if home_candidate is not None and _looks_like_template_root(home_candidate):\n        return _load_path_template(home_candidate)\n\n    raise TemplateError(\n        f\"Unable to load template '{identifier}'. Provide a valid path or \"\n        \"install a package exposing a 'texsmith.templates' entry point.\"\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.CompatInfo","title":"CompatInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Compatibility constraints declared by the template.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.LatexSection","title":"LatexSection","text":"<p>               Bases: <code>BaseModel</code></p> <p>Section grouping LATEX-specific manifest settings.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateAsset","title":"TemplateAsset","text":"<p>               Bases: <code>BaseModel</code></p> <p>Description of individual template assets.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateAttributeResolver","title":"TemplateAttributeResolver","text":"<pre><code>TemplateAttributeResolver(\n    specs: Mapping[str, TemplateAttributeSpec],\n)\n</code></pre> <p>Resolve attribute values from overrides using a typed specification.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def __init__(self, specs: Mapping[str, TemplateAttributeSpec]):\n    self._specs = dict(specs)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateAttributeSpec","title":"TemplateAttributeSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>Typed attribute definition used to build template defaults.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateAttributeSpec.default_value","title":"default_value","text":"<pre><code>default_value() -&gt; Any\n</code></pre> <p>Return a deep copy of the attribute default.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def default_value(self) -&gt; Any:\n    \"\"\"Return a deep copy of the attribute default.\"\"\"\n    return copy.deepcopy(self._default_cache)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateError","title":"TemplateError","text":"<p>               Bases: <code>LatexRenderingError</code></p> <p>Raised when a LATEX template cannot be loaded or rendered.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo","title":"TemplateInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata describing the LATEX template payload.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo.attribute_defaults","title":"attribute_defaults","text":"<pre><code>attribute_defaults() -&gt; dict[str, Any]\n</code></pre> <p>Return a deep copy of template attribute defaults.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def attribute_defaults(self) -&gt; dict[str, Any]:\n    \"\"\"Return a deep copy of template attribute defaults.\"\"\"\n    return copy.deepcopy(self._attribute_defaults)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo.attribute_owners","title":"attribute_owners","text":"<pre><code>attribute_owners() -&gt; dict[str, str]\n</code></pre> <p>Return attribute ownership map (name -&gt; owner).</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def attribute_owners(self) -&gt; dict[str, str]:\n    \"\"\"Return attribute ownership map (name -&gt; owner).\"\"\"\n    return dict(self._attribute_owners)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo.emit_defaults","title":"emit_defaults","text":"<pre><code>emit_defaults() -&gt; dict[str, Any]\n</code></pre> <p>Return default attributes emitted by the template.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def emit_defaults(self) -&gt; dict[str, Any]:\n    \"\"\"Return default attributes emitted by the template.\"\"\"\n    return copy.deepcopy(self.emit)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo.resolve_attributes","title":"resolve_attributes","text":"<pre><code>resolve_attributes(\n    overrides: Mapping[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Return defaults merged with overrides using the attribute specification.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_attributes(self, overrides: Mapping[str, Any] | None = None) -&gt; dict[str, Any]:\n    \"\"\"Return defaults merged with overrides using the attribute specification.\"\"\"\n    return self._attribute_resolver.merge(overrides)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateInfo.resolve_slots","title":"resolve_slots","text":"<pre><code>resolve_slots() -&gt; tuple[dict[str, TemplateSlot], str]\n</code></pre> <p>Return declared slots ensuring a single default sink exists.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_slots(self) -&gt; tuple[dict[str, TemplateSlot], str]:\n    \"\"\"Return declared slots ensuring a single default sink exists.\"\"\"\n    resolved = {\n        name: slot if isinstance(slot, TemplateSlot) else TemplateSlot.model_validate(slot)\n        for name, slot in self.slots.items()\n    }\n\n    if \"mainmatter\" not in resolved:\n        resolved[\"mainmatter\"] = TemplateSlot(default=True)\n\n    defaults = [name for name, slot in resolved.items() if slot.default]\n    if not defaults:\n        resolved[\"mainmatter\"] = resolved[\"mainmatter\"].model_copy(update={\"default\": True})\n        defaults = [\"mainmatter\"]\n    elif len(defaults) &gt; 1:\n        formatted = \", \".join(defaults)\n        raise TemplateError(f\"Multiple default slots declared: {formatted}\")\n\n    return resolved, defaults[0]\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateManifest","title":"TemplateManifest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured manifest describing a LATEX template.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateManifest.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(manifest_path: Path) -&gt; TemplateManifest\n</code></pre> <p>Load and validate a manifest from disk.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>@classmethod\ndef load(cls, manifest_path: Path) -&gt; TemplateManifest:\n    \"\"\"Load and validate a manifest from disk.\"\"\"\n    try:\n        content = tomllib.loads(manifest_path.read_text(encoding=\"utf-8\"))\n    except FileNotFoundError as exc:  # pragma: no cover - sanity check\n        raise TemplateError(f\"Template manifest is missing: {manifest_path}\") from exc\n    except OSError as exc:  # pragma: no cover - IO failure\n        raise TemplateError(f\"Failed to read template manifest: {exc}\") from exc\n    except tomllib.TOMLDecodeError as exc:\n        raise TemplateError(f\"Invalid template manifest: {exc}\") from exc\n\n    try:\n        return cls.model_validate(content)\n    except ValidationError as exc:\n        raise TemplateError(f\"Template manifest validation failed: {exc}\") from exc\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateSlot","title":"TemplateSlot","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration describing how content is injected into a template slot.</p>"},{"location":"api/latex/#texsmith.core.templates.manifest.TemplateSlot.resolve_level","title":"resolve_level","text":"<pre><code>resolve_level(fallback: int) -&gt; int\n</code></pre> <p>Return the base level applied to rendered headings for this slot.</p> Source code in <code>src/texsmith/core/templates/manifest.py</code> <pre><code>def resolve_level(self, fallback: int) -&gt; int:\n    \"\"\"Return the base level applied to rendered headings for this slot.\"\"\"\n    base = fallback\n    if self.base_level is not None:\n        base = self.base_level\n    elif self.depth is not None:\n        base = fallback + LATEX_HEADING_LEVELS[self.depth]\n    return base + self.offset\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.TemplateBinding","title":"TemplateBinding  <code>dataclass</code>","text":"<pre><code>TemplateBinding(\n    runtime: TemplateRuntime | None,\n    instance: WrappableTemplate | None,\n    name: str | None,\n    engine: str | None,\n    requires_shell_escape: bool,\n    formatter_overrides: dict[str, Path],\n    slots: dict[str, TemplateSlot],\n    default_slot: str,\n    base_level: int | None,\n    required_partials: set[str] = set(),\n)\n</code></pre> <p>Binding between slot requests and a LATEX template.</p>"},{"location":"api/latex/#texsmith.core.templates.runtime.TemplateBinding.apply_formatter_overrides","title":"apply_formatter_overrides","text":"<pre><code>apply_formatter_overrides(\n    formatter: \"LaTeXFormatter\",\n) -&gt; None\n</code></pre> <p>Apply template-provided overrides to a formatter.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def apply_formatter_overrides(self, formatter: \"LaTeXFormatter\") -&gt; None:\n    \"\"\"Apply template-provided overrides to a formatter.\"\"\"\n    for key, override_path in self.formatter_overrides.items():\n        formatter.override_template(key, override_path)\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.TemplateBinding.slot_levels","title":"slot_levels","text":"<pre><code>slot_levels(*, offset: int = 0) -&gt; dict[str, int]\n</code></pre> <p>Return the resolved base level for each slot.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def slot_levels(self, *, offset: int = 0) -&gt; dict[str, int]:\n    \"\"\"Return the resolved base level for each slot.\"\"\"\n    base = (self.base_level or 0) + offset\n    return {name: slot.resolve_level(base) for name, slot in self.slots.items()}\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.TemplateRuntime","title":"TemplateRuntime  <code>dataclass</code>","text":"<pre><code>TemplateRuntime(\n    instance: WrappableTemplate,\n    name: str,\n    engine: str | None,\n    requires_shell_escape: bool,\n    slots: dict[str, TemplateSlot],\n    default_slot: str,\n    formatter_overrides: dict[str, Path],\n    base_level: int | None,\n    required_partials: set[str] = set(),\n    extras: dict[str, Any] = dict(),\n)\n</code></pre> <p>Resolved template metadata reused across conversions.</p>"},{"location":"api/latex/#texsmith.core.templates.runtime.build_template_overrides","title":"build_template_overrides","text":"<pre><code>build_template_overrides(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build template overrides from front matter while preserving metadata.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def build_template_overrides(front_matter: Mapping[str, Any] | None) -&gt; dict[str, Any]:\n    \"\"\"Build template overrides from front matter while preserving metadata.\"\"\"\n    if not front_matter or not isinstance(front_matter, Mapping):\n        return {}\n\n    overrides = dict(front_matter)\n    press_section = overrides.get(\"press\")\n    if isinstance(press_section, Mapping):\n        overrides[\"press\"] = dict(press_section)\n\n    fragments = overrides.get(\"fragments\")\n    if fragments is None and isinstance(press_section, Mapping):\n        fragments = press_section.get(\"fragments\")\n    if isinstance(fragments, list):\n        overrides[\"fragments\"] = list(fragments)\n\n    callouts_section = overrides.get(\"callouts\")\n    if callouts_section is None and isinstance(press_section, Mapping):\n        callouts_section = press_section.get(\"callouts\")\n    if isinstance(callouts_section, Mapping):\n        overrides[\"callouts\"] = dict(callouts_section)\n\n    callouts_style = overrides.get(\"callouts_style\")\n    if callouts_style is None and isinstance(press_section, Mapping):\n        callouts_style = press_section.get(\"callouts_style\")\n    if callouts_style is not None:\n        overrides[\"callout_style\"] = callouts_style\n\n    base_override = overrides.get(\"base_level\")\n    if base_override is None and isinstance(press_section, Mapping):\n        base_override = press_section.get(\"base_level\")\n    if base_override is not None:\n        try:\n            overrides[\"base_level\"] = coerce_base_level(base_override)\n        except TemplateError:\n            overrides[\"base_level\"] = base_override\n\n    return overrides\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.coerce_base_level","title":"coerce_base_level","text":"<pre><code>coerce_base_level(\n    value: Any, *, allow_none: bool = True\n) -&gt; int | None\n</code></pre> <p>Normalise base-level metadata to an integer or <code>None</code>.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def coerce_base_level(value: Any, *, allow_none: bool = True) -&gt; int | None:\n    \"\"\"Normalise base-level metadata to an integer or ``None``.\"\"\"\n    if value is None:\n        if allow_none:\n            return None\n        raise TemplateError(\"Base level value is missing.\")\n\n    if isinstance(value, bool):\n        raise TemplateError(\"Base level must be an integer, booleans are not supported.\")\n\n    if isinstance(value, (int, float)):\n        return int(value)\n\n    if isinstance(value, str):\n        candidate = value.strip().lower()\n        if not candidate:\n            if allow_none:\n                return None\n            raise TemplateError(\"Base level value cannot be empty.\")\n        alias_map = {\n            \"part\": -1,\n            \"chapter\": 0,\n            \"section\": 1,\n            \"subsection\": 2,\n        }\n        if candidate in alias_map:\n            return alias_map[candidate]\n        try:\n            return int(candidate)\n        except ValueError as exc:  # pragma: no cover - defensive\n            raise TemplateError(\n                f\"Invalid base level '{value}'. Expected an integer value or one of \"\n                f\"{', '.join(alias_map)}.\"\n            ) from exc\n\n    raise TemplateError(\n        f\"Base level should be provided as an integer value, got type '{type(value).__name__}'.\"\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.extract_base_level_override","title":"extract_base_level_override","text":"<pre><code>extract_base_level_override(\n    overrides: Mapping[str, Any] | None,\n) -&gt; Any\n</code></pre> <p>Extract a base level override from template metadata overrides.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def extract_base_level_override(overrides: Mapping[str, Any] | None) -&gt; Any:\n    \"\"\"Extract a base level override from template metadata overrides.\"\"\"\n    if not overrides:\n        return None\n\n    press_section = overrides.get(\"press\")\n    direct_candidate = overrides.get(\"base_level\")\n    if direct_candidate is not None:\n        return direct_candidate\n    if isinstance(press_section, Mapping):\n        return press_section.get(\"base_level\")\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.extract_language_from_front_matter","title":"extract_language_from_front_matter","text":"<pre><code>extract_language_from_front_matter(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str | None\n</code></pre> <p>Inspect front matter for language hints.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def extract_language_from_front_matter(\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str | None:\n    \"\"\"Inspect front matter for language hints.\"\"\"\n    if not isinstance(front_matter, Mapping):\n        return None\n\n    for key in (\"language\", \"lang\"):\n        value = front_matter.get(key)\n        if isinstance(value, str):\n            stripped = value.strip()\n            if stripped:\n                return stripped\n\n    press_entry = front_matter.get(\"press\")\n    if isinstance(press_entry, Mapping):\n        for key in (\"language\", \"lang\"):\n            value = press_entry.get(key)\n            if isinstance(value, str):\n                stripped = value.strip()\n                if stripped:\n                    return stripped\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.load_template_runtime","title":"load_template_runtime","text":"<pre><code>load_template_runtime(template: str) -&gt; TemplateRuntime\n</code></pre> <p>Resolve template metadata for repeated conversions.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def load_template_runtime(template: str) -&gt; TemplateRuntime:\n    \"\"\"Resolve template metadata for repeated conversions.\"\"\"\n    template_instance = load_template(template)\n\n    template_base = coerce_base_level(\n        template_instance.info.get_attribute_default(\"base_level\"),\n    )\n\n    slots, default_slot = template_instance.info.resolve_slots()\n    formatter_overrides = dict(template_instance.iter_formatter_overrides())\n    extras_payload = getattr(template_instance, \"extras\", {}) or {}\n    extras = {key: value for key, value in extras_payload.items()}\n    declared_fragments = (\n        list(template_instance.info.fragments) if template_instance.info.fragments is not None else None\n    )\n    extras.setdefault(\n        \"fragments\",\n        declared_fragments if declared_fragments is not None else [],\n    )\n\n    return TemplateRuntime(\n        instance=template_instance,\n        name=template_instance.info.name,\n        engine=template_instance.info.engine,\n        requires_shell_escape=bool(template_instance.info.shell_escape),\n        slots=slots,\n        default_slot=default_slot,\n        formatter_overrides=formatter_overrides,\n        base_level=template_base,\n        required_partials=set(template_instance.info.required_partials or []),\n        extras=extras,\n    )\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.normalise_template_language","title":"normalise_template_language","text":"<pre><code>normalise_template_language(\n    value: str | None,\n) -&gt; str | None\n</code></pre> <p>Normalise language codes and map them through babel aliases when available.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def normalise_template_language(value: str | None) -&gt; str | None:\n    \"\"\"Normalise language codes and map them through babel aliases when available.\"\"\"\n    if value is None:\n        return None\n\n    stripped = value.strip()\n    if not stripped:\n        return None\n\n    lowered = stripped.lower().replace(\"_\", \"-\")\n    alias = _BABEL_LANGUAGE_ALIASES.get(lowered)\n    if alias:\n        return alias\n\n    primary = lowered.split(\"-\", 1)[0]\n    alias = _BABEL_LANGUAGE_ALIASES.get(primary)\n    if alias:\n        return alias\n\n    if lowered.isalpha():\n        return lowered\n\n    return None\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.resolve_template_binding","title":"resolve_template_binding","text":"<pre><code>resolve_template_binding(\n    *,\n    template: str | None,\n    template_runtime: TemplateRuntime | None,\n    template_overrides: Mapping[str, Any],\n    slot_requests: Mapping[str, str],\n    warn: Callable[[str], None] | None = None,\n) -&gt; tuple[TemplateBinding, dict[str, str]]\n</code></pre> <p>Resolve template runtime metadata and apply slot overrides.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def resolve_template_binding(\n    *,\n    template: str | None,\n    template_runtime: TemplateRuntime | None,\n    template_overrides: Mapping[str, Any],\n    slot_requests: Mapping[str, str],\n    warn: Callable[[str], None] | None = None,\n) -&gt; tuple[TemplateBinding, dict[str, str]]:\n    \"\"\"Resolve template runtime metadata and apply slot overrides.\"\"\"\n    runtime = template_runtime\n    if runtime is None and template:\n        runtime = load_template_runtime(template)\n\n    if runtime is not None:\n        # Adjust base level for book parts when requested via overrides.\n        binding_base_level = runtime.base_level\n        part_flag = None\n        press_section = template_overrides.get(\"press\")\n        if isinstance(template_overrides.get(\"part\"), bool):\n            part_flag = template_overrides.get(\"part\")\n        elif isinstance(press_section, Mapping) and isinstance(press_section.get(\"part\"), bool):\n            part_flag = press_section.get(\"part\")\n        if part_flag and runtime.name == \"book\":\n            binding_base_level = coerce_base_level(\"part\")\n\n        binding = TemplateBinding(\n            runtime=runtime,\n            instance=runtime.instance,\n            name=runtime.name,\n            engine=runtime.engine,\n            requires_shell_escape=runtime.requires_shell_escape,\n            formatter_overrides=dict(runtime.formatter_overrides),\n            slots=runtime.slots,\n            default_slot=runtime.default_slot,\n            base_level=binding_base_level,\n            required_partials=set(runtime.required_partials),\n        )\n    else:\n        binding = TemplateBinding(\n            runtime=None,\n            instance=None,\n            name=None,\n            engine=None,\n            requires_shell_escape=False,\n            formatter_overrides={},\n            slots={\"mainmatter\": TemplateSlot(default=True)},\n            default_slot=\"mainmatter\",\n            base_level=None,\n            required_partials=set(),\n        )\n\n    base_override = coerce_base_level(extract_base_level_override(template_overrides))\n    if base_override is not None:\n        binding.base_level = base_override\n\n    filtered: dict[str, str] = {}\n    for slot_name, selector in slot_requests.items():\n        if slot_name not in binding.slots:\n            if warn is not None:\n                template_hint = f\"template '{binding.name}'\" if binding.name else \"the template\"\n                warn(\n                    f\"slot '{slot_name}' is not defined by {template_hint}; \"\n                    f\"content will remain in '{binding.default_slot}'.\"\n                )\n            continue\n        if binding.runtime is None:\n            if warn is not None:\n                warn(f\"slot '{slot_name}' was requested but no template is selected; ignoring.\")\n            continue\n        filtered[slot_name] = selector\n\n    return binding, filtered\n</code></pre>"},{"location":"api/latex/#texsmith.core.templates.runtime.resolve_template_language","title":"resolve_template_language","text":"<pre><code>resolve_template_language(\n    explicit: str | None,\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str\n</code></pre> <p>Resolve the effective template language from CLI and front matter inputs.</p> Source code in <code>src/texsmith/core/templates/runtime.py</code> <pre><code>def resolve_template_language(\n    explicit: str | None,\n    front_matter: Mapping[str, Any] | None,\n) -&gt; str:\n    \"\"\"Resolve the effective template language from CLI and front matter inputs.\"\"\"\n    candidates = (\n        normalise_template_language(explicit),\n        normalise_template_language(extract_language_from_front_matter(front_matter)),\n    )\n\n    for candidate in candidates:\n        if candidate:\n            return candidate\n\n    return DEFAULT_TEMPLATE_LANGUAGE\n</code></pre>"},{"location":"api/markdown/","title":"Markdown Conversion","text":"<p>Markdown conversion utilities for TeXSmith.</p> <p>Central registry for TeXSmith's bundled Markdown extensions.</p> <p>Extension to capture undefined Markdown footnotes.</p>"},{"location":"api/markdown/#texsmith.adapters.markdown.MarkdownConversionError","title":"MarkdownConversionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Markdown cannot be converted into HTML.</p>"},{"location":"api/markdown/#texsmith.adapters.markdown.MarkdownDocument","title":"MarkdownDocument  <code>dataclass</code>","text":"<pre><code>MarkdownDocument(html: str, front_matter: dict[str, Any])\n</code></pre> <p>Result of converting Markdown into HTML.</p>"},{"location":"api/markdown/#texsmith.adapters.markdown.deduplicate_markdown_extensions","title":"deduplicate_markdown_extensions","text":"<pre><code>deduplicate_markdown_extensions(\n    values: Iterable[str],\n) -&gt; list[str]\n</code></pre> <p>Remove duplicate extensions while preserving order and case.</p> Source code in <code>src/texsmith/adapters/markdown/__init__.py</code> <pre><code>def deduplicate_markdown_extensions(values: Iterable[str]) -&gt; list[str]:\n    \"\"\"Remove duplicate extensions while preserving order and case.\"\"\"\n    seen: set[str] = set()\n    result: list[str] = []\n    for value in values:\n        if not isinstance(value, str):\n            continue\n        key = value.lower()\n        if key in seen:\n            continue\n        seen.add(key)\n        result.append(value)\n    return result\n</code></pre>"},{"location":"api/markdown/#texsmith.adapters.markdown.normalize_markdown_extensions","title":"normalize_markdown_extensions","text":"<pre><code>normalize_markdown_extensions(\n    values: Iterable[str] | str | None,\n) -&gt; list[str]\n</code></pre> <p>Normalise extension names from CLI-friendly strings into a flat list.</p> Source code in <code>src/texsmith/adapters/markdown/__init__.py</code> <pre><code>def normalize_markdown_extensions(\n    values: Iterable[str] | str | None,\n) -&gt; list[str]:\n    \"\"\"Normalise extension names from CLI-friendly strings into a flat list.\"\"\"\n    if values is None:\n        return []\n\n    if isinstance(values, str):\n        candidates: Iterable[str] = [values]\n    else:\n        candidates = values\n\n    normalized: list[str] = []\n    for value in candidates:\n        if not isinstance(value, str):\n            continue\n        chunks = re.split(r\"[,\\s\\x00]+\", value)\n        normalized.extend(chunk for chunk in chunks if chunk)\n    return normalized\n</code></pre>"},{"location":"api/markdown/#texsmith.adapters.markdown.render_markdown","title":"render_markdown","text":"<pre><code>render_markdown(\n    source: str,\n    extensions: Sequence[str] | None = None,\n    *,\n    base_path: str | Path | None = None,\n) -&gt; MarkdownDocument\n</code></pre> <p>Convert Markdown source into HTML while collecting front matter.</p> Source code in <code>src/texsmith/adapters/markdown/__init__.py</code> <pre><code>def render_markdown(\n    source: str,\n    extensions: Sequence[str] | None = None,\n    *,\n    base_path: str | Path | None = None,\n) -&gt; MarkdownDocument:\n    \"\"\"Convert Markdown source into HTML while collecting front matter.\"\"\"\n    try:\n        import markdown\n    except ModuleNotFoundError as exc:  # pragma: no cover - environment dependent\n        raise MarkdownConversionError(\n            \"Python Markdown is required to process Markdown inputs; \"\n            \"install the 'markdown' package.\"\n        ) from exc\n\n    metadata, markdown_body = split_front_matter(source)\n\n    active_extensions = list(extensions or ())\n    extensions_key = tuple(active_extensions)\n\n    snippet_enabled = any(\n        _normalise_extension_name(extension) == \"pymdownx.snippets\"\n        for extension in active_extensions\n    )\n    snippet_paths: tuple[str, ...] = ()\n    if snippet_enabled and base_path is not None:\n        snippet_paths = (str(Path(base_path).resolve()),)\n\n    entry = _resolve_markdown_entry(markdown, extensions_key, snippet_paths)\n\n    resolved_base: Path | None = None\n    if base_path is not None:\n        try:\n            resolved_base = Path(base_path).resolve()\n        except OSError:\n            resolved_base = Path(base_path)\n\n    try:\n        with entry.lock:\n            processor = entry.processor\n            reset_callback = getattr(processor, \"reset\", None)\n            if callable(reset_callback):\n                reset_callback()\n            processor.texsmith_mermaid_base_path = (\n                str(resolved_base) if resolved_base is not None else None\n            )\n            html = processor.convert(markdown_body)\n    except MarkdownConversionError:\n        raise\n    except Exception as exc:  # pragma: no cover - library-controlled\n        raise MarkdownConversionError(f\"Failed to convert Markdown source: {exc}\") from exc\n\n    return MarkdownDocument(html=html, front_matter=metadata)\n</code></pre>"},{"location":"api/markdown/#texsmith.adapters.markdown.resolve_markdown_extensions","title":"resolve_markdown_extensions","text":"<pre><code>resolve_markdown_extensions(\n    requested: Iterable[str] | None,\n    disabled: Iterable[str] | None,\n) -&gt; list[str]\n</code></pre> <p>Return the active Markdown extension list after applying overrides.</p> Source code in <code>src/texsmith/adapters/markdown/__init__.py</code> <pre><code>def resolve_markdown_extensions(\n    requested: Iterable[str] | None,\n    disabled: Iterable[str] | None,\n) -&gt; list[str]:\n    \"\"\"Return the active Markdown extension list after applying overrides.\"\"\"\n    enabled = normalize_markdown_extensions(requested)\n    disabled_normalized = {\n        extension.lower() for extension in normalize_markdown_extensions(disabled)\n    }\n\n    combined = deduplicate_markdown_extensions(list(DEFAULT_MARKDOWN_EXTENSIONS) + enabled)\n\n    if not disabled_normalized:\n        return combined\n\n    return [extension for extension in combined if extension.lower() not in disabled_normalized]\n</code></pre>"},{"location":"api/markdown/#texsmith.adapters.markdown.split_front_matter","title":"split_front_matter","text":"<pre><code>split_front_matter(\n    source: str,\n) -&gt; tuple[dict[str, Any], str]\n</code></pre> <p>Split YAML front matter from Markdown content, returning metadata and body.</p> Source code in <code>src/texsmith/adapters/markdown/__init__.py</code> <pre><code>def split_front_matter(source: str) -&gt; tuple[dict[str, Any], str]:\n    \"\"\"Split YAML front matter from Markdown content, returning metadata and body.\"\"\"\n    candidate = source.lstrip(\"\\ufeff\")\n    prefix_len = len(source) - len(candidate)\n    lines = candidate.splitlines()\n    if not lines or lines[0].strip() != \"---\":\n        return {}, source\n\n    front_matter_lines: list[str] = []\n    closing_index: int | None = None\n    for idx, line in enumerate(lines[1:], start=1):\n        stripped = line.strip()\n        if stripped in {\"---\", \"...\"}:\n            closing_index = idx\n            break\n        front_matter_lines.append(line)\n\n    if closing_index is None:\n        return {}, source\n\n    raw_block = \"\\n\".join(front_matter_lines)\n    try:\n        metadata = yaml.safe_load(raw_block) or {}\n    except yaml.YAMLError:\n        return {}, source\n\n    if not isinstance(metadata, dict):\n        metadata = {}\n\n    body_lines = lines[closing_index + 1 :]\n    body = \"\\n\".join(body_lines)\n    if source.endswith(\"\\n\"):\n        body += \"\\n\"\n\n    prefix = source[:prefix_len]\n    return metadata, prefix + body\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.ExtensionSpec","title":"ExtensionSpec  <code>dataclass</code>","text":"<pre><code>ExtensionSpec(\n    slug: str,\n    markdown_entry: str,\n    renderer_entry: str | None = None,\n    mkdocs_entry: str | None = None,\n    description: str | None = None,\n)\n</code></pre> <p>Describe how to import Markdown and renderer hooks for an extension.</p>"},{"location":"api/markdown/#texsmith.extensions.ExtensionSpec.iter_entry_points","title":"iter_entry_points","text":"<pre><code>iter_entry_points() -&gt; Iterable[str]\n</code></pre> <p>Yield configured entry points for documentation/debugging.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def iter_entry_points(self) -&gt; Iterable[str]:\n    \"\"\"Yield configured entry points for documentation/debugging.\"\"\"\n    yield self.markdown_entry\n    if self.renderer_entry:\n        yield self.renderer_entry\n    if self.mkdocs_entry:\n        yield self.mkdocs_entry\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.available_extensions","title":"available_extensions","text":"<pre><code>available_extensions() -&gt; list[ExtensionSpec]\n</code></pre> <p>Return the registered extension specs sorted by slug.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def available_extensions() -&gt; list[ExtensionSpec]:\n    \"\"\"Return the registered extension specs sorted by slug.\"\"\"\n    return [_EXTENSIONS[key] for key in sorted(_EXTENSIONS)]\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.get_extension_spec","title":"get_extension_spec","text":"<pre><code>get_extension_spec(name: str) -&gt; ExtensionSpec\n</code></pre> <p>Look up the runtime spec for a given extension slug or qualified name.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def get_extension_spec(name: str) -&gt; ExtensionSpec:\n    \"\"\"Look up the runtime spec for a given extension slug or qualified name.\"\"\"\n    slug = _normalise_slug(name)\n    try:\n        return _EXTENSIONS[slug]\n    except KeyError as exc:  # pragma: no cover - defensive\n        raise KeyError(f\"No TeXSmith extension named '{name}'.\") from exc\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.load_markdown_extension","title":"load_markdown_extension","text":"<pre><code>load_markdown_extension(name: str, **config: Any) -&gt; Any\n</code></pre> <p>Instantiate a Python-Markdown extension by slug or qualified name.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def load_markdown_extension(name: str, **config: Any) -&gt; Any:\n    \"\"\"Instantiate a Python-Markdown extension by slug or qualified name.\"\"\"\n    spec = get_extension_spec(name)\n    factory: Callable[..., Any] = _load_attribute(spec.markdown_entry)\n    return factory(**config)\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.load_mkdocs_plugin","title":"load_mkdocs_plugin","text":"<pre><code>load_mkdocs_plugin(name: str) -&gt; type[Any] | None\n</code></pre> <p>Return the MkDocs plugin class for an extension, if any.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def load_mkdocs_plugin(name: str) -&gt; type[Any] | None:\n    \"\"\"Return the MkDocs plugin class for an extension, if any.\"\"\"\n    spec = get_extension_spec(name)\n    if not spec.mkdocs_entry:\n        return None\n    plugin_cls: type[Any] = _load_attribute(spec.mkdocs_entry)\n    return plugin_cls\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.register_all_renderers","title":"register_all_renderers","text":"<pre><code>register_all_renderers(renderer: object) -&gt; None\n</code></pre> <p>Register every available renderer hook on the provided renderer.</p> Source code in <code>src/texsmith/extensions/__init__.py</code> <pre><code>def register_all_renderers(renderer: object) -&gt; None:\n    \"\"\"Register every available renderer hook on the provided renderer.\"\"\"\n    for spec in _EXTENSIONS.values():\n        if not spec.renderer_entry:\n            continue\n        register: Callable[[object], None] = _load_attribute(spec.renderer_entry)\n        register(renderer)\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.missing_footnotes.MissingFootnotesExtension","title":"MissingFootnotesExtension","text":"<pre><code>MissingFootnotesExtension(**kwargs: Any)\n</code></pre> <p>               Bases: <code>Extension</code></p> <p>Detect footnote references lacking explicit definitions.</p> Source code in <code>src/texsmith/extensions/missing_footnotes.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    self.config = {\n        \"element\": [\"texsmith-missing-footnote\", \"Tag inserted for missing notes.\"],\n        \"text_template\": [\n            \"{id}\",\n            \"Fallback text rendered for missing notes (can reference {id}).\",\n        ],\n        \"css_class\": [\"\", \"CSS class applied to placeholder nodes.\"],\n        \"link_to_list\": [\n            False,\n            \"When true, link to the generated footnote list despite the absence.\",\n        ],\n        \"data_attribute\": [\n            \"data-footnote-id\",\n            \"Custom attribute storing the missing footnote identifier.\",\n        ],\n    }\n    super().__init__(**kwargs)\n    self._footnotes_ext: FootnoteExtension | None = None\n    self._patched_pattern = False\n    self.missing_ids: set[str] = set()\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.missing_footnotes.MissingFootnotesExtension.build_placeholder","title":"build_placeholder","text":"<pre><code>build_placeholder(\n    identifier: str, pattern: Any\n) -&gt; ElementTree.Element\n</code></pre> <p>Construct the XML placeholder inserted for missing footnotes.</p> Source code in <code>src/texsmith/extensions/missing_footnotes.py</code> <pre><code>def build_placeholder(self, identifier: str, pattern: Any) -&gt; ElementTree.Element:\n    \"\"\"Construct the XML placeholder inserted for missing footnotes.\"\"\"\n    element_name = self.getConfig(\"element\")\n    node = ElementTree.Element(element_name)\n\n    css_class = self.getConfig(\"css_class\")\n    if css_class:\n        node.set(\"class\", css_class)\n\n    data_attribute = self.getConfig(\"data_attribute\")\n    if data_attribute:\n        node.set(data_attribute, identifier)\n\n    text = self.getConfig(\"text_template\").format(id=identifier)\n    if self.getConfig(\"link_to_list\"):\n        footnote_extension = self._get_footnotes_extension(pattern.md)\n        separator = footnote_extension.get_separator() if footnote_extension else \":\"\n        anchor = ElementTree.SubElement(node, \"a\")\n        if css_class:\n            anchor.set(\"class\", css_class)\n        anchor.set(\"href\", f\"#fn{separator}{identifier}\")\n        anchor.text = text\n    else:\n        node.text = text\n\n    return node\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.missing_footnotes.MissingFootnotesExtension.extendMarkdown","title":"extendMarkdown","text":"<pre><code>extendMarkdown(md: Any) -&gt; None\n</code></pre> <p>Patch the inline footnote processor to capture missing notes.</p> Source code in <code>src/texsmith/extensions/missing_footnotes.py</code> <pre><code>def extendMarkdown(self, md: Any) -&gt; None:  # noqa: N802 - markdown hook\n    \"\"\"Patch the inline footnote processor to capture missing notes.\"\"\"\n    md.registerExtension(self)\n    if self._patched_pattern:\n        return\n\n    pattern = self._resolve_footnote_pattern(md)\n    if pattern is None:\n        raise RuntimeError(\n            \"MissingFootnotesExtension requires the 'footnotes' extension to be \"\n            \"registered beforehand.\"\n        )\n\n    original_handle = pattern.handleMatch\n    extension = self\n\n    def patched_handle(self_pattern: Any, match: Any, data: Any) -&gt; Any:\n        result = original_handle(match, data)\n        if result and result[0] is not None:\n            return result\n\n        footnote_id = match.group(1)\n        extension.missing_ids.add(footnote_id)\n        node = extension.build_placeholder(footnote_id, self_pattern)\n        return node, match.start(0), match.end(0)\n\n    pattern.handleMatch = MethodType(patched_handle, pattern)\n    self._patched_pattern = True\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.missing_footnotes.MissingFootnotesExtension.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset cached state before each Markdown conversion.</p> Source code in <code>src/texsmith/extensions/missing_footnotes.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset cached state before each Markdown conversion.\"\"\"\n    self.missing_ids.clear()\n</code></pre>"},{"location":"api/markdown/#texsmith.extensions.missing_footnotes.makeExtension","title":"makeExtension","text":"<pre><code>makeExtension(**kwargs: Any) -&gt; MissingFootnotesExtension\n</code></pre> <p>Entry point exposed to Python-Markdown.</p> Source code in <code>src/texsmith/extensions/missing_footnotes.py</code> <pre><code>def makeExtension(**kwargs: Any) -&gt; MissingFootnotesExtension:  # noqa: N802 - markdown hook\n    \"\"\"Entry point exposed to Python-Markdown.\"\"\"\n    return MissingFootnotesExtension(**kwargs)\n</code></pre>"},{"location":"api/plugins/","title":"Plugin API","text":"<p>Plugins bundle opinionated handler collections so you can enable MkDocs-specific behavior (Material tabs, cards, callouts) or ship your own HTML post-processors without patching the core engine.</p> <p><code>texsmith.plugins</code> exposes a namespace package populated by the MkDocs hook in <code>docs/hooks/mkdocs_hooks.py</code>. Importing a plugin module registers its handlers via the standard <code>@renders</code> decorator\u2014no extra registry required.</p>"},{"location":"api/plugins/#loading-plugins","title":"Loading plugins","text":"<pre><code># ensure plugin handlers are registered\nimport texsmith.plugins.material  # noqa: F401\n\nfrom texsmith import Document, convert_documents\n\nbundle = convert_documents([Document.from_markdown(Path(\"intro.md\"))])\n</code></pre> <p>When running <code>texsmith</code>, use the <code>--enable-extension</code> or MkDocs plugin configuration to import modules before TeXSmith executes. For example, add the following to your MkDocs <code>hooks</code> file:</p> <pre><code>def on_config(config):\n    import texsmith.plugins.material  # registers Material handlers\n    return config\n</code></pre>"},{"location":"api/plugins/#authoring-your-own-plugin","title":"Authoring your own plugin","text":"<ol> <li>Create a module (e.g., <code>texsmith.plugins.acme</code>) and import any handlers that    <code>@renders</code> functions depend on.</li> <li>Declare entry points or instruct consumers to <code>import texsmith.plugins.acme</code>    before rendering.</li> <li>Optionally provide a MkDocs plugin/hook so documentation builds load your    plugin automatically, mirroring what TeXSmith\u2019s docs do with the Material    helpers.</li> </ol> <p>Keep plugin modules small and focused; most behaviour belongs in dedicated handler modules under <code>texsmith.adapters.handlers</code>.</p>"},{"location":"api/plugins/#reference","title":"Reference","text":"<p>Compatibility layer exposing plugin integrations to documentation.</p> <p>TeXSmith consolidated its plugin utilities under <code>texsmith.adapters.plugins</code>.  mkdocstrings still references the historical <code>texsmith.plugins</code> namespace, so we re-export the maintained modules here to keep the public import path available.</p> <p>Optional handlers for MkDocs Material specific constructs.</p>"},{"location":"api/plugins/#texsmith.plugins.material.register","title":"register","text":"<pre><code>register(renderer: Any) -&gt; None\n</code></pre> <p>Register Material-specific exercise and epigraph handlers.</p> Source code in <code>src/texsmith/adapters/plugins/material.py</code> <pre><code>def register(renderer: Any) -&gt; None:\n    \"\"\"Register Material-specific exercise and epigraph handlers.\"\"\"\n    renderer.register(render_exercise_div)\n    renderer.register(render_exercise_details)\n    renderer.register(render_epigraph)\n</code></pre>"},{"location":"api/plugins/#texsmith.plugins.material.render_epigraph","title":"render_epigraph","text":"<pre><code>render_epigraph(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render Material epigraph blockquotes using the LATEX epigraph macro.</p> Source code in <code>src/texsmith/adapters/plugins/material.py</code> <pre><code>@renders(\n    \"blockquote\",\n    phase=RenderPhase.POST,\n    priority=10,\n    name=\"material_epigraphs\",\n    auto_mark=False,\n)\ndef render_epigraph(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render Material epigraph blockquotes using the LaTeX epigraph macro.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"epigraph\" not in classes:\n        return\n\n    source = None\n    if footer := element.find(\"footer\"):\n        source = footer.get_text(strip=True)\n        footer.decompose()\n\n    text = element.get_text(strip=False)\n    latex = context.formatter.epigraph(text=text, source=source)\n    node = mark_processed(NavigableString(latex))\n    context.mark_processed(element)\n    context.suppress_children(element)\n    element.replace_with(node)\n</code></pre>"},{"location":"api/plugins/#texsmith.plugins.material.render_exercise_details","title":"render_exercise_details","text":"<pre><code>render_exercise_details(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render exercise blocks authored using  markup. Source code in <code>src/texsmith/adapters/plugins/material.py</code> <pre><code>@renders(\n    \"details\",\n    phase=RenderPhase.POST,\n    priority=56,\n    name=\"material_exercise_details\",\n    nestable=False,\n)\ndef render_exercise_details(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render exercise blocks authored using &lt;details&gt; markup.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"exercise\" not in classes:\n        return\n\n    title = \"\"\n    if summary := element.find(\"summary\"):\n        title = summary.get_text(strip=True)\n        summary.decompose()\n\n    _render_exercise(element, context, classes=classes, title=title or \"\")\n</code></pre>"},{"location":"api/plugins/#texsmith.plugins.material.render_exercise_div","title":"render_exercise_div","text":"<pre><code>render_exercise_div(\n    element: Tag, context: RenderContext\n) -&gt; None\n</code></pre> <p>Render Material exercise admonitions into LATEX callouts.</p> Source code in <code>src/texsmith/adapters/plugins/material.py</code> <pre><code>@renders(\n    \"div\",\n    phase=RenderPhase.POST,\n    priority=51,\n    name=\"material_exercise_admonition\",\n    nestable=False,\n)\ndef render_exercise_div(element: Tag, context: RenderContext) -&gt; None:\n    \"\"\"Render Material exercise admonitions into LaTeX callouts.\"\"\"\n    classes = gather_classes(element.get(\"class\"))\n    if \"admonition\" not in classes or \"exercise\" not in classes:\n        return\n\n    title = base_admonitions._extract_title(  # noqa: SLF001\n        element.find(\"p\", class_=\"admonition-title\")\n    )\n    _render_exercise(element, context, classes=classes, title=title)\n</code></pre>"},{"location":"api/transformers/","title":"Transformers","text":"<p>Conversion registry exposing high-level helpers for assets.</p> <p>Primitives used by asset converter strategies.</p> <p>Concrete converter strategies with caching and error handling.</p> <p>Utility helpers shared across transformer strategies.</p>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterRegistry","title":"ConverterRegistry","text":"<pre><code>ConverterRegistry()\n</code></pre> <p>Registry storing converter strategies.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._strategies: dict[str, ConverterStrategy] = {}\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterRegistry.convert","title":"convert","text":"<pre><code>convert(\n    name: str,\n    source: Path | str,\n    *,\n    output_dir: Path,\n    **options: Any,\n) -&gt; Any\n</code></pre> <p>Execute a converter strategy with the provided arguments.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def convert(\n    self,\n    name: str,\n    source: Path | str,\n    *,\n    output_dir: Path,\n    **options: Any,\n) -&gt; Any:\n    \"\"\"Execute a converter strategy with the provided arguments.\"\"\"\n    strategy = self.get(name)\n    return strategy(source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; ConverterStrategy\n</code></pre> <p>Return a registered converter strategy or raise an execution error.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def get(self, name: str) -&gt; ConverterStrategy:\n    \"\"\"Return a registered converter strategy or raise an execution error.\"\"\"\n    try:\n        return self._strategies[name]\n    except KeyError as exc:  # pragma: no cover - defensive\n        raise TransformerExecutionError(f\"No converter registered for '{name}'\") from exc\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterRegistry.is_registered","title":"is_registered","text":"<pre><code>is_registered(name: str) -&gt; bool\n</code></pre> <p>Return True when a converter has been registered under the given name.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def is_registered(self, name: str) -&gt; bool:\n    \"\"\"Return True when a converter has been registered under the given name.\"\"\"\n    return name in self._strategies\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterRegistry.register","title":"register","text":"<pre><code>register(name: str, strategy: ConverterStrategy) -&gt; None\n</code></pre> <p>Register a converter strategy under a unique name.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def register(self, name: str, strategy: ConverterStrategy) -&gt; None:\n    \"\"\"Register a converter strategy under a unique name.\"\"\"\n    self._strategies[name] = strategy\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.ConverterStrategy","title":"ConverterStrategy","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by concrete converter strategies.</p>"},{"location":"api/transformers/#texsmith.adapters.transformers.DrawioToPdfStrategy","title":"DrawioToPdfStrategy","text":"<pre><code>DrawioToPdfStrategy(\n    image: str = \"rlespinasse/drawio-desktop-headless\",\n)\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Convert draw.io diagrams using selectable backends (playwright, local, docker).</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"rlespinasse/drawio-desktop-headless\",\n) -&gt; None:\n    super().__init__(\"drawio\")\n    self.image = image\n    self.export_url = _EXPORT3_URL\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.MermaidToPdfStrategy","title":"MermaidToPdfStrategy","text":"<pre><code>MermaidToPdfStrategy(\n    image: str = \"minlag/mermaid-cli\",\n    *,\n    default_theme: str = \"neutral\",\n)\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Render Mermaid diagrams to PDF using the official CLI image.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"minlag/mermaid-cli\",\n    *,\n    default_theme: str = \"neutral\",\n) -&gt; None:\n    super().__init__(\"mermaid\")\n    self.image = image\n    self.default_theme = default_theme\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.drawio2pdf","title":"drawio2pdf","text":"<pre><code>drawio2pdf(\n    source: Path | str, output_dir: Path, **options: Any\n) -&gt; Path\n</code></pre> <p>Convert draw.io diagrams to PDF.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def drawio2pdf(source: Path | str, output_dir: Path, **options: Any) -&gt; Path:\n    \"\"\"Convert draw.io diagrams to PDF.\"\"\"\n    return registry.convert(\"drawio\", source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.fetch_image","title":"fetch_image","text":"<pre><code>fetch_image(\n    url: str, output_dir: Path, **options: Any\n) -&gt; Path\n</code></pre> <p>Fetch a remote image and normalise it to PDF.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def fetch_image(url: str, output_dir: Path, **options: Any) -&gt; Path:\n    \"\"\"Fetch a remote image and normalise it to PDF.\"\"\"\n    return registry.convert(\"fetch-image\", url, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.get_pdf_page_sizes","title":"get_pdf_page_sizes","text":"<pre><code>get_pdf_page_sizes(\n    source: Path | str, **options: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Inspect a PDF and return structured metadata.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def get_pdf_page_sizes(source: Path | str, **options: Any) -&gt; dict[str, Any]:\n    \"\"\"Inspect a PDF and return structured metadata.\"\"\"\n    output_dir = options.pop(\n        \"output_dir\", Path(source).parent if isinstance(source, Path) else Path.cwd()\n    )\n    return registry.convert(\"pdf-metadata\", source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.has_converter","title":"has_converter","text":"<pre><code>has_converter(name: str) -&gt; bool\n</code></pre> <p>Return True when a converter strategy is currently registered.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def has_converter(name: str) -&gt; bool:\n    \"\"\"Return True when a converter strategy is currently registered.\"\"\"\n    return registry.is_registered(name)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.image2pdf","title":"image2pdf","text":"<pre><code>image2pdf(\n    source: Path | str, output_dir: Path, **options: Any\n) -&gt; Path\n</code></pre> <p>Convert bitmap images to PDF.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def image2pdf(source: Path | str, output_dir: Path, **options: Any) -&gt; Path:\n    \"\"\"Convert bitmap images to PDF.\"\"\"\n    return registry.convert(\"image\", source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.mermaid2pdf","title":"mermaid2pdf","text":"<pre><code>mermaid2pdf(\n    source: Path | str, output_dir: Path, **options: Any\n) -&gt; Path\n</code></pre> <p>Convert Mermaid diagrams to PDF.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def mermaid2pdf(source: Path | str, output_dir: Path, **options: Any) -&gt; Path:\n    \"\"\"Convert Mermaid diagrams to PDF.\"\"\"\n    return registry.convert(\"mermaid\", source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.register_converter","title":"register_converter","text":"<pre><code>register_converter(\n    name: str, strategy: ConverterStrategy\n) -&gt; None\n</code></pre> <p>Expose a helper to register external strategies.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def register_converter(name: str, strategy: ConverterStrategy) -&gt; None:\n    \"\"\"Expose a helper to register external strategies.\"\"\"\n    registry.register(name, strategy)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.svg2pdf","title":"svg2pdf","text":"<pre><code>svg2pdf(\n    source: Path | str, output_dir: Path, **options: Any\n) -&gt; Path\n</code></pre> <p>Convert SVG assets to PDF.</p> Source code in <code>src/texsmith/adapters/transformers/__init__.py</code> <pre><code>def svg2pdf(source: Path | str, output_dir: Path, **options: Any) -&gt; Path:\n    \"\"\"Convert SVG assets to PDF.\"\"\"\n    return registry.convert(\"svg\", source, output_dir=output_dir, **options)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.base.CachedConversionStrategy","title":"CachedConversionStrategy","text":"<pre><code>CachedConversionStrategy(\n    namespace: str,\n    *,\n    max_attempts: int = 3,\n    backoff: Callable[[int], float] | None = None,\n)\n</code></pre> <p>Base class that adds caching and retry/backoff policies.</p> Source code in <code>src/texsmith/adapters/transformers/base.py</code> <pre><code>def __init__(\n    self,\n    namespace: str,\n    *,\n    max_attempts: int = 3,\n    backoff: Callable[[int], float] | None = None,\n) -&gt; None:\n    self.namespace = namespace\n    self.max_attempts = max_attempts\n    self.backoff = backoff or exponential_backoff()\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.base.CachedConversionStrategy.output_suffix","title":"output_suffix","text":"<pre><code>output_suffix(source: Any, options: dict[str, Any]) -&gt; str\n</code></pre> <p>Allow subclasses to customise the output suffix.</p> Source code in <code>src/texsmith/adapters/transformers/base.py</code> <pre><code>def output_suffix(self, source: Any, options: dict[str, Any]) -&gt; str:\n    \"\"\"Allow subclasses to customise the output suffix.\"\"\"\n    return self.suffix\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.base.ConverterStrategy","title":"ConverterStrategy","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol implemented by concrete converter strategies.</p>"},{"location":"api/transformers/#texsmith.adapters.transformers.base.exponential_backoff","title":"exponential_backoff","text":"<pre><code>exponential_backoff(\n    base_delay: float = 0.5,\n    factor: float = 2.0,\n    max_delay: float = 5.0,\n) -&gt; Callable[[int], float]\n</code></pre> <p>Return a simple exponential backoff policy.</p> Source code in <code>src/texsmith/adapters/transformers/base.py</code> <pre><code>def exponential_backoff(\n    base_delay: float = 0.5, factor: float = 2.0, max_delay: float = 5.0\n) -&gt; Callable[[int], float]:\n    \"\"\"Return a simple exponential backoff policy.\"\"\"\n\n    def policy(attempt: int) -&gt; float:\n        delay = base_delay * (factor ** (attempt - 1))\n        return min(delay, max_delay)\n\n    return policy\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.DrawioToPdfStrategy","title":"DrawioToPdfStrategy","text":"<pre><code>DrawioToPdfStrategy(\n    image: str = \"rlespinasse/drawio-desktop-headless\",\n)\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Convert draw.io diagrams using selectable backends (playwright, local, docker).</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"rlespinasse/drawio-desktop-headless\",\n) -&gt; None:\n    super().__init__(\"drawio\")\n    self.image = image\n    self.export_url = _EXPORT3_URL\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.FetchImageStrategy","title":"FetchImageStrategy","text":"<pre><code>FetchImageStrategy(timeout: float = 10.0)\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Fetch a remote image, normalise it to PDF, and cache the result.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(self, timeout: float = 10.0) -&gt; None:\n    super().__init__(\"fetch-image\")\n    self.timeout = timeout\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.ImageToPdfStrategy","title":"ImageToPdfStrategy","text":"<pre><code>ImageToPdfStrategy()\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Convert bitmap images to PDF using Pillow.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"image\")\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.MermaidToPdfStrategy","title":"MermaidToPdfStrategy","text":"<pre><code>MermaidToPdfStrategy(\n    image: str = \"minlag/mermaid-cli\",\n    *,\n    default_theme: str = \"neutral\",\n)\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Render Mermaid diagrams to PDF using the official CLI image.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"minlag/mermaid-cli\",\n    *,\n    default_theme: str = \"neutral\",\n) -&gt; None:\n    super().__init__(\"mermaid\")\n    self.image = image\n    self.default_theme = default_theme\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.NotConfiguredStrategy","title":"NotConfiguredStrategy","text":"<pre><code>NotConfiguredStrategy(name: str)\n</code></pre> <p>Strategy used to signal that a converter must be provided by the host.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.PdfMetadataStrategy","title":"PdfMetadataStrategy","text":"<p>Inspect PDF files and expose structural metadata.</p>"},{"location":"api/transformers/#texsmith.adapters.transformers.strategies.SvgToPdfStrategy","title":"SvgToPdfStrategy","text":"<pre><code>SvgToPdfStrategy()\n</code></pre> <p>               Bases: <code>CachedConversionStrategy</code></p> <p>Convert inline SVG payloads or files to PDF using CairoSVG.</p> Source code in <code>src/texsmith/adapters/transformers/strategies.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\"svg\")\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.utils.normalise_pdf_version","title":"normalise_pdf_version","text":"<pre><code>normalise_pdf_version(\n    pdf_path: Path, *, target_version: str = \"1.5\"\n) -&gt; None\n</code></pre> <p>Re-write a PDF so its header advertises the requested version.</p> Source code in <code>src/texsmith/adapters/transformers/utils.py</code> <pre><code>def normalise_pdf_version(pdf_path: Path, *, target_version: str = \"1.5\") -&gt; None:\n    \"\"\"Re-write a PDF so its header advertises the requested version.\"\"\"\n    try:\n        import pypdf  # type: ignore[import]\n    except ImportError as exc:  # pragma: no cover - optional dependency\n        msg = \"pypdf is required to normalise PDF artefacts.\"\n        raise TransformerExecutionError(msg) from exc\n\n    try:\n        reader = pypdf.PdfReader(str(pdf_path))\n    except Exception as exc:  # pragma: no cover - defensive\n        msg = f\"Failed to read generated PDF '{pdf_path}': {exc}\"\n        raise TransformerExecutionError(msg) from exc\n\n    # Skip rewriting when already on the desired version.\n    header = getattr(reader, \"pdf_header\", b\"\")\n    if isinstance(header, bytes):\n        header_text = header.decode(\"latin-1\", \"ignore\")\n        if header_text.startswith(\"%PDF-\"):\n            current_version = header_text[5:].strip()\n            if current_version == target_version:\n                return\n\n    writer = pypdf.PdfWriter()\n    for page in reader.pages:\n        writer.add_page(page)\n    writer.pdf_header = f\"%PDF-{target_version}\\n\"\n\n    metadata = reader.metadata or {}\n    filtered_metadata = {k: v for k, v in metadata.items() if isinstance(v, str)}\n    if filtered_metadata:\n        writer.add_metadata(filtered_metadata)\n\n    tmp_path = pdf_path.with_suffix(pdf_path.suffix + \".tmp\")\n    try:\n        with tmp_path.open(\"wb\") as handle:\n            writer.write(handle)\n    except Exception as exc:  # pragma: no cover - defensive\n        msg = f\"Failed to rewrite PDF '{pdf_path}' to version {target_version}: {exc}\"\n        raise TransformerExecutionError(msg) from exc\n\n    tmp_path.replace(pdf_path)\n</code></pre>"},{"location":"api/transformers/#texsmith.adapters.transformers.utils.points_to_mm","title":"points_to_mm","text":"<pre><code>points_to_mm(points: float) -&gt; float\n</code></pre> <p>Convert PDF points to millimetres.</p> Source code in <code>src/texsmith/adapters/transformers/utils.py</code> <pre><code>def points_to_mm(points: float) -&gt; float:\n    \"\"\"Convert PDF points to millimetres.\"\"\"\n    return points * 25.4 / 72\n</code></pre>"},{"location":"cli/","title":"TeXSmith Command-Line Interface","text":"<p>TeXSmith ships with a feature-rich CLI that lets you convert Markdown or HTML into LATEX, compile PDFs, and inspect bibliography files directly from a terminal. The CLI now exposes a single command: <code>texsmith</code>. Every flag hangs off that root entry point.</p> <pre><code>$ texsmith --help\n\n Usage: texsmith [OPTIONS] [INPUT...]\n\n Convert MkDocs documents into LaTeX artefacts and optionally build PDFs.\n\n\u256d\u2500 Input Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502   inputs      [INPUT...]  Conversion inputs such as Markdown (.md) or HTML   \u2502\n\u2502                           (.html) source documents. Optionally, BibTeX files \u2502\n\u2502                           (.bib) for citation processing.                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version                                Show the TeXSmith version and exit. \u2502\n\u2502 --diagrams-backend              BACKEND  Force the backend for diagram       \u2502\n\u2502                                          conversion (draw.io, mermaid):      \u2502\n\u2502                                          playwright, local, or docker        \u2502\n\u2502                                          (auto-default).                     \u2502\n\u2502 --embed                                  Embed converted documents into the  \u2502\n\u2502                                          main document instead linking them  \u2502\n\u2502                                          with \\input.                        \u2502\n\u2502 --classic-output                         Display raw latexmk output without  \u2502\n\u2502                                          parsing.                            \u2502\n\u2502 --build                 -b               Invoke latexmk after rendering to   \u2502\n\u2502                                          compile the resulting LaTeX         \u2502\n\u2502                                          project.                            \u2502\n\u2502 --legacy-latex-accents                   Escape accented characters and      \u2502\n\u2502                                          ligatures with legacy LaTeX macros  \u2502\n\u2502                                          instead of emitting Unicode glyphs  \u2502\n\u2502                                          (defaults to Unicode output).       \u2502\n\u2502 --template-scaffold             DEST     Copy the selected template into     \u2502\n\u2502                                          DEST and exit.                      \u2502\n\u2502 --install-completion                     Install completion for the current  \u2502\n\u2502                                          shell.                              \u2502\n\u2502 --show-completion                        Show completion for the current     \u2502\n\u2502                                          shell, to copy it or customize the  \u2502\n\u2502                                          installation.                       \u2502\n\u2502 --help                                   Show this message and exit.         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Diagnostics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --list-extensions                     List Markdown extensions enabled by    \u2502\n\u2502                                       default and exit.                      \u2502\n\u2502 --list-templates                      List available templates (builtin,     \u2502\n\u2502                                       entry-point, and local) and exit.      \u2502\n\u2502 --list-bibliography                   Print bibliography details from        \u2502\n\u2502                                       provided .bib files and exit.          \u2502\n\u2502 --verbose            -v      INTEGER  Increase CLI verbosity. Combine        \u2502\n\u2502                                       multiple times for additional          \u2502\n\u2502                                       diagnostics.                           \u2502\n\u2502                                       [default: 0]                           \u2502\n\u2502 --debug                               Show full tracebacks when an           \u2502\n\u2502                                       unexpected error occurs.               \u2502\n\u2502 --debug-rules                         Display the ordered list of registered \u2502\n\u2502                                       render rules.                          \u2502\n\u2502 --debug-html                          Persist intermediate HTML snapshots    \u2502\n\u2502                                       (inherits from --debug when omitted).  \u2502\n\u2502 --open-log                            Open the latexmk log with the system   \u2502\n\u2502                                       viewer when compilation fails.         \u2502\n\u2502 --dump-snippets              DIR      Copy snippet render sources (tex, aux  \u2502\n\u2502                                       files) into DIR for inspection.        \u2502\n\u2502 --template-info                       Display template metadata and exit.    \u2502\n\u2502 --fonts-info                          Display a summary of fallback fonts    \u2502\n\u2502                                       detected during rendering.             \u2502\n\u2502 --print-context                       Print resolved template context        \u2502\n\u2502                                       emitters/consumers and exit.           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --output,--output-dir  -o      PATH  Output file or directory. Defaults to   \u2502\n\u2502                                      stdout unless a template is used.       \u2502\n\u2502 --makefile-deps        -M            Emit a Makefile-compatible .d           \u2502\n\u2502                                      dependency file when building PDFs.     \u2502\n\u2502 --html                               Output intermediate HTML instead of     \u2502\n\u2502                                      LaTeX/PDF.                              \u2502\n\u2502 --engine               -e      TEXT  LaTeX engine backend to use when        \u2502\n\u2502                                      building (tectonic, lualatex, xelatex). \u2502\n\u2502                                      [default: tectonic]                     \u2502\n\u2502 --system               -S            Use the system Tectonic binary instead  \u2502\n\u2502                                      of the bundled download.                \u2502\n\u2502 --isolate                            Use a per-render TeX cache inside the   \u2502\n\u2502                                      output directory instead of the shared  \u2502\n\u2502                                      ~/.cache/texsmith cache.                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Input Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --selector             TEXT  CSS selector to extract the MkDocs article      \u2502\n\u2502                              content.                                        \u2502\n\u2502                              [default: article.md-content__inner]            \u2502\n\u2502 --full-document              Disable article extraction and render the       \u2502\n\u2502                              entire HTML file.                               \u2502\n\u2502 --parser               TEXT  BeautifulSoup parser backend to use (defaults   \u2502\n\u2502                              to \"html.parser\").                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Structure \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --base-level           TEXT  Base heading level relative to the template     \u2502\n\u2502                              (e.g. 1 or 'section').                          \u2502\n\u2502                              [default: 0]                                    \u2502\n\u2502 --strip-heading              Drop the first document heading from the        \u2502\n\u2502                              rendered content.                               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Template \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --no-promote-title                Disable promotion of the first heading to  \u2502\n\u2502                                   document title.                            \u2502\n\u2502 --no-title                        Disable title generation even when         \u2502\n\u2502                                   metadata provides one.                     \u2502\n\u2502 --template          -t      TEXT  Select a LaTeX template to use during      \u2502\n\u2502                                   conversion. Accepts a local path, entry    \u2502\n\u2502                                   point, or built-in slug such as 'article'  \u2502\n\u2502                                   or 'letter'.                               \u2502\n\u2502 --enable-fragment   -f      TEXT  Enable an additional fragment by name (can \u2502\n\u2502                                   be repeated).                              \u2502\n\u2502 --disable-fragment  -F      TEXT  Disable a fragment by name (can be         \u2502\n\u2502                                   repeated).                                 \u2502\n\u2502 --attribute         -a      TEXT  Override template attributes as key=value  \u2502\n\u2502                                   pairs (e.g. -a emoji=color).               \u2502\n\u2502 --slot              -s      TEXT  Inject a document section into a template  \u2502\n\u2502                                   slot using 'slot:Section'. Repeat to map   \u2502\n\u2502                                   multiple sections.                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Rendering \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --no-fallback-converters                Disable registration of placeholder  \u2502\n\u2502                                         converters when Docker is            \u2502\n\u2502                                         unavailable.                         \u2502\n\u2502 --no-copy-assets          -C            Disable copying of remote assets to  \u2502\n\u2502                                         the output directory.                \u2502\n\u2502 --convert-assets                        Convert bitmap assets (PNG/JPEG) to  \u2502\n\u2502                                         PDF even when LaTeX supports the     \u2502\n\u2502                                         original format.                     \u2502\n\u2502 --hash-assets                           Hash stored asset filenames instead  \u2502\n\u2502                                         of preserving their original names.  \u2502\n\u2502 --http-user-agent                 TEXT  User-Agent header used when fetching \u2502\n\u2502                                         remote assets like images.           \u2502\n\u2502                                         [env var: TEXSMITH_HTTP_USER_AGENT]  \u2502\n\u2502 --manifest                -m            Generate a manifest.json file        \u2502\n\u2502                                         alongside the LaTeX output.          \u2502\n\u2502 --language                -l      TEXT  Language code passed to babel        \u2502\n\u2502                                         (defaults to metadata or english).   \u2502\n\u2502 --enable-extension        -x      TEXT  Additional Markdown extensions to    \u2502\n\u2502                                         enable (comma or space separated     \u2502\n\u2502                                         values are accepted).                \u2502\n\u2502 --disable-extension       -X      TEXT  Markdown extensions to disable.      \u2502\n\u2502                                         Provide a comma separated list or    \u2502\n\u2502                                         repeat the option multiple times.    \u2502\n\u2502                                         Use --list-extensions to see the     \u2502\n\u2502                                         extensions enabled by default.       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/#options","title":"Options","text":""},{"location":"cli/#general-options","title":"General Options","text":"<code>--diagrams-backend</code> When TeXSmith discovers diagrams in your Markdown (e.g., Mermaid or Draw.io), it needs to convert them into image files that LATEX can include. This option forces a specific backend for that conversion, overriding the automatic selection logic. Supported backends include <code>playwright</code> (headless browser), <code>local</code> (locally installed CLI tools), and <code>docker</code> (containerized tools). <code>--embed</code> By default, TeXSmith renders converted documents as separate LATEX files and links them into the main document using <code>\\input{}</code>. This option inlines the converted LATEX documents directly into the main document body instead. This can be useful for simpler projects where a single <code>.tex</code> file is preferred. <code>--classic-output</code> When building PDFs, TeXSmith normally parses and structures the output from <code>latexmk</code> to provide cleaner logs and richer diagnostics. This option disables that behavior and streams the raw <code>latexmk</code> output directly to your terminal. You can disable structured logs temporarily with this option. <code>--build</code> After rendering the LATEX document from your Markdown sources, invoke the default engine (<code>tectonic</code>) or the engine specified via <code>--engine</code> to compile the LATEX into a PDF. <code>--legacy-latex-accents</code> By default, TeXSmith emits Unicode characters for accented letters and ligatures (e.g., \u00e9, \u00f1, \u00e6) when generating LATEX output. This option switches to using legacy LATEX macros (e.g., <code>\\'{e}</code>, <code>\\~{n}</code>, <code>\\ae{}</code>) instead, which may be necessary for compatibility with older LATEX engines or templates. <code>--install-completion</code>, <code>--show-completion</code> Install or display shell completion scripts for the TeXSmith CLI. This enhances your terminal experience by providing auto-completion for commands and options. <code>--help</code> Show contextual help for the TeXSmith CLI, including available commands and options."},{"location":"cli/#diagnostics-options","title":"Diagnostics Options","text":"<code>--list-extensions</code> Print a list of all Markdown extensions that are enabled by default during conversion. This is useful for understanding how your Markdown will be processed. <code>--list-templates</code> List all discoverable templates, along with their origins and paths. <code>--list-bibliography</code> Display a summary of all bibliography entries found in the provided <code>.bib</code> files, front matter, or DOI links. This is useful for validating bibliography sources without performing a full document render. <code>--debug</code> Enable detailed debugging output for the CLI. This includes full Python tracebacks when unexpected exceptions occur, which can help diagnose issues during conversion or rendering. <code>--debug-rules</code> Print the ordered list of registered render rules that TeXSmith applies during conversion. This is useful for understanding the transformation pipeline. <code>--debug-html</code> Save intermediate HTML snapshots generated during the conversion process. This can help diagnose issues related to HTML parsing or content extraction. <code>--open-log</code> If LATEX compilation fails during the build step, automatically open the <code>latexmk</code> log file using the system's default viewer. This makes it easier to inspect compilation errors. <code>--template-info</code> Show manifest metadata for the template selected via <code>--template</code>, including its attributes, assets, and slots. <code>--fonts-info</code> After rendering, display a summary of the fonts used in the generated LATEX document, including any fallback fonts that were selected based on the document's language and content. <code>--print-context</code> Print the resolved template context, including all emitters and consumers, then exit. This is useful for debugging template rendering issues."},{"location":"cli/#output-options","title":"Output Options","text":"<code>--output</code>, <code>--output-dir</code> Specify the output file or directory for the rendered LATEX or compiled PDF. If no output path is provided, TeXSmith defaults to writing to <code>stdout</code> unless a template is used. <code>--makefile-deps</code> When building PDFs, generate a Makefile-compatible <code>.d</code> dependency file alongside the output. This can be useful for integrating TeXSmith into larger build systems. <code>--html</code> Instead of generating LATEX or PDF output, emit the intermediate HTML produced during the conversion process. This is useful for inspecting how your Markdown is transformed into HTML. <code>--engine</code> Specify the LATEX engine to use when compiling the rendered document into a PDF. Supported engines include <code>tectonic</code>, <code>lualatex</code>, and <code>xelatex</code>. The default is <code>tectonic</code>. <code>--system</code> Use the system-installed Tectonic binary instead of the bundled version provided by TeXSmith. This can be useful if you have a specific version of Tectonic installed or want to leverage system-wide configurations. <code>--isolate</code> By default, TeXSmith uses a shared cache located at <code>~/.cache/texsmith</code> to store compiled LATEX artifacts. This option creates a per-render cache inside the output directory, isolating the build environment for each project."},{"location":"cli/#input-handling-options","title":"Input Handling Options","text":"<code>--selector</code> When converting HTML documents (e.g., from MkDocs), this option specifies a CSS selector to extract the main article content. The default selector is <code>article.md-content__inner</code>, which targets the primary content area. <code>--full-document</code> Disable article extraction and render the entire HTML file as-is. This is useful when you want to convert a complete HTML document rather than just the main content. <code>--parser</code> Specify the BeautifulSoup parser backend to use when parsing HTML input. The default is <code>html.parser</code>, but you can choose other parsers like <code>lxml</code> if they are installed."},{"location":"cli/#structure-options","title":"Structure Options","text":"<code>--base-level</code> Set the base heading level for the document relative to the template. For example, if your template starts at level 1 (e.g., <code>\\section{}</code>), you can adjust the base level accordingly. The default is <code>0</code>. We use the convention where <code>-1</code> is <code>\\part{}</code>, <code>0</code> is <code>\\chapter{}</code>, <code>1</code> is <code>\\section{}</code>, and so on. <code>--strip-heading</code> Remove the first heading from the rendered content. This is useful when the first heading is redundant with the document title or when you want to avoid duplicate titles or keep the first heading as information only."},{"location":"cli/#template-options","title":"Template Options","text":"<code>--no-promote-title</code> By default, TeXSmith promotes the first heading in the document to be the title of the LATEX document. This option disables that behavior, keeping the first heading as part of the main content. If no title is found in metadata or front matter, no title will be generated. <code>--no-title</code> Disable title generation entirely, even if metadata or front matter provides a title. This is useful when you want to suppress the title page in the rendered document. <code>--template</code>, <code>-t</code> Select a LATEX template to use during conversion. You can provide a local path, an entry point, or a built-in slug such as <code>article</code>, <code>book</code>, or <code>letter</code>. <code>--attribute</code>, <code>-a</code> Override template attributes by providing key=value pairs. This allows you to customize template behavior without modifying the template files directly. You can repeat this option multiple times to set multiple attributes. <code>--slot</code>, <code>-s</code> Inject specific document sections into designated template slots using the syntax <code>slot:Section</code>. You can repeat this option multiple times to map multiple sections to different slots in the template."},{"location":"cli/#rendering-options","title":"Rendering Options","text":"<code>--no-fallback-converters</code> Disable the registration of placeholder converters that TeXSmith uses when Docker is unavailable. This ensures that only fully supported conversion paths are used. <code>--no-copy-assets</code>, <code>-C</code> Control whether remote assets (e.g., images, diagrams) are copied to the output directory during rendering. By default, assets are copied to ensure they are available for LATEX compilation. You can disable this behavior. <code>--convert-assets</code> Convert bitmap assets (e.g., PNG, JPEG) to PDF format even when LATEX supports the original format. This can improve compatibility and rendering quality in some cases. <code>--hash-assets</code> Hash the filenames of stored assets instead of preserving their original names. This helps avoid filename collisions when multiple assets with the same name are used in different documents. <code>--http-user-agent</code> Override the User-Agent header used when fetching remote assets (images, emoji). You can also set <code>TEXSMITH_HTTP_USER_AGENT</code> in the environment. <code>--manifest</code>, <code>-m</code> Generate a <code>manifest.json</code> file alongside the LATEX output, containing metadata about the rendered document, including input sources, template details, and rendering options. <code>--language</code>, <code>-l</code> Specify the language code to pass to the LATEX <code>babel</code> package. This affects hyphenation and language-specific typographic rules. If not provided, TeXSmith uses the language specified in the document metadata or defaults to English. <code>--enable-extension</code>, <code>-x</code> Enable additional Markdown extensions during conversion. You can repeat this option multiple times or provide a comma-separated list of extensions to activate. <code>--disable-extension</code>, <code>-X</code> Disable specific Markdown extensions during conversion. You can repeat this option multiple times or provide a comma-separated list of extensions to deactivate."},{"location":"cli/#quick-start","title":"Quick Start","text":"<pre><code># Generate LaTeX fragments from Markdown\ntexsmith intro.md --output build/\n\n# Render with a template and compile to PDF (default = Tectonic)\ntexsmith intro.md --template article --output-dir build/pdf --build\n\n# Inspect bibliography sources\ntexsmith references.bib --list-bibliography\n</code></pre> <p>Refer to <code>texsmith COMMAND --help</code> whenever you need the most up-to-date option list, defaults, and environment-specific notes.</p>"},{"location":"cli/#diagnostics","title":"Diagnostics","text":"<p>Every CLI invocation routes warnings, errors, and structured events through the <code>DiagnosticEmitter</code> interface. The Typer app instantiates a <code>CliEmitter</code>, so verbosity flags (<code>-v</code>) control how much detail reaches your terminal. Library consumers can provide their own emitter to capture the same diagnostics programmatically when embedding TeXSmith.</p>"},{"location":"cli/bibliography/","title":"Bibliography","text":""},{"location":"cli/bibliography/#add-bibliography-entries","title":"Add Bibliography Entries","text":"<p>To include bibliography entries in your document, provide one or more BibTeX files as inputs when running TeXSmith. TeXSmith will parse these files and integrate the references into your document during the conversion process. For example:</p> <pre><code>texsmith paper.md nature.bib ieee.bib -o paper.pdf\n</code></pre>"},{"location":"cli/bibliography/#list-bibliography-entries","title":"List Bibliography Entries","text":"<p>Use the <code>--list-bibliography</code> flag to inspect BibTeX files before running a conversion or build. It helps catch parsing issues, duplicate entries, and empty datasets early in your workflow. For example in the <code>paper</code> example project:</p> <pre><code>$ texsmith cheese.md cheese.bib --list-bibliography\n\n                    Bibliography Files\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File                                         \u2502 Entries \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 /home/ycr/texsmith/examples/paper/cheese.bib \u2502       2 \u2502\n\u2502 Total                                        \u2502       2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              Jaoac2019 (article)\n  Title    Determination of Moisture in Cheese and Cheese Products\n  Year     2019\n  Journal  Journal of AOAC INTERNATIONAL\n  Authors  Jr Bradley Robert L, Margaret A Vanderwarn\n  Sources  /home/ycr/texsmith/examples/paper/cheese.bib\n  Abstract Variables related to oven-drying samples of cheese and cheese\n           products to determine moisture...\n  Doi      10.1093/jaoac/84.2.570\n  Eprint   https://academic.oup.com/jaoac/article-pdf/84/2/570/32415847/jaoac\u2026\n  Issn     1060-3271\n  Month    11\n  Number   2\n  Pages    570-592\n  Url      https://doi.org/10.1093/jaoac/84.2.570\n  Volume   84\n\n\n                             Prentice1993 (inbook)\n  Title     Cheese Rheology\n  Year      1993\n  Authors   J. H. Prentice, K. R. Langley, R. J. Marshall\n  Sources   /home/ycr/texsmith/examples/paper/cheese.bib\n  Abstract  Rheology is formally defined as the study of the flow and\n            deformation of matter...\n  Address   Boston, MA\n  Booktitle Cheese: Chemistry, Physics and Microbiology: Volume 1 General\n            Aspects\n  Doi       10.1007/978-1-4615-2650-6_8\n  Isbn      978-1-4615-2650-6\n  Pages     303--340\n  Publisher Springer US\n  Url       https://doi.org/10.1007/978-1-4615-2650-6_8\n\n\n    Bibliography Summary\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Category          \u2502 Count \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Total entries     \u2502     2 \u2502\n\u2502 From cheese.bib   \u2502     2 \u2502\n\u2502 From front matter \u2502     0 \u2502\n\u2502 From DOI fetches  \u2502     0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/bibliography/#behaviour","title":"Behaviour","text":"<p>TeXSmith loads every provided <code>.bib</code> file using <code>pybtex</code> and analyzes their contents, checks for duplicate keys, and verifies parsing integrity. It emits warnings for any issues found and prints a summary table of the number of entries per file.</p> <p>The <code>--list-bibliography</code> flag has the following behavior:</p> <ul> <li>Prints a formatted table summarising the number of entries per file.</li> <li>Emits warnings for files that fail to parse, contain duplicate keys, or are empty.</li> <li>Highlights issues detected by TeXSmith\u2019s bibliography loader (e.g. conflicting entries sourced from multiple files).</li> <li>Exits before rendering anything else, so you can run it as a fast preflight step.</li> </ul>"},{"location":"cli/build/","title":"Build","text":"<p>To build your LATEX document into a PDF, use the <code>--build</code> (or <code>-b</code>) option. This command compiles the generated LATEX file using the default engine. TeXSmith uses <code>tectonic</code> by default as it is the only self-contained LATEX engine, but you can configure it to use <code>lualatex</code> or <code>xelatex</code> via <code>latexmk</code> if preferred. Here is an example of a simple document built with different engines:</p> <pre><code>$ uv run texsmith cheese.md cheese.bib -tarticle --build --engine=xelatex\n$ uv run texsmith cheese.md cheese.bib -tarticle --build --engine=lualatex\n$ uv run texsmith cheese.md cheese.bib -tarticle --build --engine=tectonic\n</code></pre>"},{"location":"cli/slots/","title":"Managing Slots","text":"<p>Slots are placeholders in the LATEX template where specific document sections can be injected. Use the <code>--slot</code> (or <code>-s</code>) option to map input documents to these slots. For example, to inject <code>abstract.md</code> into the <code>abstract</code> slot and <code>dedication.md</code> into the <code>dedication</code> slot of a book template, run:</p> <pre><code>texsmith abstract.md dedication.md chapter*.md \\\n  --template book \\\n  --slot abstract:abstract.md \\\n  --slot dedication:dedication.md\n</code></pre> <p>To see the available slots for a given template, use the <code>--template-info</code> flag:</p> <pre><code>$ uv run texsmith -tbook --template-info\n...\n                                     Slots\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \u2502         \u2502      Base \u2502         \u2502        \u2502  Effective \u2502   Strip   \u2502\n\u2502 Name       \u2502 Default \u2502     Level \u2502   Depth \u2502 Offset \u2502      Level \u2502  Heading  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 appendix   \u2502         \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    no     \u2502\n\u2502 backmatter \u2502         \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    no     \u2502\n\u2502 colophon   \u2502         \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    yes    \u2502\n\u2502 dedication \u2502         \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    yes    \u2502\n\u2502 frontmatt\u2026 \u2502         \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    no     \u2502\n\u2502 mainmatter \u2502    *    \u2502         - \u2502 chapter \u2502      0 \u2502          0 \u2502    no     \u2502\n\u2502 preface    \u2502         \u2502         0 \u2502       - \u2502      0 \u2502          0 \u2502    no     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can also extract sections from a single document using the <code>slot:Section Name</code> syntax. For example, to inject the \"Abstract\" section from <code>main.md</code> into the <code>abstract</code> slot:</p> <pre><code>texsmith main.md \\\n  --template article \\\n  --slot abstract:slot:Abstract\n</code></pre>"},{"location":"cli/templates/","title":"Templates","text":"<p>Templates are predefined LATEX document structures that dictate the overall layout, style, and organization of your final document. TeXSmith includes several built-in templates for common document types, and you can also create and use custom templates.</p>"},{"location":"cli/templates/#use-a-template","title":"Use a template","text":"<p>TeXSmith provides some templates out of the box to help you get started with common document types. You can specify a template using the <code>--template</code> (or <code>-t</code>) option followed by the template name.</p> <pre><code>texsmith document.md --template article\n</code></pre>"},{"location":"cli/templates/#listing-available-templates","title":"Listing Available Templates","text":"<p>To see the list of available templates, use the <code>--list-templates</code> flag:</p> <pre><code>\u279c uv run texsmith --list-templates\n                           Available Templates\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Name     \u2502 Origin  \u2502 Location                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 article  \u2502 builtin \u2502 /home/ycr/texsmith/src/texsmith/templates/article \u2502\n\u2502 book     \u2502 builtin \u2502 /home/ycr/texsmith/src/texsmith/templates/book    \u2502\n\u2502 letter   \u2502 builtin \u2502 /home/ycr/texsmith/src/texsmith/templates/letter  \u2502\n\u2502 snippet  \u2502 builtin \u2502 /home/ycr/texsmith/src/texsmith/templates/snippet \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each template comes with its own set of slots, styles, and configurations tailored for specific document types. For example, the <code>article</code> template is suitable for academic papers, while the <code>book</code> template is designed for longer documents with chapters and parts.</p>"},{"location":"cli/templates/#explore-template-details","title":"Explore Template Details","text":"<p>You can inspect the details of a specific template using the <code>--template-info</code> flag. This command provides information about the template's metadata, slots, attributes, and assets.</p> <pre><code>texsmith --template article --template-info\n</code></pre> <p>It will display a summary of the template, including:</p> <ul> <li>List of attributes and their types (e.g., authors, columns, date, language...)</li> <li>List of assets included in the template (e.g. style files, images...)</li> <li>List of fragments (<code>ts-geometry</code>, <code>ts-typesetting</code>, ...) that the template uses.</li> <li>List of slots available for content injection.</li> </ul>"},{"location":"cli/templates/#scaffolding-custom-templates","title":"Scaffolding Custom Templates","text":"<p>One goal of TeXSmith is to make it easy to create and share custom templates. You can scaffold a new template by copying an existing one and modifying it to suit your needs. Use the <code>--template-scaffold</code> flag to copy a template to a local directory:</p> <pre><code>texsmith --template article --template-scaffold my-custom-template/\n</code></pre> <p>Then edit the files in <code>my-custom-template/</code> to customize the layout, styles, and slots as needed, and use your custom template by specifying its path:</p> <pre><code>texsmith document.md --template ./my-custom-template/\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Great documentation shines brightest with real examples \u2014 so here are a few to get you started. These showcase TeXSmith\u2019s range across various document types and creative workflows:</p> <ul> <li>Letters</li> <li>Books</li> <li>Custom posters</li> <li>Cooking recipes</li> <li>Diagrams</li> <li>Academic articles</li> <li>Snippet blocks for embedding PDF previews</li> <li>...</li> </ul> <p>Each example lives in its own folder inside the <code>examples/</code> directory of the TeXSmith repository. Feel free to dive into the source files, front matter, and templates to see exactly how each document is assembled.</p> <p>These examples also double as test cases for TeXSmith\u2019s continuous integration (CI) pipeline, making sure that improvements to the engine don\u2019t accidentally break existing features.</p> <p>This collection will continue to grow as we add new examples and templates. Want to contribute? Send us a pull request! Our aim is to build a rich, community-driven library that inspires TeXSmith users and supports a wide variety of needs.</p>"},{"location":"examples/book/","title":"Book","text":""},{"location":"examples/book/#book","title":"Book","text":"<p>For this example we want to render homage to Albert Einstein by creating a small book using the Wikipedia as our source.</p> <p>The text was converted to LATEX then built using the <code>book</code> template.</p> <p>This example demonstrates the use of front matter for citations, abbreviations, glossary, and index.</p> <p>For this example, we decided to use a small paper size (A5) and a sans serif font (Adventor). The book is structured in parts and specific slots are used for the colophon, dedication, and preface. Here is the front matter used for this example:</p> <pre><code>title: Albert Einstein\nsubtitle: His Life and Achievements\ndate: 2025-03-15\nedition: Wikipedia Adaptation\nauthor: Wikipedia Contributors\npublisher: Wikipedia Sourcebooks\nimprint:\n  thanks: |\n    Adapted from the Wikipedia article \u201cAlbert Einstein\u201d (retrieved ).\n    Thank you to the Wikipedia contributors whose work makes this example\n    possible.\n  copyright: |\n    Wikipedia contributors. Text licensed under Creative Commons Attribution-ShareAlike\n    International (CC BY-SA).\n  license: |\n    This TeXSmith example is derived from Wikipedia and is not affiliated\n    with TeXSmith. Reuse must credit Wikipedia and share under CC BY-SA .\npress:\n  paper: a5\n  template: book\n  base_level: part\n  fonts: adventor\n  admonition_style: classic\n  slots:\n    colophon: Colophon\n    dedication: Dedication\n    preface: Preface\n</code></pre> <pre><code>layout: 4x2\ncwd: ../../examples/book\nsources:\n  - book.md\n  - book.bib\ntemplate: book\nfragments:\n  ts-frame:\npress:\n  frame: true\n</code></pre> <p>The example can be built independently using the CLI in the <code>examples/book/</code> folder. The engine can be chosen between <code>tectonic</code>, <code>xelatex</code>, and <code>lualatex</code> as follows:</p> <pre><code>texsmith book.md book.bib --template book --build --engine tectonic\n</code></pre> <p>The power of TeXSmith is that it can generate such complex documents from simple Markdown with no LATEX knowledge required and no LATEX toolchain installed. Fonts, toolchain, and image conversion are all handled automatically by TeXSmith in a single command.</p>"},{"location":"examples/colorful/","title":"Colorful Squares","text":"<p>This example shows off a custom poster-ish template with four slots wired through a local template. Front matter steers colors, slot routing, and layout\u2014no LATEX tweaks needed.</p> <pre><code>cwd: ../../examples/colorful\nsources:\n  - colorful.md\ntemplate: ../../examples/colorful\n</code></pre> <p>The YAML front matter picks the locally defined template (<code>.</code>), sets the palette, and feeds each slot. Colors live under <code>colors</code>, and slot content under <code>slots</code>.</p> <p>The manifest defines defaults, available attributes, and where they get injected.</p> colorful.mdmanifest.tomltemplate.tex <pre><code>---\ntitle: Colorful Manifesto\npress:\n  template: .\n  colors:\n    nw: \"#FF5A5F\"\n    ne: \"#FFC857\"\n    sw: \"#30C39E\"\n    se: \"#2D7DD2\"\n  slots:\n    nw: Northwest\n    ne: Northeast\n    sw: Southwest\n    se: Southeast\n---\n## Northwest\n\nIn the age of AI, our greatest power is not computation -- but compassion.\nLet us rise above the machines we create, and redefine what it means to be human.\n\n## Northeast\n\nThe planet is speaking through storms and silence. Climate change is our final\nreminder: protect the world that protects us, before the last leaf falls.\n\n## Southwest\n\nWe invented technology to connect souls -- not isolate them. In the glow of\nprogress, choose presence, choose people, choose purpose.\n\n## Southeast\n\nThe future is not written in code or carbon. It is shaped by every act of\ncourage we dare today. Humanity\u2019s masterpiece is still ahead.\n</code></pre> <pre><code>[compat]\ntexsmith = \"&gt;=0.6,&lt;1.0\"\n\n[latex.template]\nname = \"colorful-grid\"\nversion = \"0.1.0\"\nentrypoint = \"template.tex\"\nengine = \"lualatex\"\nshell_escape = false\ntexlive_year = 2023\ntlmgr_packages = [\n    \"geometry\",\n    \"fontspec\",\n    \"xcolor\",\n    \"pgf\",\n]\n\n[latex.template.attributes.colors]\ntype = \"mapping\"\nsources = [\"press.colors\", \"colors\"]\n\n[latex.template.attributes.colors.default]\nnw = \"strongpink\"\nne = \"strongyellow\"\nsw = \"stronggreen\"\nse = \"strongblue\"\n\n[latex.template.slots.nw]\ndefault = true\ndepth = \"section\"\nstrip_heading = true\n\n[latex.template.slots.ne]\ndepth = \"section\"\nstrip_heading = true\n\n[latex.template.slots.sw]\ndepth = \"section\"\nstrip_heading = true\n\n[latex.template.slots.se]\ndepth = \"section\"\nstrip_heading = true\n\n[latex.template.slots.mainmatter]\ndefault = false\n</code></pre> <pre><code>\\documentclass{article}\n\\usepackage[paperwidth=20cm, paperheight=20cm, margin=0cm]{geometry}\n\\usepackage{fontspec}\n\n\\setsansfont{texgyreheros-regular.otf}[\n    BoldFont       = texgyreheros-bold.otf,\n    ItalicFont     = texgyreheros-italic.otf,\n    BoldItalicFont = texgyreheros-bolditalic.otf\n]\n\\renewcommand{\\familydefault}{\\sfdefault}\n\n\\usepackage{tikz}\n\\usetikzlibrary{calc}\n\\usepackage{xcolor}\n\n\\definecolor{strongpink}{RGB}{255,105,180}\n\\definecolor{strongyellow}{RGB}{255,215,0}\n\\definecolor{stronggreen}{RGB}{0,200,150}\n\\definecolor{strongblue}{RGB}{100,149,237}\n\n\\pagestyle{empty}\n\n\\BLOCK{ set squares = [\n  {\"slot\": \"nw\", \"origin\": \"0,0\", \"center\": \"5,5\",\n   \"label\": \"NW\", \"content\": nw, \"color\": colors.nw},\n  {\"slot\": \"ne\", \"origin\": \"10,0\", \"center\": \"15,5\",\n   \"label\": \"NE\", \"content\": ne, \"color\": colors.ne},\n  {\"slot\": \"sw\", \"origin\": \"0,10\", \"center\": \"5,15\",\n   \"label\": \"SW\", \"content\": sw, \"color\": colors.sw},\n  {\"slot\": \"se\", \"origin\": \"10,10\", \"center\": \"15,15\",\n   \"label\": \"SE\", \"content\": se, \"color\": colors.se},\n] }\n\n\\begin{document}\n\\begin{tikzpicture}[remember picture,overlay,x=1cm,y=1cm]\n  \\coordinate (SW) at (current page.south west);\n  \\def\\boxwidth{7.5cm}\n\n  \\BLOCK{ for square in squares }\n  \\BLOCK{ set color_name = \"slotcolor-\" ~ square.slot }\n  \\BLOCK{ set color_value = square.color | default('', true) }\n  \\BLOCK{ if color_value and color_value.startswith('#') }\n  \\definecolor{\\VAR{color_name}}{HTML}{\\VAR{color_value|replace('#', '')}}\n  \\BLOCK{ elif color_value and ',' in color_value }\n  \\definecolor{\\VAR{color_name}}{RGB}{\\VAR{color_value}}\n  \\BLOCK{ elif color_value }\n  \\colorlet{\\VAR{color_name}}{\\VAR{color_value}}\n  \\BLOCK{ else }\n  \\colorlet{\\VAR{color_name}}{black}\n  \\BLOCK{ endif }\n\n  \\fill[\\VAR{color_name}] ($(SW)+(\\VAR{square.origin})$) rectangle ++(10,10);\n  \\node[text=white,font=\\bfseries\\Large,align=center]\n  at ($(SW)+(\\VAR{square.center})$)\n  {\\parbox{\\boxwidth}{%\n    \\VAR{square.content|default('Slot ' ~ square.label, true)|trim}}};\n  \\BLOCK{ endfor }\n\\end{tikzpicture}\n\\end{document}\n</code></pre> <p>Build it with:</p> <pre><code>$ ls\ncolorful.md  manifest.toml  template.tex\n$ texsmith colorful.md -t. --build\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Artifact      \u2502 Location                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PDF           \u2502 colorful.pdf                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/cooking/","title":"Cooking Recipes","text":"<p>TeXSmith isn\u2019t just for papers and slides -- it can plate up gorgeous recipes straight from structured data. Here\u2019s a French walnut cake expressed as YAML, pushed through a custom <code>recipe</code> template. Click the card to grab the PDF.</p> <pre><code>width: 60%\nfragments:\n  ts-frame:\npress:\n  frame: true\ncwd: ../../examples/recipe\nsources:\n  - cake.yml\ntemplate: ../../examples/recipe\n</code></pre> <p>The authoring surface is pure data: YAML fields flow into a LATEX template, no Markdown gymnastics required. Swap the YAML for a DB/API payload and you\u2019ve got a pipeline-ready recipe generator for your site or app.</p> cake.ymlmanifest.tomltemplate.tex <pre><code>---\ntitle: G\u00e2teau aux noix\ndescription: |\n  Ce g\u00e2teau aux noix s\u00e9duit d\u00e8s la premi\u00e8re bouch\u00e9e par son \u00e9quilibre parfait\n  entre une p\u00e2te sabl\u00e9e d\u00e9licatement friable et une farce g\u00e9n\u00e9reuse m\u00ealant\n  noix croquantes, caramel dor\u00e9 et miel parfum\u00e9. Doux sans \u00eatre lourd,\n  riche sans \u00eatre \u00e9c\u0153urant, il offre une texture fondante relev\u00e9e par\n  le croustillant des noix et la profondeur du caramel. Servi ti\u00e8de\n  ou \u00e0 temp\u00e9rature ambiante, il d\u00e9gage un parfum chaleureux et\n  gourmand qui \u00e9voque les desserts traditionnels d'automne, tout en\n  offrant une \u00e9l\u00e9gance rustique irr\u00e9sistible. Une v\u00e9ritable tentation\n  pour tous les amateurs de saveurs authentiques et de p\u00e2tisseries raffin\u00e9es.\nnotes: &gt;\n  Se conserve env. 2 semaines au r\u00e9frig\u00e9rateur bien emball\u00e9.\ntime:\n  total: 140\n  preparation: 50\n  cooking: 40\nsections:\n  - title: Pr\u00e9paration du moule\n    instructions:\n      - Pr\u00e9parer le moule.\n  - title: P\u00e2te sabl\u00e9e\n    steps:\n      - ingredients:\n          - quantity:\n              amount: 150\n              unit: g\n            name: farine\n          - quantity:\n              amount: 100\n              unit: g\n            name: sucre\n          - quantity:\n              amount: 1\n              unit: pinc\u00e9e\n            name: sel\n        instructions:\n          - Mettre dans un saladier.\n      - ingredients:\n          - quantity:\n              amount: 100\n              unit: g\n            name: beurre froid\n        instructions:\n          - Couper en morceaux, ajouter.\n          - &lt;\n            Travailler soigneusement \u00e0 la main jusqu'\u00e0 ce que la pr\u00e9paration\n            soit friable.\n      - ingredients:\n          - quantity:\n              amount: 1\n            name: \u0153uf\n        instructions:\n          - Ajouter.\n          - Travailler rapidement \u00e0 la main, ne pas p\u00e9trir.\n          - Couvrir et mettre au r\u00e9frig\u00e9rateur 30 minutes.\n        time:\n          refrigeration: 30\n  - title: Farce\n    steps:\n      - ingredients:\n          - name: noix\n            quantity:\n              amount: 130\n              unit: g\n        instructions:\n          - Hacher grossi\u00e8rement, r\u00e9server.\n      - ingredients:\n          - quantity:\n              amount: 100\n              unit: g\n            name: sucre\n          - quantity:\n              amount: 2\n              unit: cs\n            name: eau\n        instructions:\n          - Verser dans une grande casserole.\n          - Chauffer \u00e0 feu tr\u00e8s vif jusqu'\u00e0 dissolution du sucre, revenir \u00e0 feu vif.\n          - Tourner l\u00e9g\u00e8rement la casserole.\n          - Faire caram\u00e9liser sans remuer jusqu'\u00e0 ce que la couleur devienne noisette.\n          - Retirer la casserole du feu.\n      - ingredients:\n          - quantity:\n              amount: 1.25\n              unit: dl\n            name: cr\u00e8me enti\u00e8re\n        instructions:\n          - Ajouter, m\u00e9langer \u00e0 la cuill\u00e8re de cuisine.\n          - &lt;\n            R\u00e9chauffer \u00e0 petit feu en remuant jusqu'\u00e0 dissolution compl\u00e8te du\n            caramel, porter \u00e0 \u00e9bullition env. 10 min.\n        time:\n          cooking: 10\n      - ingredients:\n          - name: miel liquide\n            quantity:\n              amount: 1.5\n              unit: cs\n        instructions:\n          - Ajouter, m\u00e9langer, laisser refroidir.\n  - title: Assemblage\n    steps:\n      - ingredients:\n          - name: farine\n            quantity:\n              text: un peu\n        instructions:\n          - Partager la p\u00e2te en 3 portions r\u00e9guli\u00e8res.\n          - &lt;\n            \u00c9taler 1 portion en un cercle d'environ 4 mm d'\u00e9paisseur sur un peu de\n            farine.\n          - Poser dans le moule pr\u00e9par\u00e9.\n          - Piquer avec une fourchette.\n      - ingredients:\n          - name: farine\n            quantity:\n              text: un peu\n        instructions:\n          - Former un rouleau avec la deuxi\u00e8me portion de p\u00e2te.\n          - Appuyer sur les bords du moule jusqu'\u00e0 obtenir un bord d'environ 4 cm de\n            hauteur.\n      - instructions:\n          - R\u00e9partir la farce sur le fond de p\u00e2te.\n          - Replier le bord qui d\u00e9passe sur la farce.\n          - &lt;\n            \u00c9taler la derni\u00e8re portion en un cercle d'environ 4 mm et poser sur la\n            farce.\n          - Piquer avec une fourchette.\n          - Cuire dans le bas du four, 200\u00b0C, 40-50 min.\n        time:\n          cooking: 40\n---\n</code></pre> <pre><code>[compat]\ntexsmith = \"&gt;=0.6,&lt;1.0\"\n\n[latex.template]\nname = \"recipe\"\nversion = \"0.1.0\"\nentrypoint = \"template.tex\"\nengine = \"lualatex\"\ntexlive_year = 2023\ntlmgr_packages = [\n    \"geometry\",\n    \"fontspec\",\n    \"pgf\",\n    \"tabularx\",\n    \"multirow\",\n    \"xcolor\",\n]\n\n[latex.template.assets]\n\"tikz-cookingsymbols.sty\" = { source = \"tikz-cookingsymbols.sty\" }\n\n[latex.template.slots.mainmatter]\ndefault = true\n\n[latex.template.attributes.preamble]\ndefault = \"\"\ntype = \"string\"\nallow_empty = true\n</code></pre> <pre><code>\\documentclass{article}\n\\usepackage[a4paper, top=2cm, left=2cm, right=2cm, bottom=1cm]{geometry}\n\\usepackage{fontspec}\n\\usepackage{tikz-cookingsymbols}\n\\usepackage{tabularx}\n\\usepackage{multirow}\n\\usepackage{enumitem}\n\\usepackage{array}\n\\BLOCK{ if extra_packages }\n\\VAR{extra_packages}\n\\BLOCK{ endif }\n\n\\BLOCK{ if preamble }\n\\VAR{preamble}\n\n\\BLOCK{ endif }\n\n\\setlist[itemize]{leftmargin=*,nosep}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\\setlength{\\parindent}{0pt}\n\\setlength{\\parskip}{0.5em}\n\n\\newlength{\\colA}\n\\newlength{\\colB}\n\\setlength{\\colA}{0.07\\textwidth}\n\\setlength{\\colB}{0.15\\textwidth}\n\\newcolumntype{A}{&gt;{\\raggedright\\arraybackslash}p{\\colA}}\n\\newcolumntype{B}{&gt;{\\raggedright\\arraybackslash}p{\\colB}}\n\\newcolumntype{C}{&gt;{\\raggedright\\arraybackslash}X}\n\n\\BLOCK{ macro quantity(value) -}\n\\BLOCK{ if value is mapping -}\n  \\BLOCK{ if value.text -}\n    \\VAR{value.text}\n  \\BLOCK{ elif value.amount is defined -}\n    \\VAR{value.amount}\\BLOCK{ if value.unit }~\\VAR{value.unit}\\BLOCK{ endif }\n  \\BLOCK{ else -}\n  \\BLOCK{ endif -}\n\\BLOCK{ elif value is number -}\n  \\VAR{value}\n\\BLOCK{ elif value -}\n  \\VAR{value}\n\\BLOCK{ endif -}\n\\BLOCK{ endmacro }\n\n\\BLOCK{ set recipe_documents = documents | default([], true) }\n\n\\begin{document}\n\\pagestyle{empty}\n\\BLOCK{ if recipe_documents }\n\\BLOCK{ for doc in recipe_documents }\n\\BLOCK{ set data = doc.front_matter | default({}, true) }\n\\BLOCK{ set recipe = data.recipe if data.recipe is defined else data }\n\\BLOCK{ if loop.index &gt; 1 }\\newpage\\BLOCK{ endif }\n\n{\\Huge\\bfseries \\VAR{recipe.title | default('Recette', true)}}\\par\n\\vspace{2cm}\n\\noindent\n\\begin{minipage}[t]{0.3\\textwidth}\n\\vspace{0pt}%\n\\rule{\\linewidth}{1.5pt}\n\\BLOCK{ set time = recipe.time | default({}, true) }\n\\TopBottomHeat\\quad{} temps total \\textbf{\\VAR{time.total | default('--', true)}}~min \\\\\n\\Grill\\quad{} pr\u00e9paration \\textbf{\\VAR{time.preparation | default('--', true)}}~min \\\\\n\\ConvectionOven\\quad{} cuisson \\textbf{\\VAR{time.cooking | default('--', true)}}~min \\\\\n\\rule{\\linewidth}{1.5pt}\n\n\\BLOCK{ if recipe.description }\n\\subsection*{Description}\n\\VAR{recipe.description}\n\\BLOCK{ endif }\n\n\\subsection*{Conseils}\n\n\\VAR{recipe.notes | default('Aucun conseil enregistr\u00e9.', true)}\n\n\\end{minipage}\n\\hfill\n\\begin{minipage}[t]{0.68\\textwidth}\n\\vspace{0pt}%\n\\BLOCK{ for section in recipe.sections | default([], true) }\n\\textbf{\\VAR{section.title | default('\u00c9tape', true)}}\\vskip 0.75em\n\n\\BLOCK{ if section.instructions }\n\\begin{itemize}\n\\BLOCK{ for instruction in section.instructions }\n  \\item \\VAR{instruction}\n\\BLOCK{ endfor }\n\\end{itemize}\n\\BLOCK{ endif }\n\n\\BLOCK{ if section.steps }\n\\begin{tabularx}{\\textwidth}{@{}A B C@{}}\n\\BLOCK{ for step in section.steps }\n\\BLOCK{ set raw_items = step.ingredients | default([], true) }\n\\BLOCK{ if raw_items is mapping }\n  \\BLOCK{ set ingredients = [raw_items] }\n\\BLOCK{ elif raw_items is iterable and raw_items is not string }\n  \\BLOCK{ set ingredients = raw_items }\n\\BLOCK{ else }\n  \\BLOCK{ set ingredients = [] }\n\\BLOCK{ endif }\n\\BLOCK{ set note = step.instructions | default([], true) }\n\\BLOCK{ set note_text = note | join(' \\\\newline ') }\n\\BLOCK{ if ingredients }\n  \\BLOCK{ for ingredient in ingredients }\n    \\VAR{quantity(ingredient.quantity | default('', true))} &amp;\n    \\VAR{ingredient.name | default(ingredient.step | default('', true), true)} &amp;\n    \\BLOCK{ if loop.first }\n      \\VAR{note_text}\n    \\BLOCK{ endif }\\\\\n  \\BLOCK{ endfor }\n\\BLOCK{ else }\n  &amp; &amp; \\VAR{note_text}\\\\\n\\BLOCK{ endif }\n\\BLOCK{ if not loop.last }\n\\multicolumn{3}{@{}l}{\\rule{\\textwidth}{0.2pt}}\\\\\n\\BLOCK{ endif }\n\\BLOCK{ endfor }\n\\end{tabularx}\n\\BLOCK{ endif }\n\n\\vspace{1em}\n\\BLOCK{ endfor }\n\\end{minipage}\n\n\\BLOCK{ endfor }\n\\BLOCK{ endif }\n\n\\BLOCK{ if mainmatter and mainmatter.strip() }\n\\newpage\n\\VAR{mainmatter}\n\\BLOCK{ endif }\n\n\\end{document}\n</code></pre> <p>Note</p> <p>The recipe layout used in this template was inspired by the Cours de cuisine created by M.-C. Bolle back in 1978. She produced an exceptional cookbook for the Department of Public Instruction of the Canton of Geneva, Switzerland.</p> <p>I\u2019ve never seen recipes presented quite this way anywhere else -- it\u2019s a uniquely clever system -- but I find it incredibly practical and efficient.</p>"},{"location":"examples/diagrams/","title":"Diagrams","text":"<p>Markdown doesn\u2019t have to be flat text. Here\u2019s how we wire live Mermaid and Draw.io diagrams straight into TeXSmith, no opaque binaries, friendly diffs.</p> <pre><code>width: 60%\ncwd: ../../examples/diagrams\nsources:\n  - diagrams.md\ntemplate: article\nfragments:\n  ts-frame\npress:\n  frame: true\n</code></pre> <p>Here is the source:</p> <pre><code>---\npress:\n  subtitle: \"An Overview of drawio and mermaid diagram integration\"\n  paper:\n    margin: 2cm\n---\n# Diagram Integration\n\nYou can embed Draw.io or Mermaid diagrams directly in Markdown. This keeps\ntechnical documentation close to the visuals it describes, and the package\ntakes care of converting each diagram to an image that the final LaTeX\ndocument can reference automatically.\n\n## Draw.io Diagram\n\n![Euclidean GCD](pgcd.drawio){width=60%}\n\n/// caption\nEuclidean algorithm for the greatest common divisor\n///\n\n## Mermaid Diagram\n\n```mermaid {width=80%}\n%% Vegetable harvesting algorithm\nflowchart LR\n    start(Start) --&gt; pick[Dig up]\n    pick --&gt; if{Cabbages?}\n    if --No--&gt; step[Move forward one step]\n    step --&gt; pick\n    if --Yes--&gt; stop(End)\n```\n</code></pre>"},{"location":"examples/diagrams/#rendered-markdown","title":"Rendered Markdown","text":"<p>Obviously everything built with TeXSmith can also be rendered in this very Markdown file:</p>"},{"location":"examples/diagrams/#drawio-diagram","title":"Draw.io Diagram","text":"<p>Euclidean algorithm for the greatest common divisor</p>"},{"location":"examples/diagrams/#mermaid-diagram","title":"Mermaid Diagram","text":"<pre><code>%% Vegetable harvesting algorithm\nflowchart LR\n    start(Start) --&gt; pick[Dig up]\n    pick --&gt; if{Cabbages?}\n    if --No--&gt; step[Move forward one step]\n    step --&gt; pick\n    if --Yes--&gt; stop(End)</code></pre>"},{"location":"examples/diagrams/#drawio-backend-choice","title":"Draw.io backend choice","text":"<p>TeXSmith now tries a Playwright-based exporter first (cached under <code>~/.cache/texsmith/playwright</code>), falling back to the local <code>drawio</code>/<code>mmdc</code> CLI and finally the Docker image. Force a specific path with <code>--diagrams-backend=playwright|local|docker</code> if needed.</p>"},{"location":"examples/languages/","title":"Languages","text":"<p>TeXSmith speaks more than Markdown\u2014it speaks your language. Noto fonts ship in, so LATEX stops tripping over glyphs while browsers casually fall back. Most scripts just work out of the box; typographic nuances for highly specialized scripts (Arabic, Japanese, etc.) can be layered in if or when you need them.</p> <p>Below, we render a dialect sampler through the <code>article</code> template and lay two PDF pages side-by-side (<code>layout: 2x1</code>). Click to fetch the PDF.</p> <pre><code>layout: 2x1\ncwd: ../../examples/dialects\nsources:\n  - dialects.md\ntemplate: article\nfragments:\n  ts-frame\npress:\n  frame: true\n</code></pre> <p>Source:</p> <pre><code>---\npress:\n  subtitle: Demo on fonts fallback support\n  columns: 2\n  paragraph:\n    indent: 0\n    spacing: 0.5em\n  slots:\n    abstract: Abstract\n---\n# Foreign Script Support\n\n## Abstract\n\nTeXSmith can render documents in multiple languages and scripts, including those with complex typesetting requirements. Below are examples of various\nlanguages and scripts supported by TeXSmith, showcasing its versatility in\nhandling diverse linguistic content.\n\n## Japanese (\u65e5\u672c\u8a9e)\n\nJapanese is the national language of Japan and is spoken by over 125 million people, primarily within the country.\n\n\u6708\u65e5\u306f\u767e\u4ee3\u306e\u904e\u5ba2\u306b\u3057\u3066\u3001\u884c\u304d\u304b\u3075\u5e74\u3082\u65c5\u4eba\u306a\u308a\u3002\n\n\u821f\u306b\u4e57\u308a\u3001\u99ac\u306b\u4e57\u308a\u3066\u3001\u521d\u79cb\u306e\u98a8\u306b\u5439\u304b\u308c\u3064\u3064\u3001\n\n\u9053\u306e\u3079\u306e\u5c0f\u8349\u3092\u5206\u3051\u3001\u5c71\u5ddd\u3092\u8d8a\u3048\u3066\u3002\n\n## Korean (\ud55c\uad6d\uc5b4)\n\nKorean is spoken by about 80 million people worldwide and is the official language of both South Korea and North Korea.\n\n\uc774 \ubab8\uc774 \uc8fd\uace0 \uc8fd\uc5b4 \uc77c\ubc31 \ubc88 \uace0\uccd0 \uc8fd\uc5b4\n\n\ubc31\uace8\uc774 \uc9c4\ud1a0\ub418\uc5b4 \ub10b\uc774\ub77c\ub3c4 \uc788\uace0 \uc5c6\uace0\n\n\uc784 \ud5a5\ud55c \uc77c\ud3b8\ub2e8\uc2ec\uc774\uc57c \uac00\uc2e4 \uc904\uc774 \uc788\uc73c\ub7b4\n\n## Syriac (\u0720\u072b\u0722\u0710 \u0723\u0718\u072a\u071d\u071d\u0710)\n\nSyriac is an ancient Aramaic language historically used in the Middle East, especially in Christian liturgical and literary traditions.\n\n\u071b\u0718\u0712\u071d\u0717\u0718\u0722 \u0720\u0721\u0723\u071f\u0722\u0308\u0710 \u0712\u072a\u0718\u071a\u0710\u060c \u0715\u0715\u071d\u0720\u0717\u0718\u0722 \u0717\u071d \u0721\u0720\u071f\u0718\u072c\u0710 \u0715\u072b\u0721\u071d\u0308\u0710. \u071b\u0718\u0712\u071d\u0717\u0718\u0722 \u0720\u0710\u0712\u071d\u0308\u0720\u0710\u060c \u0715\u0717\u0722\u0718\u0722 \u0722\u072c\u0712\u071d\u0710\u0718\u0722. \u071b\u0718\u0712\u071d\u0717\u0718\u0722 \u0720\u0721\u071f\u071d\u0308\u071f\u0710\u060c \u0715\u0717\u0722\u0718\u0722 \u0722\u072a\u072c\u0718\u0722 \u0720\u0710\u072a\u0725\u0710. \u071b\u0718\u0712\u071d\u0717\u0718\u0722 \u0720\u0710\u071d\u0720\u071d\u0722 \u0715\u071f\u0726\u0722\u071d\u0722 \u0718\u0728\u0717\u071d\u0722 \u0720\u071f\u0710\u0722\u0718\u072c\u0710\u060c \u0715\u0717\u0722\u0718\u0722 \u0722\u0723\u0712\u0725\u0718\u0722.\n\n## Greek (\u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac)\n\nGreek is the official language of Greece and Cyprus and is spoken by roughly 13 million people, with a literary tradition dating back more than three millennia.\n\n\u0386\u03bd\u03c4\u03c1\u03b1, \u039c\u03bf\u03cd\u03c3\u03b1, \u03c0\u03b5\u03c2 \u03bc\u03bf\u03c5 \u03c4\u03bf\u03bd \u03c0\u03bf\u03bb\u03c5\u03bc\u03ae\u03c7\u03b1\u03bd\u03bf, \u03c0\u03bf\u03c5 \u03c0\u03ac\u03c1\u03b1 \u03c0\u03bf\u03bb\u03bb\u03ac\n\u03c4\u03b1\u03bb\u03b1\u03b9\u03c0\u03c9\u03c1\u03ae\u03b8\u03b7\u03ba\u03b5, \u03b1\u03c6\u03bf\u03cd \u03ba\u03b1\u03c4\u03ad\u03c3\u03c4\u03c1\u03b5\u03c8\u03b5 \u03c4\u03b7\u03bd \u03b9\u03b5\u03c1\u03ae \u03c0\u03bf\u03bb\u03b9\u03c4\u03b5\u03af\u03b1 \u03c4\u03b7\u03c2 \u03a4\u03c1\u03bf\u03af\u03b1\u03c2\u00b7\n\n\u03ba\u03b1\u03b9 \u03b5\u03af\u03b4\u03b5 \u03c4\u03b9\u03c2 \u03c0\u03cc\u03bb\u03b5\u03b9\u03c2 \u03c0\u03bf\u03bb\u03bb\u03ce\u03bd \u03b1\u03bd\u03b8\u03c1\u03ce\u03c0\u03c9\u03bd \u03ba\u03b1\u03b9 \u03b3\u03bd\u03ce\u03c1\u03b9\u03c3\u03b5 \u03c4\u03bf\u03bd \u03c4\u03c1\u03cc\u03c0\u03bf \u03c4\u03bf\u03c5\u03c2,\n\u03ba\u03b1\u03b9 \u03c0\u03bf\u03bb\u03bb\u03ad\u03c2 \u03bb\u03cd\u03c0\u03b5\u03c2 \u03ad\u03c0\u03b1\u03b8\u03b5 \u03c3\u03c4\u03b7 \u03b8\u03ac\u03bb\u03b1\u03c3\u03c3\u03b1 \u03bc\u03ad\u03c3\u03b1 \u03c3\u03c4\u03b7\u03bd \u03ba\u03b1\u03c1\u03b4\u03b9\u03ac \u03c4\u03bf\u03c5,\n\n\u03c0\u03c1\u03bf\u03c3\u03c0\u03b1\u03b8\u03ce\u03bd\u03c4\u03b1\u03c2 \u03bd\u03b1 \u03c3\u03ce\u03c3\u03b5\u03b9 \u03ba\u03b1\u03b9 \u03c4\u03b7 \u03b4\u03b9\u03ba\u03ae \u03c4\u03bf\u03c5 \u03b6\u03c9\u03ae\n\u03ba\u03b1\u03b9 \u03c4\u03b7\u03bd \u03b5\u03c0\u03b9\u03c3\u03c4\u03c1\u03bf\u03c6\u03ae \u03c4\u03c9\u03bd \u03c3\u03c5\u03bd\u03c4\u03c1\u03cc\u03c6\u03c9\u03bd \u03c4\u03bf\u03c5.\n\n## Chinese Trad. (\u7e41\u9ad4\u4e2d\u6587)\n\nTraditional Chinese characters are used mainly in Taiwan, Hong Kong, and Macau by tens of millions of speakers of Mandarin, Cantonese, and other Sinitic languages.\n\n\u5c11\u65e0\u9002\u4fd7\u97f5\uff0c\u6027\u672c\u7231\u4e18\u5c71\u3002\n\u8bef\u843d\u5c18\u7f51\u4e2d\uff0c\u4e00\u53bb\u4e09\u5341\u5e74\u3002\n\u7f81\u9e1f\u604b\u65e7\u6797\uff0c\u6c60\u9c7c\u601d\u6545\u6e0a\u3002\n\u5f00\u8352\u5357\u91ce\u9645\uff0c\u5b88\u62d9\u5f52\u56ed\u7530\u3002\n\u4e45\u5728\u6a0a\u7b3c\u91cc\uff0c\u590d\u5f97\u8fd4\u81ea\u7136\u3002\n\n## Arabic\n\nArabic is spoken by over 400 million people across the Middle East and North Africa and serves as the liturgical language of Islam.\n\n\u0642\u0650\u0641\u0627 \u0646\u064e\u0628\u0652\u0643\u0650 \u0645\u0650\u0646\u0652 \u0630\u0650\u0643\u0631\u064e\u0649 \u062d\u0628\u064a\u0628\u064d \u0648\u0645\u064e\u0646\u0632\u0650\u0644\u0650\n\n\u0628\u0650\u0633\u0650\u0642\u0637\u0650 \u0627\u0644\u0644\u0650\u0651\u0648\u064e\u0649 \u0628\u064e\u064a\u0652\u0646\u064e \u0627\u0644\u062f\u064e\u0651\u062e\u0648\u0644 \u0641\u064e\u062d\u064e\u0648\u0652\u0645\u064e\u0644\u0650\n\n\u0641\u064e\u062a\u064f\u0648\u0636\u0650\u062d\u064e \u0641\u064e\u0627\u0644\u0645\u0650\u0642\u0631\u0627\u0629\u0650 \u0644\u064e\u0645 \u064a\u064e\u0639\u0641\u064f \u0631\u064e\u0633\u0645\u064f\u0647\u0627\n\n\u0644\u0650\u0645\u0627 \u0646\u064e\u0633\u064e\u062c\u064e\u062a\u0647\u0627 \u0645\u0650\u0646 \u062c\u064e\u0646\u064f\u0648\u0628\u064d \u0648\u0634\u064e\u0645\u0623\u0644\u0650\n\n\u062a\u064e\u0631\u064e\u0649 \u0628\u064e\u0639\u064e\u0631\u064e \u0627\u0644\u0623\u0631\u0652\u0622\u0645\u0650 \u0641\u064a \u0639\u064e\u0631\u064e\u0635\u0627\u062a\u0650\u0647\u0627\n\n\u0648\u064e\u0642\u0650\u064a\u0652\u0639\u0627\u0646\u0650\u0647\u0627 \u0643\u064e\u0623\u0646\u064e\u0651\u0647\u064f \u062d\u064e\u0628\u064f\u0651 \u0641\u064f\u0644\u0652\u0641\u064f\u0644\u0650\n\n## Devanagari (\u0926\u0947\u0935\u0928\u093e\u0917\u0930\u0940)\n\nThe Devanagari script is used for several major South Asian languages, including Hindi, Marathi, and Sanskrit, representing over 600 million speakers combined.\n\n\u0928 \u091c\u093e\u092f\u0924\u0947 \u092e\u094d\u0930\u093f\u092f\u0924\u0947 \u0935\u093e \u0915\u0926\u093e\u091a\u093f\u0928\u094d\n\n\u0928\u093e\u092f\u0902 \u092d\u0942\u0924\u094d\u0935\u093e \u092d\u0935\u093f\u0924\u093e \u0935\u093e \u0928 \u092d\u0942\u092f\u0903\u0964\n\n\u0905\u091c\u094b \u0928\u093f\u0924\u094d\u092f\u0903 \u0936\u093e\u0936\u094d\u0935\u0924\u094b\u093d\u092f\u0902 \u092a\u0941\u0930\u093e\u0923\u094b\n\n\u0928 \u0939\u0928\u094d\u092f\u0924\u0947 \u0939\u0928\u094d\u092f\u092e\u093e\u0928\u0947 \u0936\u0930\u0940\u0930\u0947\u0965\n\n## Urdu (\u0627\u0631\u062f\u0648)\n\nUrdu is spoken by more than 170 million people, mainly in Pakistan and India, and serves as Pakistan's national language.\n\n\u0639\u0634\u0642 \u0627\u06cc\u06a9 \u0645\u0650\u06cc\u0631\u064f\u06cc \u0622\u0641\u062a \u06c1\u06d2\n\n\u062f\u0644 \u06a9\u0648 \u0644\u06d2 \u06a9\u0631 \u0688\u0648\u0628 \u06c1\u06cc \u062c\u0627\u062a\u06cc \u06c1\u06d2\n\n\u062f\u0631\u062f \u06a9\u06cc \u0644\u06c1\u0631 \u0627\u0679\u06be\u062a\u06cc \u062c\u0627\u0626\u06d2\n\n\u0627\u0634\u06a9 \u0628\u06be\u06cc \u0633\u0627\u062a\u06be \u0628\u06c1\u06c1 \u06c1\u06cc \u062c\u0627\u062a\u06d2 \u06c1\u06cc\u06ba\n\n## Sinhala (\u0dc3\u0dd2\u0d82\u0dc4\u0dbd)\n\nSinhala is the primary language of Sri Lanka and is spoken by about 17 million native speakers.\n\n\u0dc3\u0db3 \u0d91\u0dc5\u0dd2\u0dba \u0db4\u0dd4\u0dbb\u0dcf \u0dbb\u0dd0\u0dba \u0db1\u0dd2\u0dbd\u0dca \u0dc3\u0dd2\u0dbd\u0dd4\u0dc0\u0dd9\u0db1\u0dca \u0dc4\u0dd0\u0dac\u0dda\u0dbd\u0dcf\n\n\u0dc3\u0db3\u0dc4\u0db1\u0dd9\u0d9a\u0dd4 \u0db8\u0dd9\u0db1\u0dca \u0dc3\u0dd2\u0dad\u0dca \u0dad\u0dd4\u0dc5 \u0dc4\u0dac\u0d9a\u0dca \u0dc0\u0dd3 \u0db4\u0dcf\u0dc0\u0dd9\u0dba\u0dd2\u0964\n\n\u0dc3\u0dd2\u0dc4\u0dd2\u0db1\u0dd9\u0db1\u0dca \u0db4\u0dcf\u0dbb\u0dc0\u0dbd\u0dca \u0dc4\u0dbb\u0dc4\u0dcf \u0dbd\u0d82\u0dc0\u0dd3\u0dba \u0db8\u0dbd\u0dca \u0dc3\u0dd4\u0dc0\u0db3\u0d9a\u0dca\n\n\u0dc3\u0dbb\u0dad\u0dca \u0dbb\u0dd0\u0dba\u0dda \u0dc3\u0dd4\u0dc0\u0dd2\u0dc3\u0dd9\u0dbd\u0dd2\u0db1\u0dd2 \u0db8\u0db1\u0db8\u0dda \u0dad\u0db1\u0dd4\u0dc0\u0dda \u0dbb\u0dd0\u0daf\u0dd3.\n\n## Khmer (\u1781\u17d2\u1798\u17c2\u179a)\n\nKhmer is the official language of Cambodia and is spoken by more than 16 million people.\n\n\u1799\u1794\u17cb\u179f\u17d2\u1790\u1794\u17cb\u178f\u17d2\u179a\u1784\u17cb \u1796\u17d2\u179a\u17c3\u179f\u17d2\u179a\u1796\u1793\u17cb\u179f\u17bc\u179a \u179f\u17d2\u1791\u17b9\u1784\u179f\u17d2\u1791\u17bc\u1784\u178f\u17b6\u1798\u179f\u17d2\u179a\u1798\u17c4\u179b\u178a\u17be\u1798\u1788\u17be\n\u1781\u17d2\u1799\u179b\u17cb\u17a2\u17bc\u179b\u17b8\u179b \u1798\u1780\u1796\u17b8\u1797\u17d2\u1793\u17c6\u1786\u17d2\u1784\u17b6\u1799 \u1794\u17c9\u17c7\u1798\u1780\u178a\u179b\u17cb\u1785\u17b7\u178f\u17d2\u178f\u17a2\u17be\u1799\u1786\u17d2\u1784\u17b6\u1799\u178e\u17b6\n\u179f\u17bc\u179a\u179f\u178f\u17d2\u179c\u1794\u1780\u17d2\u179f\u17b8 \u179b\u17c1\u1794\u179b\u17b6\u1793\u17cb\u178f\u17b6\u1798\u179f\u17c2\u1793 \u1780\u17d2\u179b\u17b7\u1793\u1795\u17d2\u1780\u17b6\u1788\u17bc\u1780\u179a\u17b6\u178f\u17d2\u179a\u17b8\u179a\u17c6\u179b\u17c1\u1785\u17d4\n\n## Telugu (\u0c24\u0c46\u0c32\u0c41\u0c17\u0c41)\n\nTelugu is a major Dravidian language of India, spoken by over 80 million people, primarily in the states of Andhra Pradesh and Telangana.\n\n\u0c28\u0c28\u0c4d\u0c28\u0c2f \u0c2d\u0c1f\u0c4d\u0c1f\u0c41\u0c28\u0c3f \u0c35\u0c3e\u0c15\u0c4d\u0c15\u0c41\u0c32\u0c41 \u0c28\u0c26\u0c40\u0c35\u0c47\u0c17\u0c2e\u0c41\u0c35\u0c32\u0c46 \u0c2a\u0c4d\u0c30\u0c35\u0c39\u0c3f\u0c02\u0c1a\u0c3f\n\n\u0c2a\u0c3e\u0c02\u0c21\u0c35 \u0c15\u0c25\u0c3e\u0c2e\u0c43\u0c24\u0c2e\u0c41 \u0c32\u0c4b\u0c15\u0c2e\u0c41\u0c28\u0c41 \u0c28\u0c3f\u0c02\u0c2a\u0c46\u0c28\u0c41\u0964\n\n\u0c27\u0c30\u0c4d\u0c2e\u0c2e\u0c41\u0c28\u0c15\u0c41 \u0c2e\u0c3e\u0c30\u0c4d\u0c17\u0c26\u0c30\u0c4d\u0c36\u0c3f \u0c2a\u0c3e\u0c02\u0c21\u0c35\u0c41\u0c28\u0c3f \u0c17\u0c3e\u0c25\u0c32\u0c24\u0c4b\n\n\u0c24\u0c46\u0c32\u0c41\u0c17\u0c41 \u0c2d\u0c3e\u0c37\u0c15\u0c41 \u0c24\u0c4a\u0c32\u0c3f\u0c2e\u0c15\u0c41\u0c1f\u0c02 \u0c15\u0c40\u0c30\u0c4d\u0c24\u0c3f \u0c2a\u0c4d\u0c30\u0c38\u0c30\u0c3f\u0c02\u0c1a\u0c46\u0c28\u0c46.\n\n## Georgian (\u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8)\n\nGeorgian is the official language of Georgia, with around 4-5 million speakers, and is the largest member of the Kartvelian language family.\n\n\u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u10d4\u10dc\u10d0 \u10d9\u10d0\u10d5\u10d9\u10d0\u10e1\u10d8\u10dd\u10dc\u10d8\u10e1 \u10db\u10d7\u10d4\u10d1\u10e1 \u10e8\u10dd\u10e0\u10d8\u10e1 \u10d3\u10d0\u10d1\u10d0\u10d3\u10d4\u10d1\u10e3\u10da\u10d8 \u10eb\u10d5\u10d4\u10da\u10d8 \u10ee\u10db\u10d0\u10d5\u10d8\u10d0.\n\u10e5\u10e0\u10dd\u10dc\u10d8\u10d9\u10d4\u10d1\u10e8\u10d8, \u10ee\u10d4\u10da\u10dc\u10d0\u10ec\u10d4\u10e0\u10d4\u10d1\u10e8\u10d8 \u10d3\u10d0 \u10ee\u10d0\u10da\u10ee\u10e3\u10e0 \u10e1\u10d8\u10db\u10e6\u10d4\u10e0\u10d4\u10d1\u10e8\u10d8 \u10d4\u10e1 \u10d4\u10dc\u10d0 \u10ee\u10d0\u10da\u10ee\u10d8\u10e1 \u10d8\u10e1\u10e2\u10dd\u10e0\u10d8\u10d0\u10e1 \u10db\u10dd\u10f0\u10e7\u10d5\u10d4\u10d1\u10d0.\n\u10d7\u10d1\u10d8\u10da\u10d8\u10e1\u10d8\u10e1 \u10e5\u10e3\u10e9\u10d8\u10e1 \u10e1\u10d0\u10e3\u10d1\u10e0\u10d8\u10d3\u10d0\u10dc \u10e1\u10dd\u10e4\u10da\u10d8\u10e1 \u10e1\u10e3\u10e4\u10e0\u10d8\u10e1 \u10e2\u10dd\u10e1\u10e2\u10d4\u10d1\u10d0\u10db\u10d3\u10d4,\n\u10e5\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u10e1\u10d8\u10e2\u10e7\u10d5\u10d4\u10d1\u10d8 \u10db\u10d4\u10d2\u10dd\u10d1\u10e0\u10dd\u10d1\u10d8\u10e1\u10d0 \u10d3\u10d0 \u10e1\u10e2\u10e3\u10db\u10d0\u10e0\u10d7\u10db\u10dd\u10e7\u10d5\u10d0\u10e0\u10d4\u10dd\u10d1\u10d8\u10e1 \u10e1\u10e3\u10da\u10e1 \u10d0\u10e2\u10d0\u10e0\u10d4\u10d1\u10e1.\n\n## Armenian (\u0540\u0561\u0575\u0565\u0580\u0565\u0576)\n\nArmenian is the official language of Armenia and a key language of the global Armenian diaspora, spoken by roughly 6\u20137 million people.\n\n\u0540\u0561\u0575\u0565\u0580\u0565\u0576\u0568 \u0574\u056b\u0561\u0575\u0576 \u057a\u0565\u057f\u0561\u056f\u0561\u0576 \u056c\u0565\u0566\u0578\u0582 \u0579\u0567\u055d \u0561\u0575\u056c \u0576\u0561\u0565\u0582 \u0570\u0578\u0563\u0565\u0582\u0578\u0580 \u0570\u056b\u0577\u0578\u0572\u0578\u0582\u0569\u0575\u0561\u0576 \u057f\u0561\u0576\u0578\u0572 \u0578\u0582\u0572\u056b \u0567\u0589\n\n\u0534\u0561\u0580\u0565\u0580\u056b \u0568\u0576\u0569\u0561\u0581\u0584\u0578\u0582\u0574 \u0563\u0580\u057e\u0561\u056e \u057f\u0561\u0580\u0565\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0576\u0565\u0580\u0568\u055d \u057d\u0561\u0572\u0574\u0578\u057d\u0576\u0565\u0580\u0568 \u0565\u0582 \u056a\u0578\u0572\u0578\u057e\u0580\u0564\u0561\u056f\u0561\u0576 \u0565\u0580\u0563\u0565\u0580\u0568\u055d\n\n\u0561\u0575\u057d \u056c\u0565\u0566\u057e\u0578\u057e \u0565\u0576 \u057a\u0561\u0570\u057a\u0561\u0576\u0565\u056c \u056a\u0578\u0572\u0578\u057e\u0580\u0564\u056b \u0578\u0582\u0580\u0561\u056d\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0576 \u0578\u0582 \u0581\u0561\u057e\u0568\u0589\n\n## Russian (\u0440\u0443\u0441\u0441\u043a\u0438\u0439)\n\nRussian is an East Slavic language spoken by about 258 million people worldwide and is an official language in Russia, Belarus, Kazakhstan, and Kyrgyzstan.\n\n\u041c\u043e\u0439 \u0434\u044f\u0434\u044f \u0441\u0430\u043c\u044b\u0445 \u0447\u0435\u0441\u0442\u043d\u044b\u0445 \u043f\u0440\u0430\u0432\u0438\u043b,\n\n\u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0432 \u0448\u0443\u0442\u043a\u0443 \u0437\u0430\u043d\u0435\u043c\u043e\u0433,\n\n\u043e\u043d \u0443\u0432\u0430\u0436\u0430\u0442\u044c \u0441\u0435\u0431\u044f \u0437\u0430\u0441\u0442\u0430\u0432\u0438\u043b\n\n\u0438 \u043b\u0443\u0447\u0448\u0435 \u0432\u044b\u0434\u0443\u043c\u0430\u0442\u044c \u043d\u0435 \u043c\u043e\u0433.\n\n## Hebrew (\u05e2\u05d1\u05e8\u05d9\u05ea)\n\nHebrew is a Semitic language spoken by over 9 million people worldwide and is the official language of Israel.\n\n\u05d4\u05b7\u05dc\u05bc\u05b5\u05d9\u05dc\u05b8\u05d4 \u05d0\u05b2\u05e0\u05b4\u05d9 \u05d7\u05d5\u05b9\u05dc\u05b5\u05dd \u05e2\u05b7\u05dc \u05e9\u05c2\u05b8\u05e4\u05d5\u05b9\u05ea \u05d4\u05b8\u05e2\u05b5\u05ea \u05d1\u05bc\u05b8\u05d0\u05d5\u05bc \u05d1\u05bc\u05b7\u05d7\u05d5\u05b9\u05e3\n\u05e7\u05d5\u05b9\u05dc \u05d4\u05b7\u05d2\u05bc\u05b7\u05dc\u05bc\u05b4\u05d9\u05dd \u05de\u05b0\u05e9\u05c1\u05b7\u05d7\u05b5\u05e7 \u05e2\u05b4\u05dd \u05d4\u05b8\u05e8\u05b6\u05d2\u05b7\u05e2\n\u05d5\u05b0\u05d4\u05b7\u05dc\u05bc\u05b5\u05d1 \u05db\u05bc\u05d5\u05b9\u05e1\u05b5\u05e3 \u05dc\u05b0\u05d1\u05b5\u05d9\u05ea \u05db\u05bc\u05b8\u05dc \u05e9\u05c1\u05b4\u05d9\u05e8\u05b7\u05d9.\n\n## Thai (\u0e44\u0e17\u0e22)\n\nThai is the national language of Thailand and is spoken by more than 60 million people.\n\n\u0e2a\u0e32\u0e22\u0e25\u0e21\u0e1e\u0e31\u0e14\u0e1c\u0e48\u0e32\u0e19\u0e17\u0e38\u0e48\u0e07\u0e02\u0e49\u0e32\u0e27\u0e40\u0e02\u0e35\u0e22\u0e27\u0e02\u0e08\u0e35\n\n\u0e01\u0e25\u0e34\u0e48\u0e19\u0e14\u0e2d\u0e01\u0e44\u0e21\u0e49\u0e42\u0e0a\u0e22\u0e21\u0e32\u0e01\u0e31\u0e1a\u0e40\u0e2a\u0e35\u0e22\u0e07\u0e23\u0e30\u0e06\u0e31\u0e07\u0e27\u0e31\u0e14\n\n\u0e2b\u0e31\u0e27\u0e43\u0e08\u0e04\u0e34\u0e14\u0e16\u0e36\u0e07\u0e23\u0e2d\u0e22\u0e22\u0e34\u0e49\u0e21\u0e41\u0e25\u0e30\u0e04\u0e33\u0e17\u0e31\u0e01\u0e17\u0e32\u0e22\u0e2d\u0e1a\u0e2d\u0e38\u0e48\u0e19\u0e02\u0e2d\u0e07\u0e1c\u0e39\u0e49\u0e04\u0e19.\n\n## Bengali (\u09ac\u09be\u0982\u09b2\u09be)\n\nBengali is spoken by over 250 million people, mainly in Bangladesh and the Indian state of West Bengal.\n\n\u098f\u0987 \u09a8\u09a6\u09c0 \u09ae\u09be\u09a0 \u0986\u09b0 \u0997\u09be\u099b\u09c7\u09b0 \u099b\u09be\u09af\u09bc\u09be\n\n\u09ae\u09be\u09a8\u09c1\u09b7\u09c7\u09b0 \u09b9\u09be\u09b8\u09bf \u0986\u09b0 \u09b6\u09cb\u0995\u09c7\u09b0 \u0997\u09be\u09a8\n\n\u09b8\u09ac \u09ae\u09bf\u09b2\u09bf\u09af\u09bc\u09c7 \u09ac\u09be\u0982\u09b2\u09be \u09ad\u09be\u09b7\u09be \u09b9\u09c3\u09a6\u09af\u09bc\u09c7 \u09b0\u09be\u0996\u09c7 \u09aa\u09cd\u09b0\u09be\u09a3\u09c7\u09b0 \u0997\u09b2\u09cd\u09aa\u0964\n\n## Tibetan\n\n\u0f56\u0f7c\u0f51\u0f0b\u0f61\u0f72\u0f42\u0f0b\u0f42\u0f72\u0f0b\u0f5a\u0f72\u0f42\u0f0b\u0f66\u0fa8\u0f7c\u0f53\u0f0b\u0f62\u0f92\u0fb1\u0f63\u0f0b\u0f41\u0f56\u0f0b\u0f42\u0f72\u0f0b\u0f66\u0f99\u0f72\u0f44\u0f0b\u0f53\u0f66\u0f0b\u0f56\u0fb1\u0f74\u0f44\u0f0b\n\n\u0f62\u0fb3\u0f74\u0f44\u0f0b\u0f51\u0f44\u0f0b\u0f66\u0fa3\u0f74\u0f58\u0f0b\u0f42\u0fb1\u0f72\u0f0b\u0f66\u0f92\u0fb2\u0f0b\u0f51\u0f44\u0f0b\u0f58\u0f49\u0f58\u0f0b\u0f51\u0f74\u0f0b\u0f66\u0f90\u0f51\u0f0b\u0f46\u0f0b\u0f66\u0fa3\u0f44\u0f0b\u0f56\u0f0b\u0f56\u0f66\u0f90\u0f74\u0f62\u0f0d\n\n\u0f63\u0f58\u0f0b\u0f66\u0f7a\u0f44\u0f0b\u0f42\u0f72\u0f0b\u0f66\u0f92\u0fb2\u0f7c\u0f53\u0f0b\u0f58\u0f0b\u0f56\u0f5e\u0f74\u0f42\u0f66\u0f0b\u0f66\u0f92\u0f7c\u0f58\u0f0b\u0f51\u0f44\u0f0b\u0f58\u0f49\u0f58\u0f0b\u0f56\u0f5e\u0f42\u0f0b\u0f54\u0f60\u0f72\u0f0b\u0f61\u0f72\u0f51\u0f0b\u0f40\u0fb1\u0f72\u0f0b\u0f42\u0f51\u0f74\u0f44\u0f0b\u0f60\u0f51\u0f74\u0f42\u0f0d\n\n## Tamil (\u0ba4\u0bae\u0bbf\u0bb4\u0bcd)\n\n\u0b95\u0bbe\u0bb1\u0bcd\u0bb1\u0bbf\u0ba9\u0bcd \u0bae\u0ba3\u0bae\u0bcd \u0ba8\u0ba9\u0bc8\u0ba8\u0bcd\u0ba4\u0bc1 \u0bb5\u0bb0\u0bc1\u0bae\u0bcd\n\u0baa\u0bbe\u0b9f\u0bcd\u0b9f\u0bbf\u0ba9\u0bcd \u0b9a\u0bca\u0bb2\u0bcd \u0bae\u0ba9\u0ba4\u0bbf\u0bb2\u0bcd \u0ba8\u0bbf\u0bb1\u0bcd\u0b95\u0bc1\u0bae\u0bcd\n\u0ba4\u0bae\u0bbf\u0bb4\u0bcd \u0bae\u0ba3\u0bcd\u0ba3\u0bbf\u0ba9\u0bcd \u0ba8\u0bc6\u0b9e\u0bcd\u0b9a\u0bbf\u0bb2\u0bcd \u0bb5\u0bbe\u0bb4\u0bc1\u0bae\u0bcd \u0bae\u0bb0\u0baa\u0bbf\u0ba9\u0bcd \u0b87\u0ba9\u0bbf\u0bae\u0bc8.\n\n## Amharic (\u12a0\u121b\u122d\u129b)\n\nAmharic is a Semitic language spoken mainly in Ethiopia.\n\n\u12a0\u121b\u122d\u129b \u1260\u12a2\u1275\u12ee\u1335\u12eb \u12e8\u1218\u1295\u130d\u1225\u1275 \u124b\u1295\u124b \u12a5\u1293 \u12e8\u1265\u12d9 \u1265\u1214\u122e\u127d \u1218\u1308\u1293\u129b \u1218\u1295\u1308\u12f5 \u1293\u1275\u1362\n\n\u1218\u12dd\u1219\u122e\u127d\u1363 \u1273\u122a\u12ab\u12ca \u12d8\u1308\u1263\u12ce\u127d \u12a5\u1293 \u12e8\u12d5\u1208\u1275 \u1270\u12d5\u1208\u1275 \u1270\u12c8\u120b\u1305 \u1243\u120b\u1275 \u12cd\u1235\u1325 \u12ed\u1205\u127d \u124b\u1295\u124b \u12e8\u1215\u12ed\u12c8\u1275\u1295 \u12f5\u121d\u133d \u1273\u1275\u121b\u1208\u127d\u1362\n\n## Burmese (\u1019\u103c\u1014\u103a\u1019\u102c)\n\nBurmese is the official language of Myanmar.\n\nand over 40 million total speakers use it.\n\n\u1019\u103c\u1014\u103a\u1019\u102c\u1018\u102c\u101e\u102c\u1000\u102d\u102f \u101b\u103e\u1031\u1038\u1021\u1001\u1031\u1010\u103a\u1000\u1015\u1004\u103a \u1017\u102d\u1019\u102c\u1014\u103a\u104a\n\n\u101b\u102c\u1007\u101d\u1004\u103a\u1005\u102c\u1021\u102f\u1015\u103a\u1010\u103d\u1031\u1011\u1032\u1000 \u1017\u103b\u102c\u1012\u102d\u1010\u103a\u1005\u102c\u1014\u1032\u1037\u1021\u1010\u1030\n\n\u1006\u1000\u103a\u1001\u1036\u101c\u102c\u1000\u103c\u1010\u101a\u103a\u104b\n</code></pre> <p>Build it locally:</p> <pre><code>texsmith build dialects.md -tarticle --build\n</code></pre>"},{"location":"examples/languages/#fallbacks","title":"Fallbacks","text":"<p>Font fallback is\u2026 complicated\u2014almost passionately so. In a browser, the mechanism is straightforward: if a glyph is missing in the first font, the engine walks the font stack and tries the next one, and the next one, until it eventually finds something that contains the character. For obscure Unicode blocks or emoji, Chrome and other modern browsers ultimately fall back to Google\u2019s Noto super-family, which covers most of the Unicode universe.</p> <p>LATEX, on the other hand, does not provide automatic font fallback in the same way. With classic pdfLaTeX there is no real fallback mechanism at all; if a glyph isn\u2019t in the selected font, you simply get a missing-glyph warning or a tofu box.</p> <p>LuaLaTeX changes the game: thanks to the <code>luaotfload</code> package, it can perform font fallback, but you must explicitly define fallback fonts in your document or template.</p> <p>However, for this to work, those fallback fonts need to actually exist on your TEX system. And this is where it gets tricky: installing Noto fonts via TEX Live (<code>tlmgr</code>) or via system packages like <code>apt install fonts-noto</code> is often incomplete, because distributions usually ship only a subset of the full Noto collection. For full Unicode coverage (emoji, rare historical scripts, CJK extensions, etc.), you often need to manually download and install the complete font set from Google\u2019s official Noto Fonts repository.</p>"},{"location":"examples/letters/","title":"Letters","text":"<p>TeXSmith includes a built-in letter template based on the KOMA-Script <code>scrlttr2</code> class. Below are three examples of letters formatted according to different national standards: DIN (Germany), SN (Switzerland), and NF (France).</p> <p>The letter template is built into TeXSmith; to use it, set <code>-tletter</code> on the command line or <code>template: letter</code> in your document front matter.</p> DIN (Germany)SN (Switzerland)NF (France) <pre><code>width: 70%\ncwd: ../../examples/letter\nsources:\n  - letter.md\npress:\n  format: din\n  frame: true\ndrop_title: true\nfragments:\n    ts-frame\n</code></pre> <pre><code>width: 70%\ncwd: ../../examples/letter\nsources:\n  - letter.md\npress:\n  format: sn\n  frame: true\ndrop_title: true\nfragments:\n    ts-frame\n</code></pre> <pre><code>width: 70%\ncwd: ../../examples/letter\nsources:\n  - letter.md\npress:\n  format: nf\n  frame: true\ndrop_title: true\nfragments:\n    ts-frame\n</code></pre> <p>Here is the source code for the letter example used above:</p> LetterTemplateManifest <pre><code>---\npress:\n  template: letter\n  date: 1903-07-14\n  signature: marie-curie.svg\n  back-address: Laboratory of Physics and Chemistry, Sorbonne Univ., Paris\n  from:\n    name: Marie Sk\u0142odowska Curie\n    address: |\n      Laboratory of Physics and Chemistry\n      Sorbonne University\n      75005 Paris, France\n  to:\n    name: Leonardo da Vinci\n    address: |\n      Casa di Leonardo\n      Near the Church of Santa Croce\n      Florence, Republic of Florence (c. 1500)\n  ps: |\n    How did you manage to withstand the ravages of time?\n    You should have been dead for 384 years by now.\n---\n# Dear Maestro Leonardo\n\nI have received your latest letter\u2014delivered, I assume, by whatever ingenious flying\nmachine you are currently testing\u2014and feel compelled to clarify a few scientific\nmisunderstandings before you accidentally remove yourself from the timeline.\n\nFirst, while your enthusiasm for \"radiant essences\" is admirable, radioactivity is\nnot a universal power source. Your idea for a \"self-illuminating mechanical bird,\nanimated by glowing stones\" is creative, but such stones would send you flying only\ntoward the afterlife. Please wear gloves\u2014preferably very thick ones.\n\nSecond, I examined the sketch you enclosed, a contraption somewhere between a windmill,\na cauldron, and an umbrella. I cannot determine its purpose, but I urge caution. If it\nis meant to rotate, do not sit inside it. If it is meant to boil, do not sit inside it.\nIf it is meant to do both\u2026 absolutely do not sit inside it.\n\nLastly, you asked whether radioactive materials might accelerate human creativity.\nA flattering thought, but the glow around me is scientific, not -- as you\nsuggested -- \"proof of a supernatural muse.\" Should you begin to glow,\nI advise stepping away quickly.\n\nI remain deeply impressed by your mind, your sketches, and your relentless curiosity.\nShould you need help with physics\u2014or with identifying substances that should not go\ninto flying machines\u2014I remain at your service.\n\nWith great scientific affection,\n</code></pre> <pre><code>\\documentclass[\n  paper=a4,\n  parskip=half,\n  firstfoot=false,\n  enlargefirstpage=true,\n]{scrlttr2}\n\\usepackage{xcolor}\n\\definecolor{texsmithLinkColor}{HTML}{0B3D91}\n\\VAR{extra_packages}\n\\usepackage{graphicx}\n\\usepackage[\\VAR{babel_language|default('english')}]{babel}\n\\usepackage[\n    colorlinks=true,\n    linkcolor=texsmithLinkColor,\n    urlcolor=texsmithLinkColor,\n    citecolor=texsmithLinkColor]{hyperref}\n\\LoadLetterOption{\\VAR{letter_standard_option}}\n\\KOMAoptions{foldmarks=\\VAR{foldmarks_option}}\n\\BLOCK{ set margin_style = margin|default('default')|lower }\n\\BLOCK{ set margin_literal = margin_style not in [\"narrow\", \"default\", \"wide\"] }\n\\BLOCK{ if margin_style == \"narrow\" }\n\\KOMAoptions{fromalign=left, backaddress=false}\n\\setlength{\\oddsidemargin}{1cm}\n\\BLOCK{ elif margin_style == \"wide\" }\n\\KOMAoptions{fromalign=left, backaddress=false}\n\\setlength{\\oddsidemargin}{2cm}\n\\BLOCK{ elif margin_literal }\n\\KOMAoptions{fromalign=left, backaddress=false}\n\\setlength{\\oddsidemargin}{0cm}\n\\addtolength{\\textwidth}{-\\VAR{margin}}\n\\BLOCK{ endif }\n\\BLOCK{ if use_cursive_signature }\n\\setmainfont[Path=fonts/,Extension=.otf,Ligatures=Common,Mapping=]{modernline}\n\\newcommand{\\TexsmithLetterEndash}{\\kern0.05em-\\kern0.05em}\n\\newcommand{\\TexsmithLetterEmdash}{\\kern0.05em-\\kern0.05em-\\kern0.05em}\n\\catcode\"2013=\\active\n\\catcode\"2014=\\active\n\\begingroup\\lccode`~=\"2013\\lowercase{\\endgroup\\protected\\def~}{\\TexsmithLetterEndash}\n\\begingroup\\lccode`~=\"2014\\lowercase{\\endgroup\\protected\\def~}{\\TexsmithLetterEmdash}\n\\BLOCK{ endif }\n\n\\BLOCK{ if preamble }\n% Custom document preamble injected from overrides.\n\\VAR{preamble}\n\n\\BLOCK{ endif }\n\n\\BLOCK{ if use_cursive_signature }\n\\newfontfamily\\SignatureFont[Path=fonts/,Extension=.otf]{modernline}\n\\newcommand{\\SignatureText}[1]{{\\SignatureFont #1}}\n\\BLOCK{ else }\n\\newcommand{\\SignatureText}[1]{#1}\n\\BLOCK{ endif }\n\n\\newcommand{\\SignatureBlock}{%\n\\BLOCK{ if has_signature_image }\n  \\includegraphics[height=1.6cm]{\\VAR{signature_image_path}}\n  \\\\[-0.25\\baselineskip]%\n\\BLOCK{ endif }\n  \\SignatureText{\\VAR{signature_text}}%\n}\n\n\\setkomavar{fromname}{\\VAR{from_name}}\n\\setkomavar{fromaddress}{%\n\\BLOCK{ if has_sender_address }\n  \\VAR{from_address_lines|join('\\\\\\\\\\n')}\n\\BLOCK{ endif }\n}\n\\BLOCK{ if from_location_value -}\n\\setkomavar{location}{\\VAR{from_location_value}}\\BLOCK{ endif }\n\\BLOCK{ set effective_date = date_value|default('')|trim }\n\\setkomavar{date}{\\BLOCK{ if effective_date -}\n\\VAR{date_value}\\BLOCK{ else }\\today\\BLOCK{ endif }}\n\\BLOCK{ if has_subject }\n\\setkomavar{subject}{\\VAR{object_value}}\n\\setkomavar*{subject}{\\VAR{subject_prefix}}\n\\BLOCK{ endif }\n\\setkomavar{signature}{\\SignatureBlock}\n\\BLOCK{ if has_back_address }\n\\setkomavar{backaddress}{%\n  \\VAR{back_address_lines|join('\\\\\\\\\\n')}\n}\n\\BLOCK{ endif }\n\\BLOCK{ if reference_value }\n\\setkomavar{myref}{\\VAR{reference_value}}\n\\BLOCK{ endif }\n\\BLOCK{ if not reference_fields_enabled }\n\\removereffields\n\\BLOCK{ endif }\n\\renewcommand*{\\raggedsignature}{\\VAR{signature_alignment_command}}\n\n\\begin{document}\n\n\\begin{letter}{%\n\\BLOCK{ if has_recipient_address }\n  \\VAR{to_address_lines|join('\\\\\\\\\\n  ')}\n\\BLOCK{ else }\n  \\VAR{to_name}\n\\BLOCK{ endif }\n}\n\n\\opening{\\VAR{opening_text}}\n\n\\VAR{mainmatter}\n\n\\VAR{backmatter}\n\\VAR{fragment_backmatter}\n\n\\BLOCK{ if has_closing }\n\\closing{\\VAR{closing_text}}\n\\BLOCK{ endif }\n\\BLOCK{ if has_postscript }\n\\ps{PS: \\VAR{postscript_text}}\n\\BLOCK{ endif }\n\n\\end{letter}\n\\BLOCK{ if not page_numbers }\n\\pagenumbering{gobble}\n\\thispagestyle{empty}\n\\pagestyle{empty}\n\\BLOCK{ endif }\n\n\\end{document}\n</code></pre> <pre><code>[compat]\ntexsmith = \"&gt;=0.6,&lt;1.0\"\n\n[latex.template]\nname = \"formal-letter\"\nversion = \"0.1.0\"\nentrypoint = \"template/template.tex\"\nengine = \"xelatex\"\nshell_escape = false\ntexlive_year = 2023\ntlmgr_packages = [\n    \"babel\",\n    \"fontspec\",\n    \"microtype\",\n    \"koma-script\",\n]\ndescription = \"\"\"\nFormal letter template based on KOMA-Script with configurable\nsender/recipient and standards.\"\"\"\n\nfragments = [\n    \"ts-fonts\",\n    \"ts-extra\",\n    \"ts-keystrokes\",\n    \"ts-callouts\",\n    \"ts-code\",\n    \"ts-glossary\",\n    \"ts-bibliography\",\n    \"ts-todolist\",\n]\n\n[latex.template.attributes.cursive]\ndefault = false\ntype = \"boolean\"\nsources = [\"cursive\"]\ndescription = \"Toggle cursive signature font.\"\n\n[latex.template.attributes.language]\ndefault = \"en-UK\"\ntype = \"string\"\nallow_empty = false\nsources = [\"language\"]\ndescription = \"Language for babel.\"\n\n[latex.template.attributes.standard]\ndefault = \"\"\ntype = \"string\"\nsources = [\"standard\", \"format\"]\ndescription = \"Letter standard/format (e.g., sn, nf).\"\n\n[latex.template.attributes.date]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nallow_empty = true\nsources = [\"date\"]\n\n[latex.template.attributes.object]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"object\"]\ndescription = \"Subject line.\"\n\n[latex.template.attributes.from_name]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nallow_empty = false\nrequired = true\nsources = [\"from_name\"]\ndescription = \"Sender full name.\"\n\n[latex.template.attributes.from_address]\ndefault = []\ntype = \"list\"\nsources = [\"from_address\"]\n\n[latex.template.attributes.back_address]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"back_address\"]\n\n[latex.template.attributes.from_location]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"from_location\"]\n\n[latex.template.attributes.to_name]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nallow_empty = false\nrequired = true\nsources = [\"to_name\"]\ndescription = \"Recipient full name.\"\n\n[latex.template.attributes.to_address]\ndefault = []\ntype = \"list\"\nsources = [\"to_address\"]\n\n[latex.template.attributes.closing]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"closing\"]\ndescription = \"Closing phrase.\"\n\n[latex.template.attributes.opening]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"opening\"]\ndescription = \"Opening phrase.\"\n\n[latex.template.attributes.signature]\ndefault = \"\"\ntype = \"any\"\nsources = [\"signature\"]\ndescription = \"Signature block (text or raw LaTeX).\"\n\n[latex.template.attributes.source_dir]\ndefault = \"\"\ntype = \"string\"\nallow_empty = true\nformat = \"raw\"\nsources = [\"source_dir\"]\n\n[latex.template.attributes.output_dir]\ndefault = \"\"\ntype = \"string\"\nallow_empty = true\nformat = \"raw\"\nsources = [\"output_dir\"]\n\n[latex.template.attributes.signature_align]\ndefault = \"left\"\ntype = \"string\"\nsources = [\"signature_align\"]\n\n[latex.template.attributes.reference]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"reference\"]\ndescription = \"Reference field content.\"\n\n[latex.template.attributes.reference_fields]\ndefault = false\ntype = \"boolean\"\nsources = [\"reference_fields\"]\ndescription = \"Whether to render reference fields block.\"\n\n[latex.template.attributes.postscript]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\nsources = [\"postscript\"]\ndescription = \"Postscript paragraph.\"\n\n[latex.template.attributes.fold_marks]\ndefault = false\ntype = \"boolean\"\nsources = [\"fold_marks\"]\ndescription = \"Toggle fold marks.\"\n\n[latex.template.attributes.margin]\ndefault = \"default\"\ntype = \"string\"\nnormaliser = \"margin_style\"\nsources = [\"margin\"]\ndescription = \"Margin style (default, wide, narrow).\"\n\n[latex.template.attributes.preamble]\ndefault = \"\"\ntype = \"string\"\nallow_empty = true\nsources = [\"preamble\"]\n\n[latex.template.attributes.page_numbers]\ndefault = false\ntype = \"boolean\"\nsources = [\"page_numbers\"]\ndescription = \"Enable page numbers.\"\n\n[latex.template.slots.mainmatter]\ndefault = true\nbase_level = 10\nstrip_heading = true\n\n[latex.template.slots.backmatter]\nstrip_heading = true\n\n[latex.template.assets]\n\"fonts/modernline.otf\" = { source = \"fonts/modernline.otf\" }\n</code></pre> <p>To build the examples, use the following commands:</p> <pre><code>texsmith letter.md --build # for default format (DIN)\ntexsmith letter.md --build -aformat sn  # for SN format\ntexsmith letter.md --build -aformat nf  # for NF format\n</code></pre>"},{"location":"examples/letters/#standards","title":"Standards","text":""},{"location":"examples/letters/#din-5008","title":"DIN 5008","text":"<p>Among all existing standards, DIN 5008 is by far the most widely adopted reference for business correspondence in Germany. It prescribes layout rules, font sizes, margins, and a whole constellation of formatting details to guarantee consistency and professionalism in written communication. It is quite possibly the most detailed standard of its kind, specifying exact margin dimensions, the precise positioning of address blocks, the full structural blueprint of a professional letter, and fine-grained typographic conventions.</p> <p>I haven\u2019t personally dived into the full paid specification, but it\u2019s safe to assume that KOMA-Script\u2019s letter template draws heavily from it\u2014and by extension, so does TeXSmith.</p>"},{"location":"examples/letters/#nf-z-11-001","title":"NF Z 11-001","text":"<p>The former French AFNOR standard NF Z 11-001, replaced by ISO 269 back in 1998, defined the presentation rules for administrative letters in France. It described margins, address placement, letter structure, and typographic conventions intended to ensure clarity and uniformity in official documents. Although the standard is no longer active, it has left a lasting imprint on French administrative writing practices, and echoes of it can still be found in contemporary templates.</p>"},{"location":"examples/letters/#iso-214","title":"ISO 214","text":"<p>ISO 214 is an international standard specifying the layout conventions for commercial letters. It defines margins, address placement, structural order, and typographic rules to ensure a clear and professional presentation of business correspondence across borders. Its purpose is to harmonize commercial letter-writing practices between countries, smoothing out differences and making international communication a little more predictable.</p>"},{"location":"examples/letters/#why-we-ultimately-chose-scrlttr2","title":"Why We Ultimately Chose scrlttr2","text":"<p>While our documentation already covers the underlying standards that govern letter layout, what actually matters in practice is finding a tool that can embody these rules with precision, consistency, and a healthy respect for typographic sanity. This is the point where LATEX\u2014and specifically KOMA-Script\u2019s <code>scrlttr2</code>\u2014quietly distinguishes itself from the rest. Designed in the German tradition of rigorous typesetting, <code>scrlttr2</code> follows the logic of formal letter standards with an almost pedantic accuracy, offering a layout engine that behaves predictably and stays faithful to the structural constraints imposed by modern correspondence norms. Yet it remains flexible enough to emulate the conventions of other national styles without falling apart or requiring awkward hacks.</p> <p>In short, choosing <code>scrlttr2</code> was less about tradition and more about engineering. It gives us a letter typesetting engine that is standards-aware, robust enough for large-scale automation, and structured enough to keep our layouts consistent across contexts. It is not the easiest tool, nor the most forgiving, but for anyone who values correctness, longevity, and the quiet satisfaction of seeing a letter snap perfectly into place, it is simply the right one.</p>"},{"location":"examples/letters/#build-the-exemple-locally","title":"Build the exemple locally","text":"<p>To build the letter example locally, navigate to the <code>examples/letter</code> directory and run the following command:</p> <pre><code>git clone https://github.com/yves-chevallier/texsmith.git\ncd texsmith\nuv sync\ncd examples/letter\nmake\n</code></pre>"},{"location":"examples/paper/","title":"Paper","text":""},{"location":"examples/paper/#research-paper","title":"Research Paper","text":"<p>This example shows how TeXSmith can be used to write scientific papers with Markdown source, bibliographies, and figures. It uses the <code>article</code> template package, which provides a standard article layout with support for citations, cross-references, and floating figures/tables.</p> <p>The documentation preview uses the default A4 portrait layout. Click the image to download the PDF.</p> <pre><code>width: 70%\nfragments:\n  ts-frame\npress:\n  frame: true\nlayout: 2x2\ncwd: ../../examples/paper\nsources:\n  - cheese.md\n  - cheese.bib\ntemplate: article\n</code></pre> <p>Here is the source code for this example:</p> ArticleBibliography <pre><code>---\npress:\n  subtitle: &gt;\n    A Rheological Study on the Viscoelastic Properties of Aged Cheese Varieties\n  authors:\n    - name: Dr. Jane Q. Dairy\n      affiliation: Department of Food Mechanics, University of Edam, Netherlands\n    - name: Dr. John P. Curds\n      affiliation: Institute of Rheological Science, Swiss Cheese Laboratory\n  date: October 20, 2025\n  slots:\n    abstract: Abstract\nbibliography:\n  WADHWANI20111713: https://doi.org/10.3168/jds.2010-3952\n\n---\n# Mechanical Stiffness and Malleability of Hard Cheese\n\n## Abstract\n\nThe mechanical behavior of hard cheese varieties is a key determinant of their\nprocessing characteristics, textural perception, and overall quality. This study\ninvestigates the stiffness and malleability of aged cheeses by combining\nrheological theory and experimental measurements. A viscoelastic constitutive\nmodel is used to describe the dependence of the elastic modulus on strain rate\nand temperature. Compression tests were conducted on Parmigiano-Reggiano, Comt\u00e9,\nand aged Cheddar under controlled conditions. The results demonstrate significant\nvariability among cheese types, primarily influenced by moisture and fat content.\nComputational modeling using Python highlights the predictive capability of the\nproposed formulation. The findings provide a quantitative framework for linking\nthe microstructure of hard cheeses to their macroscopic mechanical response.\n\n## Introduction\n\nCheese, though traditionally perceived as a food product, can also be regarded\nas a **soft viscoelastic solid**, whose rheological response depends on both time\nand temperature. The interplay between its **elastic stiffness** --- resistance\nto deformation --- and **malleability** --- the capacity to deform without\nfracture --- defines its sensory and functional attributes [^Prentice1993].\n\nThe mechanical performance of hard cheeses arises from their intricate\n**protein\u2013fat\u2013moisture matrix**. Protein cross-linking, crystalline calcium\nphosphate domains, and residual fat globules act as reinforcing or plasticizing\nagents depending on aging and composition [^Jaoac2019]. Understanding these\nparameters is crucial not only for consumer perception (texture, crumble,\nbrittleness) but also for industrial operations such as slicing, shredding,\nand packaging.\n\nThis work presents an integrated experimental\u2013computational approach to quantify\nthe rheological stiffness and malleability of hard cheese varieties, using an\nempirical viscoelastic model to rationalize observed behavior across temperature\nand strain-rate ranges.\n\n## Theoretical Framework\n\nThe elastic modulus $E$ of a viscoelastic food material is modeled as a function\nof strain rate $\\dot{\\varepsilon}$ and temperature $T$:\n\n$$\nE(T, \\dot{\\varepsilon}) = E_0 \\left( 1 - \\alpha (T - T_0) \\right)\n\\left( 1 + \\beta \\ln \\frac{\\dot{\\varepsilon}}{\\dot{\\varepsilon}_0} \\right)\n$$\n\nwhere:\n\n* $E_0$: reference modulus at temperature $T_0$,\n* $\\alpha$: thermal softening coefficient,\n* $\\beta$: strain-rate sensitivity coefficient.\n\nEquation (1) assumes linear viscoelasticity and moderate deformation, conditions\ngenerally valid below the yield point of hard cheese. Increasing temperature\nreduces stiffness via thermally activated molecular mobility, whereas higher\nstrain rates enhance stiffness due to time-dependent stress relaxation suppression.\n\nThe **malleability**, defined here as the reciprocal of stiffness, becomes:\n\n$$\nM = \\frac{1}{E(T, \\dot{\\varepsilon})}\n$$\n\nThis formalism provides a convenient means to estimate the flexibility of cheese\nunder various thermal\u2013mechanical conditions, offering a bridge between empirical\ntexture measurements and predictive modeling.\n\n## Melting and Thermal Behavior\n\nThe melting characteristics of cheese are governed primarily by **fat content**,\n**moisture level**, and the degree of **protein\u2013fat network entanglement**. Hard\ncheeses typically display a melting range between **50 \u00b0C and 70 \u00b0C**, depending\non composition and aging.\n\nThermal analysis using **Differential Scanning Calorimetry (DSC)** allows the\ndetermination of onset and peak melting temperatures. In contrast, high-moisture\ncheeses such as Mozzarella [^1] exhibit lower melting points and greater\nstretchability due to reduced protein cross-link density [^WADHWANI20111713].\nThe figure [](#melting-behavior) illustrates the melting behavior of Mozzarella\ncheese, highlighting its unique rheological response upon heating.\n\n![Cheese melting behavior](mozzarella.svg){ width=80% }\n\n/// figure-caption\n    attrs: {id: melting-behavior}\nMelting behavior of high-moisture cheese (Mozzarella) illustrating stretchability\nupon heating\n///\n\n## Materials and Methods\n\n### Sample Preparation\n\nThree commercial hard cheese types were selected for analysis [](#cheese-samples).\nCylindrical specimens (20 mm diameter \u00d7 20 mm height) were extracted from the core\nregions and equilibrated at **10 \u00b0C** for 12 h prior to testing to minimize\nmoisture gradients.\n\n| Cheese Type         | Age (months) | Moisture Content (%) | Fat Content (%) |\n| ------------------- | ------------ | -------------------- | --------------- |\n| Parmigiano-Reggiano | 24           | 29                   | 31              |\n| Comt\u00e9               | 18           | 33                   | 30              |\n| Cheddar             | 12           | 36                   | 32              |\n\n/// table-caption\n    attrs: {id: cheese-samples}\nCharacteristics of hard cheese samples used in the study\n///\n\n### Mechanical Testing\n\nCompression tests were carried out using a **TA-XT2 texture analyzer** equipped\nwith a 50 kg load cell. Specimens were compressed at three nominal strain rates\n(0.1, 1, and 10 s\u207b\u00b9) to 20% strain. The **elastic modulus (E)** was obtained\nfrom the initial linear region (0\u20135 % strain) of the stress\u2013strain curve. The\ntable [](#mechanical-results) summarizes the measured moduli.\n\n| Cheese Type         | Strain Rate (s\u207b\u00b9) | Temperature (\u00b0C) | Elastic Modulus E (MPa) |\n| ------------------- | ----------------: | ---------------: | ----------------------: |\n| Parmigiano-Reggiano |               0.1 |               10 |                    52.1 |\n| Parmigiano-Reggiano |                10 |               10 |                    66.8 |\n| Comt\u00e9               |               0.1 |               10 |                    44.2 |\n| Cheddar             |               0.1 |               10 |                    38.7 |\n\n/// table-caption\n    attrs: {id: mechanical-results}\nMeasured elastic moduli of hard cheese samples at varying strain rates\n///\n\nThe increasing modulus with strain rate reflects the time-dependent viscoelastic\nresponse typical of aged dairy matrices.\n\n## Computational Modeling\n\nTo illustrate the relationship between stiffness, temperature, and deformation\nrate, the theoretical expression (Eq. 1) was implemented in **Python** as follows:\n\n``` python linenums=\"1\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpy.typing as npt\n\n\n# Constants\nE0 = 50.0  # Reference modulus (MPa)\nT0 = 10.0  # Reference temperature (\u00b0C)\nalpha = 0.02  # Thermal softening coefficient\nbeta = 0.15  # Strain-rate sensitivity\neps_dot0 = 1.0  # Reference strain rate\n\n\nArrayLike = npt.NDArray[np.float64] | float\n\n\ndef modulus(temperature: ArrayLike, strain_rate: float) -&gt; ArrayLike:\n    \"\"\"Return elastic modulus as a function of temperature and strain rate.\"\"\"\n    return E0 * (1 - alpha * (temperature - T0)) * (1 + beta * np.log(strain_rate / eps_dot0))\n\n\n# Compute modulus for a range of temperatures\ntemperatures = np.linspace(5, 25, 100)\nrates = [0.1, 1, 10]\n\nplt.figure(figsize=(6, 4))\nfor r in rates:\n    plt.plot(temperatures, modulus(temperatures, r), label=f\"\u03b5\u0307 = {r} s\u207b\u00b9\")\nplt.xlabel(\"Temperature (\u00b0C)\")\nplt.ylabel(\"Elastic Modulus E (MPa)\")\nplt.title(\"Temperature Dependence of Cheese Stiffness\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n```\n\nThis computational approach allows the parametric exploration of cheese stiffness\nunder varying conditions, offering predictive insight into texture control\nduring processing.\n\n## Discussion\n\nThe results corroborate the expected hierarchy of stiffness among hard cheeses,\nwith **Parmigiano-Reggiano** exhibiting the highest elastic modulus, consistent\nwith its lower moisture and greater protein cross-linking. The **Comt\u00e9** sample\ndemonstrated intermediate stiffness, while **Cheddar**, being relatively younger\nand moister, showed greater malleability.\n\nThe positive strain-rate dependence (via $\\beta &gt; 0$) implies that cheese behaves\nmore elastically under rapid deformation, an important consideration for high-speed\nindustrial slicing. Conversely, the temperature dependence ($\\alpha &gt; 0$) highlights\nthe need for strict temperature control during mechanical handling to maintain\nstructural integrity.\n\nThe modeling results align qualitatively with the empirical data, suggesting that\nthe simplified rheological model captures the dominant trends despite the inherent\ncomplexity of cheese microstructure.\n\n## Disclaimer\n\nThis paper is fictional and intended solely for illustrative purposes in demonstrating\ndocument formatting and structure. The data, authors, and affiliations are entirely\nfabricated and do not correspond to real individuals or institutions. Any resemblance\nto actual persons, organizations, or scientific studies is purely coincidental.\nThe purpose is to showcase the accurate conversion from Markdown to LaTeX format\nfor scientific publications.\n\n## Conclusions\n\nThis study integrates rheological experimentation and computational modeling to\nquantify the **stiffness\u2013malleability balance** of hard cheeses. The proposed\nformulation effectively predicts the combined influence of **temperature** and\n**strain rate** on the elastic modulus.\n\nSuch predictive tools can aid in optimizing industrial cheese handling, from cutting\nand packaging to consumer preparation, by linking measurable mechanical parameters to\nsensory texture and thermal stability.\n\nFuture work should extend the model to include **nonlinear viscoelasticity** and\n**moisture-dependent plasticization effects**, as well as **microstructural imaging\n(e.g., SEM, CLSM)** to directly correlate morphology with rheological behavior.\n\n;[^1]: A high-moisture cheese known for its stretchability when melted.\n</code></pre> <pre><code>@Inbook{Prentice1993,\nauthor=\"Prentice, J. H.\nand Langley, K. R.\nand Marshall, R. J.\",\neditor=\"Fox, P. F.\",\ntitle=\"Cheese Rheology\",\nbookTitle=\"Cheese: Chemistry, Physics and Microbiology: Volume 1 General Aspects\",\nyear=\"1993\",\npublisher=\"Springer US\",\naddress=\"Boston, MA\",\npages=\"303--340\",\nabstract=\"Rheology is formally defined as the study of the flow and deformation of matter. In everyday experience, not all cheeses appear to flow, though some of the softer ones, such as Brie or Camembert, obviously do. However, it will be shown later that under many conditions even the harder cheeses may be caused to flow. The second part of the definition, the study of deformation, is more immediately applicable to describing the properties of any cheese since deformation may embrace any aspect of the change of shape of a sample.\",\nisbn=\"978-1-4615-2650-6\",\ndoi=\"10.1007/978-1-4615-2650-6_8\",\nurl=\"https://doi.org/10.1007/978-1-4615-2650-6_8\"\n}\n\n@article{Jaoac2019,\n    author = {Bradley, Robert L, Jr and Vanderwarn, Margaret A},\n    title = {Determination of Moisture in Cheese and Cheese Products},\n    journal = {Journal of AOAC INTERNATIONAL},\n    volume = {84},\n    number = {2},\n    pages = {570-592},\n    year = {2019},\n    month = {11},\n    abstract = {Variables related to oven-drying samples of cheese and cheese products to determine moisture content were examined to provide more efficient and reproducible methods. Over 6500 samples of cheese were analyzed in an effort to modify the current AOAC procedure. The gravity atmospheric oven was unsuitable for use in accurate moisture analysis because of wide temperature differentials within the oven cavity. Use of this for oven moisture determination resulted in higher variance, which corresponded to the high temperature variation within the oven. Cheese sample preparation using an Oster blender yielded consistently lower variance in final moisture content than did preparation of cheese samples with a hand grater, rotary grater, and plug and plunger. Sample size of 3 \u00b1 0.25 g maximized surface area-to-volume ratios and yielded a lower error in final moisture content because of better control of ambient weight loss rates. Use of combination of disposable 5.5 cm diameter aluminum sample pans with 5.5 cm diameter glass fiber filter pads for covers produced a smaller standard deviation for moisture analysis than did the AOAC pan and insert cover and filter paper covers. All pans must be pre-dried for at least 3 h at 100\u00b0C, and the glass fiber covers should be pre-dried for 1 h under the same conditions. All dried pans and covers must be stored in a desiccator with active desiccant. Equipment upgrades from the existing AOAC standard methods provide safer more efficient methods of analysis.},\n    issn = {1060-3271},\n    doi = {10.1093/jaoac/84.2.570},\n    url = {https://doi.org/10.1093/jaoac/84.2.570},\n    eprint = {https://academic.oup.com/jaoac/article-pdf/84/2/570/32415847/jaoac0570.pdf},\n}\n</code></pre> <p>To render the example manually:</p> <pre><code>texsmith cheese.md cheese.bib -tarticle --build\n</code></pre> <p>Info</p> <p>Naturally, this article isn\u2019t an actual research paper! It\u2019s AI-generated content cooked up purely for demo purposes. One reference is real, though\u2014the one containing the original figure. I don\u2019t own the rights to that figure; I simply redrew it in vector form. All author names and the contents of the other references are completely fictional. Any resemblance to real people or publications is entirely coincidental\u2026 unless the cheese overlords say otherwise.</p> <p>Note</p> <p>I came up with this example because: (1) as a Swiss person, cheese is basically part of my operating system, and (2) when I was a student, a friend of mine did his PhD on cheese and collected delightfully absurd cheese-related research that nobody would imagine studying scientifically.</p> <p>I initially thought about an article on how Swiss music\u2014specifically yodeling\u2014might influence cheese ripening. But, well\u2026 rheology felt slightly more scientifically defensible.</p>"},{"location":"examples/snippets/","title":"Snippet Blocks","text":"<p>TeXSmith renders fenced blocks with the <code>.snippet</code> class into PDF/PNG pairs and injects them into the page with a download link. Snippets now accept a concise YAML payload instead of <code>data-*</code> attributes, and the PNG preview is left unframed so you can wrap it with the <code>ts-frame</code> fragment when needed.</p>"},{"location":"examples/snippets/#yaml-driven-snippets","title":"YAML-driven snippets","text":"<p>Use a YAML fence to point TeXSmith at your sources, working directory, and extra template options. The width of the rendered preview comes from the fence attribute.</p> <pre><code>```yaml {.snippet}\nlayout: 2x2\ncwd: ../../examples/paper\nsources:\n  - cheese.md\n  - cheese.bib\ntemplate: article\nwidth: 70%\nfragments:\n  ts-frame\npress:\n  frame: true\n```\n</code></pre> <ul> <li><code>cwd</code> is the directory where TeXSmith runs, resolving relative sources.</li> <li><code>sources</code> mirrors the CLI arguments: Markdown inputs and auxiliary files like <code>.bib</code>.</li> <li><code>layout</code> arranges multiple PDF pages on the preview grid.</li> <li><code>press</code> merges into the template context (fragments, format, etc.).</li> </ul>"},{"location":"examples/snippets/#inline-markdown-with-front-matter","title":"Inline Markdown with front matter","text":"<p>You can also render inline Markdown. Front matter drives the template choice and fragment selection while the body becomes the snippet content.</p> <pre><code>```md {.snippet caption=\"Inline snippet\" width=\"65%\"}\n---\ntemplate: snippet\nfragments:\n  ts-frame:\npress:\n  frame: true\n---\n# Section\n\nSome content...\n```\n</code></pre> <pre><code>---\ntemplate: snippet\nfragments:\n  ts-frame:\npress:\n  frame: true\n---\n# Section\n\nSome content...\n</code></pre>"},{"location":"examples/snippets/#reusing-a-configuration-file","title":"Reusing a configuration file","text":"<p>When the same snippet settings are shared across pages, point the fence to a YAML config and keep the block body empty or minimal.</p> <pre><code>```md {.snippet config=\"snippet-configs/letter.yml\" caption=\"Config-driven snippet\" width=\"70%\"}\n```\n</code></pre> <p>The configuration lives alongside this page at <code>docs/examples/snippet-configs/letter.yml</code>.</p>"},{"location":"examples/texsmith/","title":"TeXSmith","text":"<p>And of course, the grand finale\u2014the true climax of the project\u2014is that this very documentation can itself be converted into a LATEX document using TeXSmith.</p> <pre><code>git clone https://github.com/yves-chevallier/texsmith.git\ncd texsmith\nuv sync --with docs\nexport TEXSMITH_MKDOCS_BUILD=1 # Enable PDF build\nuv run texsmith mkdocs build\n</code></pre> <p>You can download it directly from the release page.</p>"},{"location":"guide/extensions/","title":"TeXSmith Extensions","text":"<p>TeXSmith ships its Markdown extensions directly inside the <code>texsmith</code> distribution. Once <code>pip install texsmith</code> is done, you can import them either via the <code>texsmith.extensions</code> registry or by using the extension modules (<code>texsmith.extensions.smallcaps</code>, <code>texsmith.index</code>, ...).</p> <p>Every extension follows the same structure:</p> <ul> <li>A Python-Markdown class or <code>makeExtension()</code> factory available as   <code>texsmith.extensions.&lt;name&gt;</code>.</li> <li>Optional renderer hooks (<code>register_renderer</code>) that teach the LATEX backend   how to deal with the extra HTML nodes created by the Markdown layer.</li> <li>Optional MkDocs plugins that keep search indexes in sync.</li> </ul>"},{"location":"guide/extensions/#built-in-extensions","title":"Built-in extensions","text":"<p>In order to align Markdown with LATEX capabilities, TeXSmith provides the following extensions under the <code>texsmith</code> namespace:</p> Module Purpose <code>texsmith.extensions.smallcaps</code> <code>__text__</code> syntax mapped to <code>&lt;span class=\"texsmith-smallcaps\"&gt;</code>. <code>texsmith.extensions.latex_raw</code> <code>/// latex</code> fences and <code>{latex}[x]</code> inline snippets injected as hidden HTML. <code>texsmith.extensions.latex_text</code> Styles the literal <code>LaTeX</code> token in running text. <code>texsmith.extensions.missing_footnotes</code> Warns about references to undefined footnotes. <code>texsmith.extensions.multi_citations</code> Normalises <code>^[foo,bar]</code> blocks to footnotes. <code>texsmith.extensions.mermaid</code> Inlines Mermaid diagrams pointed to by Markdown images. <code>texsmith.extensions.texlogos</code> Replaces TEX logo keywords with accessible HTML spans. <code>texsmith.index</code> Adds the <code>#[tag]</code> syntax, LATEX index handlers and an MkDocs plugin. <p>Inspect the registry programmatically if you want to discover the available extensions dynamically:</p> <pre><code>&gt;&gt;&gt; from texsmith.extensions import available_extensions\n&gt;&gt;&gt; [spec.package_name for spec in available_extensions()]\n['texsmith.index', 'texsmith.extensions.latex_raw', 'texsmith.extensions.latex_text', ...]\n</code></pre>"},{"location":"guide/extensions/#using-the-extensions-with-python-markdown","title":"Using the extensions with Python Markdown","text":"<p>Use the registry helper to instantiate an extension or import the shorthand module directly:</p> <pre><code>from markdown import Markdown\nfrom texsmith.extensions import load_markdown_extension\n\nextensions = [\n    load_markdown_extension(\"smallcaps\"),\n    load_markdown_extension(\"texlogos\"),\n    load_markdown_extension(\"index\"),\n]\nmd = Markdown(extensions=extensions)\nhtml = md.convert(\"`#[LaTeX]` renders a TeX logo and an index entry.\")\n</code></pre> <p>If you prefer the explicit class names the following also works:</p> <pre><code>from texsmith.index import TexsmithIndexExtension\n\nmd = Markdown(extensions=[TexsmithIndexExtension()])\n</code></pre>"},{"location":"guide/extensions/#register-extensions-in-mkdocs","title":"Register extensions in MkDocs","text":"<p>Once TeXSmith is installed you can reference the modules directly from <code>mkdocs.yml</code>:</p> <pre><code>markdown_extensions:\n  - texsmith.index\n  - texsmith.texlogos\n  - texsmith.extensions.smallcaps\n</code></pre> <p>The index extension also publishes an MkDocs plugin that injects collected tags into the <code>search_index.json</code>. Enable it next to the Markdown extension:</p> <pre><code>plugins:\n  - texsmith.index\n</code></pre> <p>When you use <code>mkdocs-texsmith</code> the plugin automatically appends both the Markdown extension and the MkDocs plugin unless you disable it with the <code>inject_markdown_extension</code> option.</p>"},{"location":"guide/extensions/#integrating-with-the-latex-renderer","title":"Integrating with the LATEX renderer","text":"<p>Extensions that need LATEX output expose renderer hooks via <code>register_renderer(renderer)</code>. TeXSmith calls those hooks during the CLI render pipeline, but you can reuse them in your own scripts:</p> <pre><code>from texsmith.adapters.latex import LaTeXRenderer\nfrom texsmith.index import register_renderer\n\nrenderer = LaTeXRenderer()\nregister_renderer(renderer)\nlatex_output = renderer.render(html_fragment)\n</code></pre> <p>If you want every built-in extension to register its renderer hook, call <code>texsmith.extensions.register_all_renderers(renderer)</code>.</p>"},{"location":"guide/extensions/#write-your-own-extensions","title":"Write your own extensions","text":"<p>You can create custom Markdown extensions that plug into TeXSmith's conversion pipeline. Refer to the API documentation for details on the extension points and how to register your extension with TeXSmith.</p>"},{"location":"guide/extensions/#pipeline-placement-precedence","title":"Pipeline placement &amp; precedence","text":"<ul> <li>Markdown extensions run before slot extraction and fragment rendering; any HTML they emit flows through the same pipeline.</li> <li>Renderer hooks execute in <code>RenderPhase</code> order (PRE \u2192 BLOCK \u2192 INLINE \u2192 POST); use the lowest required phase to keep transforms predictable.</li> <li>Extensions should not override template partials directly\u2014expose fragment partials or attributes instead so precedence stays transparent.</li> </ul>"},{"location":"guide/fonts/","title":"Fonts and scripts","text":"<p>TeXSmith automatically wraps non\u2011Latin scripts in moving arguments (headings, captions, index entries, \u2026) with per\u2011script font macros, using a cached lookup built from the Noto family. This gives fast, consistent multilingual output without manual fontspec boilerplate.</p>"},{"location":"guide/fonts/#inspect-detected-fallback-fonts","title":"Inspect detected fallback fonts","text":"<p>Use the render command with <code>--fonts-info</code> to display the scripts and fonts that were detected during a build. The flag works for both direct LATEX output and full template renders:</p> <pre><code>uv run texsmith examples/dialects/dialects.md --template article --fonts-info\n</code></pre> <p>The report includes:</p> <ul> <li>the script name and the generated LATEX commands (<code>\\text&lt;slug&gt;</code> / <code>\\&lt;slug&gt;font</code>);</li> <li>the font family chosen for that script (from the cached fallback index);</li> <li>the number of codepoints seen for that script in the current render.</li> </ul> <p>When Rich is available, the information is shown as a table; otherwise a plaintext list is printed. The option is non-intrusive and does not change the output artefacts.</p>"},{"location":"guide/front-matter/","title":"YAML Front Matter","text":"<p>Markdown supports a special section at the top of the document called \"front matter\" that allows you to specify metadata about the document. MkDocs or other static site generators use this section to configure page-specific settings.</p> <p>TeXSmith extends this functionality to include additional options that can influence how your Markdown files are processed and rendered into LATEX/PDF.</p>"},{"location":"guide/front-matter/#press","title":"Press","text":"<p>You can use the <code>press</code> option in the front matter to specify information related to TEX production:</p> <pre><code>press:\n  title: \"My Document Title\"\n  subtitle: \"An In-depth Exploration\"\n  template: article\n  authors:\n    - name: \"Alice Smith\"\n      affiliation: \"University of Examples\"\n  slots:\n    abstract: Abstract\n</code></pre> <p>Template-specific attributes can be referenced in the front matter as well. See the Template Guide for more details.</p>"},{"location":"guide/front-matter/#bibliography","title":"Bibliography","text":"<p>Bibliography entries can also be specified in the front matter. See the Bibliography Guide for more details.</p> <pre><code>bibliography:\n  AB2020: doi:10.1000/xyz123\n  CD2019:\n    type: book\n    author: \"John Doe\"\n    title: \"Example Book\"\n    year: \"2019\"\n</code></pre>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>In our journey to typeset beautiful documents with TeXSmith, we'll start with the basics:</p> <ol> <li>Turn Markdown or HTML into LATEX/PDF.</li> <li>Drop TeXSmith into an existing MkDocs site.</li> <li>Drive it from Python.</li> </ol> <p>Hop to the section you need or read straight through for the big picture.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<p>To install TeXSmith, use your preferred Python package manager:</p> pippipxuv <pre><code>pip install texsmith\n</code></pre> <pre><code>pipx install texsmith\n</code></pre> <pre><code>uv tool install texsmith\n</code></pre> <p>For basic use, you don't need anything else. TeXSmith bundles Tectonic for LATEX builds and will auto-install the required tools on demand.</p>"},{"location":"guide/getting-started/#convert-a-markdown-file-to-latex","title":"Convert a Markdown file to LATEX","text":"<p>By default TeXSmith writes LATEX to stdout. Pipe it or direct it into a folder. HTML works too:</p> Here documentFrom fileHTML <pre><code>cat &lt;&lt; EOF | texsmith\n# Title\n\nSome **bold** text.\n\n- Foo\n- Bar\nEOF\n\\section{Title}\\label{title}\n\nSome \\textbf{bold} text.\n\n\\begin{itemize}\n\\item{} Foo\n\\item{} Bar\n\n\\end{itemize}\n</code></pre> <pre><code>$ echo \"# Title\\nSome **bold** text.\" &gt; sample.md\n$ texsmith sample.md --output build/\n\\chapter{Title}\\label{title}\n\nSome \\textbf{bold} text.\n</code></pre> <pre><code>$ echo \"&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Some &lt;strong&gt;bold&lt;/strong&gt; text.&lt;/p&gt;\" &gt; sample.html\n$ texsmith sample.html\n\\chapter{Title}\nSome \\textbf{bold} text.\n</code></pre>"},{"location":"guide/getting-started/#generate-a-pdf","title":"Generate a PDF","text":"<p>Want the full PDF? Start with our playful booby example or create your own <code>booby.md</code>:</p> <pre><code>---\npress:\n  title: Booby\n  author: Yves Chevallier\n  date: 2025-11-16\n  template: article\n---\n## Introduction\n\nBoobies are seabirds in the genus *Sula*, family Sulidae. They are\nlarge, long-winged birds that plunge-dive for fish. The name \"booby\"\noriginates from the Spanish word \"bobo\", meaning \"stupid\" or \"clown\",\ndue to the birds' apparent lack of fear of humans.\n\n![Booby](booby.png){width=30%}\n\n## Particularities\n\nBoobies have several distinctive features:\n\n- They have brightly colored feet, which they use in mating displays.\n- They are known for their spectacular diving ability, plunging into\n  the water from great heights to catch fish.\n</code></pre> <p>Notice the front matter up top: it carries the title, author, date, and template to use.</p> <p>Then let TeXSmith crunch it:</p> <pre><code>texsmith booby.md --output build/ -apaper=a5 --build\n</code></pre> <p>With Tectonic as the default engine, fonts, packages, and dependencies resolve themselves on demand (including Tectonic if it is missing). Nothing else to install.</p> <p>Enjoy a fresh PDF at <code>build/booby.pdf</code>:</p> <pre><code>width: 70%\ncwd: ../../examples/booby\nsources:\n  - booby.md\nfragments:\n  ts-frame\npress:\n  frame: true\n</code></pre> <p>Peek inside <code>build/</code> to find <code>booby.tex</code>. Swap <code>--template</code> when you want a different LATEX project layout or polish level:</p> <pre><code>texsmith booby.md --template article --output-dir build\n</code></pre> <p>The default toolchain is <code>tectonic</code>, which auto-installs itself and required packages. If you prefer using your system LATEX installation, specify <code>--engine lualatex</code> or <code>--engine xelatex</code> instead. Both commands yield <code>doc.pdf</code> in the current directory. Open it to see the rendered output.</p> <p>If you want to customize the layout, choose a template with <code>--template article</code>, <code>--template book</code> or <code>--template your-own-template</code>.</p> <p>You may want to pass additional LATEX options such as <code>-apaper=a4</code> or <code>-amargin=1in</code> to tweak page geometry:</p>"},{"location":"guide/getting-started/#optional-prerequisites","title":"Optional prerequisites","text":"LATEX distribution Install TEX Live, MiKTeX, or MacTeX if you want TeXSmith to hand off builds to <code>latexmk</code> (<code>--engine lualatex</code> / <code>--engine xelatex</code>). The default route uses Tectonic, which auto-installs itself and required packages. Diagram tooling Mermaid-to-PDF (<code>minlag/mermaid-cli</code>) conversion falls back to Docker. Install Docker Desktop (with WSL integration on Windows) or register your own converter if Mermaid diagrams are common in your docs. <p>Draw.io and Mermaid diagrams try a Playwright exporter first (cached under <code>~/.cache/texsmith/playwright</code>), then the local CLI, then Docker (<code>rlespinasse/drawio-desktop-headless</code> / <code>minlag/mermaid-cli</code>). Use <code>--diagrams-backend=playwright|local|docker</code> to pin a specific backend.</p> Fonts TeXSmith ships with Noto fallback for wide Unicode coverage. Add your own fonts if you want a specific script or branded look. Legacy LATEX accents By default TeXSmith emits Unicode glyphs. If you need legacy LATEX accent macros, pass <code>--legacy-latex-accents</code> on the CLI or set <code>ConversionRequest(legacy_latex_accents=True)</code> in the API."},{"location":"guide/getting-started/#use-the-python-api","title":"Use the Python API","text":"<p>TeXSmith also ships as a Python library. Create <code>demo.py</code>:</p> <pre><code>from pathlib import Path\nfrom texsmith import Document, convert_documents\n\nbundle = convert_documents(\n    [Document.from_markdown(Path(\"intro.md\"))],\n    output_dir=Path(\"build\"),\n)\n\nprint(\"Fragments:\", [fragment.stem for fragment in bundle.fragments])\nprint(\"Preview:\", bundle.combined_output()[:120])\n</code></pre> <p>Run the snippet with <code>python demo.py</code>. The API mirrors the CLI; reach for <code>ConversionService</code> or <code>TemplateSession</code> when you need fine-grained control over slot assignments, diagnostics, or template metadata.</p>"},{"location":"guide/getting-started/#convert-a-mkdocs-site","title":"Convert a MkDocs site","text":"<p>Point TeXSmith at a MkDocs site after <code>mkdocs build</code> renders clean HTML:</p> <pre><code># Build your MkDocs site into a disposable directory\nmkdocs build\n\n# Convert one page into LaTeX/PDF-ready assets\ntexsmith build/site/guides/overview/index.html \\\n  --template article \\\n  --output-dir build/press \\\n  docs/references.bib\n</code></pre> <p>Tip</p> <p>The default selector (<code>article.md-content__inner</code>) already matches MkDocs Material content; skip <code>--selector</code> unless you heavily customise templates.</p> <p>When your site spans multiple documents, repeat the command per page and stitch them together with template slots (for example, <code>--slot mainmatter:build/site/manual/index.html</code>).</p> <p>For live previews, point TeXSmith at the temporary site directory that <code>mkdocs serve</code> prints on startup.</p> <p>Once the LATEX bundle looks good, add <code>--build</code> to invoke your engine of choice or wire it into CI so MkDocs HTML \u2192 TeXSmith PDF runs on every build.</p>"},{"location":"guide/limitations/","title":"Limitations","text":""},{"location":"guide/limitations/#highlighting-with-ucharclasses","title":"Highlighting with <code>ucharclasses</code>","text":"<p>The <code>ucharclasses</code> package allows you to define font transitions based on Unicode character classes. However, when using it in combination with the <code>soul</code> package for highlighting, there can be compatibility issues. For example, the following code may not work as expected:</p> <pre><code>\\documentclass{article}\n\\usepackage{soul}\n\\usepackage{fontspec}\n\\usepackage[Latin]{ucharclasses}\n\n\\setmainfont{Latin Modern Roman}\n\\setDefaultTransitions{\\rmfamily}{\\rmfamily}\n\\enableTransitionRules\n\\AtBeginDocument{\\enableTransitionRules}\n\n\\begin{document}\n\\hl{Foobar}\n\\end{document}\n</code></pre> <p>TeXSmith is meant to be compatible with XeLaTeX and LuaLaTeX, but due to the way <code>ucharclasses</code> handles font transitions, it may interfere with the highlighting functionality provided by <code>soul</code>. When TeXSmith detects XeLaTeX it now disables <code>soul</code> and falls back to a plain yellow <code>\\hl{...}</code> (no box). With LuaLaTeX it loads <code>lua-ul</code> instead of <code>soul</code>, keeping underlines without tripping over <code>ucharclasses</code>. Output therefore differs slightly between XeLaTeX and LuaLaTeX, but both builds succeed.</p>"},{"location":"guide/metadata/","title":"Metadata Conventions","text":"<p>TeXSmith normalises a handful of common front matter fields so that templates and fragments can rely on a single canonical name. External configuration files, CLI <code>--attribute</code> overrides, and Markdown <code>press.*</code> blocks are all merged before the template resolver runs, so manifests only need to reference the final attribute name (for example <code>emoji</code>, <code>glossary_style</code>, or <code>width</code>). The preprocessing stage keeps the full <code>press</code> tree available for backwards compatibility, but the rest of the codebase no longer needs to reference dotted <code>press.*</code> paths.</p>"},{"location":"guide/metadata/#authors","title":"Authors","text":"<p>Author metadata is validated with Pydantic and converted into a list of objects with <code>name</code> and <code>affiliation</code> keys. TeXSmith accepts a few flexible input shapes, but always prefers the <code>authors</code> key in the front matter. The following examples are all valid and will be converted into the canonical structure:</p> <pre><code>---\nauthors: \"Ada Lovelace\"\n---\n</code></pre> <pre><code>---\nauthors:\n  - \"Ada Lovelace\"\n  - \"Grace Hopper\"\n---\n</code></pre> <pre><code>---\nauthors:\n  - name: Ada Lovelace\n    affiliation: Analytical Engine\n  - name: Grace Hopper\n    affiliation: US Navy\n---\n</code></pre> <pre><code>---\nauthors:\n  name: Ada Lovelace\n  affiliation: Analytical Engine\n---\n</code></pre> <p>Each entry is trimmed, validated, and stored as <code>{ \"name\": ..., \"affiliation\": ... }</code>. If any entry is missing a name, TeXSmith raises an error before the template render begins.</p> <p>Although the front matter parser still understands the legacy <code>author</code> key, you should prefer the plural <code>authors</code> form so that your metadata mirrors the canonical shape.</p>"},{"location":"guide/metadata/#other-common-fields","title":"Other Common Fields","text":"<p>The same copying behaviour applies to the other common fields. If your document only declares:</p> <pre><code>---\ntitle: Sample Report\nsubtitle: Q2 Findings\ndate: 2024-07-01\n---\n</code></pre> <p>the resulting template context exposes <code>press.title</code>, <code>press.subtitle</code>, and <code>press.date</code>. Templates no longer look at the root-level keys, so you can always depend on the <code>press</code> namespace inside templates and fragments.</p>"},{"location":"guide/metadata/#attribute-ownership-consumers","title":"Attribute ownership &amp; consumers","text":"<ul> <li>Owner: each attribute belongs to either the template (default) or a fragment (<code>fragment.toml</code> attributes set <code>owner = &lt;fragment name&gt;</code> implicitly). Conflicting owners raise a <code>TemplateError</code>.</li> <li>Emitter: templates can surface derived attributes through <code>emit</code> in <code>manifest.toml</code> so renderers see both declared attributes and emitted helpers (for example, <code>callout_style</code> or <code>code.engine</code>).</li> <li>Consumer: any template/fragment/renderer code that reads the attribute. Consumers should only read attributes they own or that are explicitly emitted.</li> <li>Precedence: CLI/front matter overrides \u2192 attribute resolver (type coercion, normaliser, escape) \u2192 emitted defaults \u2192 render-time context.</li> </ul> <p>When adding new attributes, pick a single owner (template or fragment) and document the sources that are allowed to override it.</p>"},{"location":"guide/mkdocs/","title":"Integration with MkDocs","text":"<p>TeXSmith can be seamlessly integrated with MkDocs, a popular static site generator for project documentation. This allows you to leverage MkDocs' powerful features while utilizing TeXSmith for document generation.</p> <p>The integration is achieved through the <code>mkdocs-texsmith</code> plugin, which processes TeXSmith documents during the MkDocs build process.</p>"},{"location":"guide/mkdocs/#configuration","title":"Configuration","text":"<p>To enable TeXSmith in your MkDocs project, you need to add the <code>mkdocs-texsmith</code> plugin to your <code>mkdocs.yml</code> configuration file:</p> <pre><code>plugins:\n  - texsmith\n</code></pre> <p>You can configure additional options for the TeXSmith plugin as needed:</p> Option Description Default <code>template</code> Template to use for rendering the site <code>book</code> <code>build_dir</code> Directory where TeXSmith outputs are stored <code>site</code>"},{"location":"guide/mkdocs/#multiple-documents","title":"Multiple documents","text":"<p>You can either generate a single document from your MkDocs site or multiple documents from different sections.</p> <pre><code>plugins:\n    - texsmith:\n      books:\n        - template: book\n          folder: foolists\n          root: \"foo\"\n          base_level: -1\n        - template: article\n          folder: bariers\n          root: \"bar\"\n</code></pre>"},{"location":"guide/mkdocs/#serve","title":"Serve","text":"<p>During development with <code>mkdocs serve</code>, the TeXSmith plugin can fetch assets from the web (e.g. images, citations) and compile PDF snippets on the fly. This allows for a smooth writing experience with instant feedback.</p>"},{"location":"guide/mkdocs/#build","title":"Build","text":"<p>When you run <code>mkdocs build</code>, the TeXSmith plugin processes all TeXSmith documents in your project, generating the corresponding PDFs and integrating them into the final site output. By default the output directory is <code>press/</code>.</p> <p>You can tell TeXSmith to build the PDF during the process with the <code>build</code> option in your mkdocs.yml:</p> <pre><code>plugins:\n  - texsmith:\n      build: true\n</code></pre>"},{"location":"guide/tectonic/","title":"Tectonic Engine","text":"<p>Tectonic is the default PDF engine in TeXSmith. It bundles automatic package fetching, fast incremental builds, and minimal setup -- ideal for CI pipelines and lightweight containers. You can switch to <code>latexmk</code> with <code>--engine lualatex</code> or <code>--engine xelatex</code> when you need full control of the traditional toolchain.</p>"},{"location":"guide/tectonic/#install-tectonic","title":"Install Tectonic","text":"<ul> <li>macOS: <code>brew install tectonic</code></li> <li>Ubuntu/Debian: <code>sudo apt install tectonic</code> (or <code>cargo install tectonic</code>)</li> <li>Fedora: <code>sudo dnf install tectonic</code></li> <li>Windows: <code>scoop install tectonic</code> or <code>choco install tectonic</code></li> <li>Fallback: grab a prebuilt archive from https://tectonic-typesetting.github.io/ and put   the <code>tectonic</code> binary on your <code>PATH</code>.</li> </ul> <p>After installation, run <code>tectonic --version</code> to confirm the binary is available.</p>"},{"location":"guide/tectonic/#building-with-tectonic","title":"Building with Tectonic","text":"<ul> <li>CLI: <code>texsmith notes.md --template article --build</code> uses Tectonic automatically.</li> <li>Latexmk: add <code>--engine lualatex</code> (or <code>--engine xelatex</code>) to opt into the latexmk +   <code>.latexmkrc</code> flow.</li> <li>API: call <code>ConversionService.build_pdf(render_result, engine=\"tectonic\")</code> after   rendering a template.</li> </ul> <p>TeXSmith still checks for optional helpers -- <code>biber</code>, <code>makeindex</code>/<code>texindy</code>, <code>makeglossaries</code> -- and reports anything missing before the engine runs.</p>"},{"location":"guide/troubleshooting/","title":"Troubleshooting LATEX Builds","text":"<p>Running <code>texsmith --build</code> shells out to your selected engine (Tectonic by default, <code>latexmk</code> when <code>--engine</code> is set to <code>xelatex</code>/<code>lualatex</code>), <code>bibtex</code>/<code>biber</code>, and any template assets declared in <code>manifest.toml</code>. When those tools fail, the CLI will highlight the failing step and (optionally) open the log file. Use this page to decode the most common issues.</p>"},{"location":"guide/troubleshooting/#enable-rich-diagnostics","title":"Enable rich diagnostics","text":"<ul> <li>Add <code>-v</code> or <code>-vv</code> to surface structured diagnostics from the conversion pipeline (missing slots, unresolved citations, asset copy failures).</li> <li>Pass <code>--debug</code> to print full Python tracebacks if TeXSmith itself throws.</li> <li>Combine <code>--classic-output</code> with CI logs when you need deterministic engine output, or keep the default rich output locally for incremental updates.</li> <li>When the engine exits non-zero, re-run with <code>--open-log</code> to jump directly into the <code>.log</code> file.</li> </ul>"},{"location":"guide/troubleshooting/#latexmk-not-found","title":"latexmk not found","text":"<p>Symptom: <code>latexmk: command not found</code> or TeXSmith reports it cannot spawn the binary.</p> <p>Fix: Ensure your TEX Live/MacTeX/MiKTeX distribution added <code>latexmk</code> to <code>PATH</code>. On macOS, <code>eval \"$(/usr/libexec/path_helper -s)\"</code> after installing MacTeX. On Windows, open the \u201cLATEX apps\u201d PowerShell and run TeXSmith from there.</p>"},{"location":"guide/troubleshooting/#tectonic-not-found","title":"tectonic not found","text":"<p>Symptom: <code>tectonic: command not found</code> or TeXSmith reports missing dependencies before starting the build.</p> <p>Fix: Install Tectonic from your package manager (<code>brew install tectonic</code>, <code>apt install tectonic</code>, or <code>cargo install tectonic</code>) or download a prebuilt binary from https://tectonic-typesetting.github.io/. Ensure the <code>tectonic</code> executable is on <code>PATH</code> before re-running TeXSmith. You can also switch to <code>--engine lualatex</code>/<code>xelatex</code> to keep using <code>latexmk</code>.</p>"},{"location":"guide/troubleshooting/#missing-tlmgr-packages","title":"Missing tlmgr packages","text":"<p>Symptom: <code>LaTeX Error: File &lt;package&gt;.sty not found</code>.</p> <p>Fix: Run <code>texsmith --template &lt;NAME&gt; --template-info</code> and install the listed tlmgr packages (<code>tlmgr install ...</code>). Distributions with minimal profiles (BasicTeX, MikTeX) require this step for every template.</p>"},{"location":"guide/troubleshooting/#shell-escape-blocked","title":"Shell-escape blocked","text":"<p>Symptom: <code>shell escape feature is not enabled</code> when templates run <code>minted</code>, <code>gnuplot</code>, or diagram converters.</p> <p>Fix: <code>texsmith --template-info</code> indicates whether <code>shell_escape</code> is required. Re-run <code>texsmith --build --classic-output</code> to confirm the flag. With <code>--engine lualatex</code>/<code>xelatex</code>, edit your TEX Live config or pass <code>latexmk -shell-escape</code> by exporting <code>LATEXMKOPT=\"-shell-escape\"</code>. If you're using Tectonic, switch to <code>--engine lualatex</code> when you need tighter control over <code>-shell-escape</code>.</p>"},{"location":"guide/troubleshooting/#bibliography-failures","title":"Bibliography failures","text":"<p>Symptom: <code>biber</code>/<code>bibtex</code> errors such as <code>I couldn't open database file</code> or duplicate citation keys.</p> <p>Fix:</p> <ul> <li>Run <code>texsmith references.bib --list-bibliography</code> to validate files before building.</li> <li>Make sure every bibliography file you pass as input exists and is UTF-8 encoded.</li> <li>If <code>biber</code> complains about encoding, add <code>encoding = \"UTF-8\"</code> to your template manifest bibliography section or normalise via <code>pybtex</code>.</li> </ul>"},{"location":"guide/troubleshooting/#figures-or-diagrams-missing","title":"Figures or diagrams missing","text":"<p>Symptom: Placeholder boxes in the PDF and warnings like <code>Converter 'mermaid' is disabled</code>.</p> <p>Fix: Install optional converters (Docker + <code>minlag/mermaid-cli</code>, Draw.io CLI, etc.) or register custom converters in <code>texsmith.adapters.transformers</code>. Use <code>--no-fallback-converters</code> during debugging to make missing dependencies fail fast.</p>"},{"location":"guide/troubleshooting/#fonts-or-language-mismatches","title":"Fonts or language mismatches","text":"<p>Symptom: <code>Package polyglossia Error</code> or <code>fontspec</code> warnings after switching languages.</p> <p>Fix: Ensure the <code>press.language</code> metadata (front matter or CLI <code>--language</code>) maps to a Babel/Polyglossia identifier. Refer to <code>texsmith --template-info</code> to confirm defaults and install any necessary language packages (e.g., <code>tlmgr install babel-french</code>).</p>"},{"location":"guide/troubleshooting/#still-stuck","title":"Still stuck?","text":"<ol> <li>Re-run with <code>--debug --classic-output -vv</code> to capture both TeXSmith diagnostics and raw <code>latexmk</code> logs.</li> <li>Attach the failing <code>.log</code> plus your template manifest when filing an issue.</li> <li>Mention your TEX distribution and operating system so maintainers can reproduce the environment.</li> </ol>"},{"location":"guide/features/acronyms/","title":"Acronyms","text":"<p>Acronyms are abbreviations formed from the initial components of words or phrases, usually individual letters (e.g., NASA, HTML). They are commonly used in technical writing to simplify complex terms and improve readability.</p>"},{"location":"guide/features/acronyms/#syntax","title":"Syntax","text":"<p>Following the pattern in MkDocs and the <code>abbr</code> extension, TeXSmith supports defining acronyms like this:</p> <pre><code>The National Aeronautics and Space Administration NASA is responsible for the\ncivilian space program.\n\n*[NASA]: National Aeronautics and Space Administration is responsible for the civilian space program. APOLLO 11 was one of its most famous missions in which humans first landed on the Moon.\n</code></pre> <pre><code># Acronyms\n\nThe National Aeronautics and Space Administration NASA is responsible for the\ncivilian space program.\n\n*[NASA]: National Aeronautics and Space Administration is responsible for the civilian space program. APOLLO 11 was one of its most famous missions in which humans first landed on the Moon.\n</code></pre> <p>Note</p> <p>Due to LATEX limitations, acronyms must be in a single paragraph. Multi-paragraph acronyms are not yet supported.</p>"},{"location":"guide/features/bibliography/","title":"Bibliography","text":"<p>TeXSmith reads bibliographic data from BibTeX files and from YAML front matter. Use it to keep citations and references tidy in academic writing, technical docs, or any project that wants repeatable citation management.</p>"},{"location":"guide/features/bibliography/#using-bibliography-files","title":"Using Bibliography Files","text":"<p>Pass one or more <code>.bib</code> files on the command line:</p> <pre><code>texsmith docs/chapter.md references.bib\n</code></pre> <p>You can also add <code>file1.bib file2.bib</code> as positional inputs alongside a MkDocs site so every page sees the same pool of references.</p>"},{"location":"guide/features/bibliography/#using-the-front-matter","title":"Using the front matter","text":"<p>You can declare bibliography entries directly in the YAML front matter of your Markdown documents:</p> <pre><code>bibliography:\n  # Extract citation from DOI\n  citation-keyword: https://doi.org/10.1000/xyz123\n  # Manual bibliography entry\n  AI2027:\n    type: misc\n    title: AI 2027\n    date: 2025-04-03\n    url: https://ai-2027.com/ai-2027.pdf\n    authors:\n      - Daniel Kokotajlo\n      - Scott Alexander\n      - Thomas Larsen\n      - first: Eli\n        last: Lifland\n      - Romeo Dean\n</code></pre> <p>The format mirrors BibTeX, translated to YAML by <code>pybtex</code>.</p> <p>Two approaches:</p> <ol> <li>Provide a DOI link; TeXSmith resolves it into a full BibTeX entry.</li> <li>Provide a manual entry with the fields you need.</li> </ol> <p>See the academic paper example or the book example.</p>"},{"location":"guide/features/bibliography/#citation-syntax","title":"Citation Syntax","text":"<p>Citations use the footnote-style syntax:</p> <pre><code>---\nbibliography:\n  WADHWANI20111713: https://doi.org/10.3168/jds.2010-3952\n---\n# Introduction\n\nCheese exhibits unique melting properties [^WADHWANI20111713].\n</code></pre> <p>Which renders into:</p> <pre><code>---\nwidth: 70%\nbibliography:\n  WADHWANI20111713: https://doi.org/10.3168/jds.2010-3952\n---\n# Introduction\n\nCheese exhibits unique melting properties [^WADHWANI20111713].\n</code></pre> <p>If a citation key is missing from your bibliography, TeXSmith leaves it as a regular footnote. If a footnote exists with the same key, the footnote wins over the bibliography entry.</p>"},{"location":"guide/features/bibliography/#bibtex","title":"BibTeX","text":"<p>BibTeX is an old, loosely specified format with many dialects (<code>bibtex</code>, <code>bibtex8</code>, <code>pbibtex</code>, and more). The most complete parser is biber, but it is Perl-based and not embeddable. TeXSmith relies on pybtex, which covers the common cases.</p>"},{"location":"guide/features/headings/","title":"Headings","text":"<p>Headings are your document's scaffold: Markdown <code>#</code> marks become LATEX <code>\\section</code>, <code>\\subsection</code>, and friends. TeXSmith retunes them using template settings, document base levels, and promotion rules so the hierarchy stays sane even when the source is messy.</p> <p>Markdown is loose: some files start at <code>##</code>, others at <code>###</code>, and multi-file builds mix it all. TeXSmith computes offsets per fragment to line things up: find the shallowest heading, derive an offset, then add the template base level. This page walks that math, how title promotion changes it, and how slots keep fragments independent.</p>"},{"location":"guide/features/headings/#how-offsets-are-computed","title":"How offsets are computed","text":"<ol> <li>Drop any sections routed to slots (e.g. <code>abstract</code>) before aligning the remaining content for that slot.</li> <li>If promotion is on and the first heading is uniquely the highest, it becomes metadata and is ignored for offsets.</li> <li>Look at the shallowest heading that remains:</li> <li><code>&lt;h1&gt;</code> \u2192 offset <code>0</code></li> <li><code>&lt;h2&gt;</code> \u2192 offset <code>-1</code></li> <li><code>&lt;h3&gt;</code> \u2192 offset <code>-2</code></li> <li>No headings \u2192 offset <code>0</code></li> <li>The effective base level for a fragment is:</li> </ol> <pre><code>template slot base + document base_level + fragment offset\n</code></pre> <ol> <li>The rendered LATEX level is <code>html_level + effective_base - 1</code>.</li> </ol> <p>Offsets are per fragment: each slot fragment gets its own pass, so moving a heading into an abstract slot cannot force the main matter down a level.</p>"},{"location":"guide/features/headings/#template-and-document-base-levels","title":"Template and document base levels","text":"<p>Classic LATEX classes anchor headings differently: <code>article</code> tops out at <code>\\section</code>, while <code>memoir</code> can start at <code>\\chapter</code> or <code>\\part</code>. Templates encode that base level per slot: abstract as a section, main matter as a chapter, etc. Adjust it per document via front matter or CLI; the template default is used if you set nothing.</p> Front matterCLI <pre><code>press:\n  template: book\n  base_level: chapter # To not use parts by default\n</code></pre> <pre><code>texsmith doc.md --template book --base-level chapter\n</code></pre>"},{"location":"guide/features/headings/#promotion-rules","title":"Promotion rules","text":"<p>Promotion lifts the first heading into the document title. Because that heading leaves the body, the next shallowest heading drives the offset. Promotion is on by default: if there is no metadata title and the first heading is uniquely the shallowest, it is promoted and skipped in the offset math.</p> <p>A declared <code>title</code> in front matter disables promotion. So do <code>--no-promote-title</code> on the CLI and <code>TitleStrategy.NONE</code> in the Python API.</p> <p><code>--strip-heading</code> / <code>TitleStrategy.DROP</code> removes the first heading without promoting it.</p> <p>Want an explicit title plus promotion? Declare <code>title</code>, keep promotion on, and the declared title wins while headings are still measured against the remaining body.</p>"},{"location":"guide/features/headings/#worked-examples","title":"Worked examples","text":"<p>All examples use the <code>article</code> template (<code>base_level=section</code>):</p> <ul> <li>Metadata title present; headings start at <code>##</code>: fragment offset <code>-1</code> + template base <code>1</code> \u2192 first heading renders as <code>\\section</code>, nested <code>###</code> as <code>\\subsection</code>.</li> <li>No metadata title; first heading is <code># Title</code>: it is promoted and ignored for offsets, so the remaining <code>##</code> headings still become <code>\\section</code>.</li> <li>Headings begin at <code>##</code> with no <code>#</code> anywhere: offset <code>-1</code> again, so the highest heading still aligns to <code>\\section</code>.</li> <li>Slot extraction: if <code># Abstract</code> is routed to the <code>abstract</code> slot and stripped there, the remaining main-matter fragment starts at <code>##</code> and is aligned to <code>\\section</code> (the removed <code>#</code> does not push sections down to subsections).</li> </ul>"},{"location":"guide/features/headings/#multidocument-behavior","title":"Multidocument behavior","text":"<p>When rendering multiple documents, each document (and each of its slot fragments) computes its own offset independently. A root title in a multi-file build does not block promotion in subdocuments, and each slot still adds the template base level before applying the fragment offset.</p>"},{"location":"guide/features/headings/#quick-reference","title":"Quick reference","text":"<ul> <li>Offsets are <code>1 - shallowest_heading_level</code> after promotion/slot stripping.</li> <li>Effective base = template slot base + document <code>base_level</code> + fragment offset.</li> <li>Promotion is default; disable with <code>--no-promote-title</code> or a declared title.</li> <li>Slots are aligned independently; moving a heading to a slot never changes the   offset of the remaining content.</li> </ul>"},{"location":"guide/features/listings/","title":"Code listings","text":"<p>TeXSmith bundles a single fragment, <code>ts-code</code>, that can render fenced code blocks with four different engines:</p> <code>pygments</code> (default) highlights code with Pygments at render time and injects the generated macros into <code>ts-code.sty</code>. No shell escape is required and the output works with XeLaTeX and Tectonic. Not suited for editing the LATEX output directly. <code>listings</code> uses the LATEX <code>listings</code> package inside a <code>tcolorbox</code>. Good for pure LATEX workflows without shell escape, but no automatic line highlighting. <code>verbatim</code> plain <code>fvextra</code>/<code>Verbatim</code> output wrapped in a tcolorbox. Useful when you want zero styling or external dependencies. <code>minted</code> Enhanced version of listings that shells out to <code>pygmentize</code>. This needs <code>--shell-escape</code> and is disabled by default for compatibility with sandboxed engines such as Tectonic."},{"location":"guide/features/listings/#choosing-an-engine","title":"Choosing an engine","text":"<p>If you need to use one, pick the engine in front matter or via the CLI template override:</p> <pre><code>---\npress:\n  code:\n    engine: listings  # verbatim | listings | minted | pygments\n---\n</code></pre> <pre><code>texsmith input.md -a code.engine=verbatim\n</code></pre> <p>The choice is global for a render. Inline code only uses <code>minted</code> when the engine is set to <code>minted</code>; otherwise it falls back to <code>\\texttt{\u2026}</code>.</p>"},{"location":"guide/features/listings/#pygments-pipeline-details","title":"Pygments pipeline details","text":"<p>When <code>code.engine=pygments</code>, TeXSmith runs Pygments during conversion and writes the highlighted LATEX directly into the <code>code</code> environment. All required style definitions are collected once per render and injected into <code>ts-code.sty</code>, so no external calls are made during LATEX compilation. Highlighted lines and line numbers from the Markdown source are preserved.</p> <p>This engine is the most flexible and works with all TEX engines supported by TeXSmith, including Tectonic.</p> <p>Furthermore, it is much faster than <code>minted</code> since it avoids shelling out during LATEX compilation.</p>"},{"location":"guide/features/listings/#shell-escape-behavior","title":"Shell-escape behavior","text":"<p>Shell escape is requested automatically when the minted engine is active or other features need it. With <code>pygments</code>, <code>listings</code>, or <code>verbatim</code>, <code>.latexmkrc</code> will not add <code>--shell-escape</code>, keeping builds compatible with engines like Tectonic.</p> <p>Note</p> <p>By default TEX disables shell escape for security reasons. Only enable it if you trust the source of your documents. Shell escape allows LATEX to run arbitrary commands on your system during compilation. This behavior is strongly discouraged by the Tectonic team and disabled by default.</p>"},{"location":"guide/features/tags/","title":"Tags","text":""},{"location":"guide/features/tags/#index-generation","title":"Index Generation","text":"<p>In static site generators such as MkDocs, every build emits a <code>search_index.json</code> file consumed by Lunr.js or Wasabi directly in the browser. It lists every word encountered in the documentation along with its locations, enabling instant client-side search. That automation works wonderfully for HTML, but printed documents require a static index compiled ahead of time.</p> <p>Traditional LATEX editing relies on <code>\\index{term}</code> commands sprinkled throughout the source. After compilation you run <code>makeindex</code> or <code>xindy</code>, which produces the final index file included near the end of the document. TeXSmith mirrors that workflow: it turns Markdown annotations into LATEX <code>\\index{...}</code> calls and triggers <code>makeindex</code>/<code>xindy</code> while building the PDF.</p> <p>The LATEX form still looks familiar:</p> <pre><code>\\index{term!subterm}\n\\index{another term}\n\\index{\\textbf{important term}}\n\\index{\\emph{emphasized term}}\n</code></pre> <p>Thus, index entries can:</p> <ul> <li>be nested up to 3 levels,</li> <li>be rendered in bold, italic, or both,</li> <li>appear multiple times in the document, with all page numbers listed.</li> </ul> <p>To mimic this behavior in Markdown, the <code>texsmith.index</code> extension provides the hashtag syntax:</p> <pre><code>#[a] One level index entry in the default index\n#[a][b][c] Three-level entry in the default index\n{index:registry}[Foo][Bar] Entry nested twice under the `registry` index\n#[*a*] Formatted index entry in default index\n#[**a**] Bold formatted index entry in default index\n#[***a***] Bold italic formatted index entry in default index\n#[a] #[b] Multiple index entries in one place\n</code></pre>"},{"location":"guide/features/tags/#emphasis-and-formatting","title":"Emphasis and Formatting","text":"<p>Printed indexes often differentiate how important an entry is within a section:</p> <ul> <li>Normal text: the term is discussed in that section (default).</li> <li>Bold: the term is the main topic of that section.</li> <li>Italic: the term is mentioned but not deeply discussed.</li> <li>Bold italic: the term is the main topic and also referenced elsewhere in the same section.</li> </ul> <p>Because the hashtag syntax accepts Markdown formatting, just wrap the indexed term in the appropriate markers (e.g. <code>#[**topic**]</code>).</p>"},{"location":"guide/features/tags/#nested-entries","title":"Nested Entries","text":"<p>Consider a cooking book where you want to index the recipe for \"Chocolate Cake\". You might want to add an index entry for \"Cake\" with a sub-entry for \"Chocolate\" and also in \"Chocolate Cake\":</p> <pre><code>## Chocolate Cake\n\n#[cake][**chocolate**] #[chocolate cake]\n</code></pre> <p>LATEX only supports up to 3 levels of nesting:</p> <pre><code>#[cake]\n#[cake][**chocolate**]\n#[dessert][cake][chocolate]\n</code></pre>"},{"location":"guide/features/tags/#tags","title":"Tags","text":"<p>In MkDocs, search powered by Lunr.js automatically adds tags on headings to improve searchability. From an HTML perspective the extension emits invisible spans such as <code>&lt;span class=\"ts-hashtag\" data-tag=\"term\" data-style=\"b\"&gt;</code>. The LATEX renderer converts them into the proper <code>\\index{...}</code> call while the MkDocs plugin collects the same metadata to enrich Lunr\u2019s search index. This keeps the PDF index and the interactive site search in sync even though they are generated through different pipelines.</p>"},{"location":"guide/fragments/","title":"Fragments","text":"<p>Fragments are reusable LATEX snippets injected into template slots. Built-in fragments (e.g., geometry, fonts, glossary, index) and custom ones share the same structure:</p> <ul> <li><code>fragment.toml</code> with <code>name</code>, <code>description</code>, and either an <code>entrypoint</code> or a <code>files</code> list.</li> <li>Optional <code>attributes</code> section describing fragment-owned attributes (ownership enforced).</li> <li>Optional <code>partials</code> block for fragment-scoped partial overrides and <code>required_partials</code> for dependencies.</li> <li>Optional <code>should_render</code> logic (via entrypoint) to render only when needed.</li> </ul>"},{"location":"guide/fragments/#manifest-shape","title":"Manifest shape","text":"<pre><code>name = \"my-fragment\"\ndescription = \"Short description.\"\n\n[files.0]\npath = \"my-fragment.jinja.sty\"  # or .tex\nslot = \"extra_packages\"\ntype = \"package\"                # package | input | inline\noutput = \"my-fragment\"\n\n[attributes.option]\ndefault = true\ntype = \"boolean\"\nsources = [\"press.option\", \"option\"]\ndescription = \"Controls feature X.\"\n</code></pre> <p>If you prefer Python logic, point <code>entrypoint</code> at a callable returning a <code>BaseFragment</code> instance.</p>"},{"location":"guide/fragments/#fragment-pieces","title":"Fragment pieces","text":"<ul> <li><code>package</code>: rendered to a <code>.sty</code> file and injected via <code>\\usepackage</code> into the target slot.</li> <li><code>input</code>: rendered to <code>.tex</code> and injected via <code>\\input{}</code> into the target slot.</li> <li><code>inline</code>: rendered string injected directly into the slot variable (no file emitted).</li> </ul> <p>Slots are validated against the template at render time; inline injections must match declared slots or template variables.</p>"},{"location":"guide/fragments/#attributes","title":"Attributes","text":"<p>Fragments can declare attributes (ownership enforced) and resolve overrides using the same <code>TemplateAttributeSpec</code> model as templates. Attribute defaults are injected into the context before rendering fragment pieces. Attribute ownership matters: if two fragments (or a template) claim the same attribute name, TeXSmith raises a <code>TemplateError</code>. Keep each attribute owned by a single fragment or the template to avoid conflicts.</p>"},{"location":"guide/fragments/#partials","title":"Partials","text":"<p>Fragments can ship their own partials so feature-specific rendering stays close to the feature:</p> <pre><code>partials = [\"strong.tex\", \"codeblock.tex\"]         # list form\nrequired_partials = [\"heading\"]                    # fail fast if missing\n</code></pre> <p>or as a mapping when paths and names differ:</p> <pre><code>[partials]\ncodeinline = \"overrides/inline/code.tex\"\n</code></pre> <p>Partial precedence is template overrides &gt; fragment overrides &gt; core defaults. Duplicate fragment providers for the same partial abort the render.</p>"},{"location":"guide/fragments/#runtime-loading","title":"Runtime loading","text":"<ul> <li>Built-ins are discovered under <code>src/texsmith/fragments/**/fragment.toml</code>.</li> <li>Custom fragments can be passed via <code>press.fragments</code> in front matter or CLI attributes.</li> <li>The registry uses manifest metadata first; entrypoint is a fallback.</li> <li>Entrypoint contract (Python): Must expose a module attribute <code>fragment</code> that is a <code>BaseFragment</code> instance. Legacy <code>create_fragment()</code> factories are no longer used.</li> </ul>"},{"location":"guide/fragments/#fragment-contract-python","title":"Fragment contract (Python)","text":"<ul> <li>Implement a <code>BaseFragment[Config]</code> subclass with:</li> <li>class attributes: <code>name</code>, <code>description</code>, <code>pieces</code>, <code>attributes</code> (TemplateAttributeSpec map), optional <code>context_defaults</code>, <code>partials</code>, <code>required_partials</code>, <code>source</code>.</li> <li>methods: <code>build_config(context, overrides=None) -&gt; Config</code>, <code>inject(config, context, overrides=None) -&gt; None</code>, <code>should_render(config) -&gt; bool</code>.</li> <li>Define a <code>Config</code> dataclass with <code>from_context(...)</code> and <code>inject_into(context)</code> methods (plus helpers like <code>enabled()</code>).</li> <li>Export <code>fragment = YourFragment()</code> from <code>__init__.py</code>; point <code>fragment.toml</code> <code>entrypoint</code> to <code>texsmith.fragments.yourname:fragment</code>.</li> <li>Injection flow: registry merges attribute defaults, builds config, calls <code>inject</code>, then checks <code>should_render</code> before rendering pieces.</li> </ul>"},{"location":"guide/fragments/#minimal-example","title":"Minimal example","text":"<p><code>src/texsmith/fragments/example/__init__.py</code> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, Mapping\n\nfrom texsmith.core.fragments.base import BaseFragment, FragmentPiece\nfrom texsmith.core.templates.manifest import TemplateAttributeSpec\n\n\n@dataclass(frozen=True)\nclass ExampleConfig:\n    message: str | None\n\n    @classmethod\n    def from_context(cls, ctx: Mapping[str, Any]) -&gt; \"ExampleConfig\":\n        return cls(message=ctx.get(\"example_message\"))\n\n    def inject_into(self, ctx: dict[str, Any]) -&gt; None:\n        ctx[\"ts_example_message\"] = self.message or \"Hello\"\n\n    def enabled(self) -&gt; bool:\n        return bool(self.message)\n\n\nclass ExampleFragment(BaseFragment[ExampleConfig]):\n    name = \"ts-example\"\n    description = \"Tiny example fragment.\"\n    pieces = [\n        FragmentPiece(\n            template_path=Path(__file__).with_name(\"ts-example.jinja.tex\"),\n            kind=\"inline\",\n            slot=\"extra_packages\",\n        )\n    ]\n    attributes = {\n        \"example_message\": TemplateAttributeSpec(\n            default=None,\n            type=\"string\",\n            sources=[\"press.example.message\", \"example.message\"],\n        )\n    }\n    context_defaults: dict[str, Any] = {\"extra_packages\": \"\"}\n    config_cls = ExampleConfig\n    source = Path(__file__).with_name(\"ts-example.jinja.tex\")\n\n    def build_config(self, context: Mapping[str, Any], overrides=None) -&gt; ExampleConfig:\n        return self.config_cls.from_context(context)\n\n    def inject(self, config: ExampleConfig, context: dict[str, Any], overrides=None) -&gt; None:\n        config.inject_into(context)\n\n    def should_render(self, config: ExampleConfig) -&gt; bool:\n        return config.enabled()\n\n\nfragment = ExampleFragment()\n</code></pre></p> <p><code>src/texsmith/fragments/example/fragment.toml</code> <pre><code>name = \"ts-example\"\ndescription = \"Tiny example fragment.\"\nentrypoint = \"texsmith.fragments.example:fragment\"\n\n[[files]]\npath = \"ts-example.jinja.tex\"\nslot = \"extra_packages\"\ntype = \"inline\"\n</code></pre></p>"},{"location":"guide/fragments/#migration-notes-for-fragment-authors","title":"Migration notes for fragment authors","text":"<ul> <li>Prefer <code>fragment.toml</code> with <code>files</code>, <code>attributes</code>, and optional <code>partials</code>/<code>required_partials</code>; use an entrypoint only when you need Python logic.</li> <li>If using Python, return a <code>BaseFragment</code> instance via <code>fragment</code>; <code>create_fragment()</code> and <code>FragmentDefinition</code> shims have been removed.</li> <li>Declare attribute ownership (implicit <code>owner = &lt;fragment name&gt;</code>) to avoid collisions with templates or other fragments.</li> <li>Keep slot targets aligned with template variables; inline targets must reference declared slots or template variables, otherwise a <code>TemplateError</code> is raised.</li> </ul>"},{"location":"guide/fragments/geometry/","title":"Geometry Fragment","text":"<p>The geometry fragment allows you to customize the page layout of your document, including paper size, orientation, margins, and adding watermarks. It relies on the LATEX <code>geometry</code> package to manage these settings and uses TikZ for watermarking if you want any.</p>"},{"location":"guide/fragments/geometry/#paper-format","title":"Paper format","text":"<p>We support standard paper formats recognized by the LATEX <code>geometry</code> package. You can specify the format using the <code>paper.format</code> key. For example, to set the paper size to A5, you would use:</p> <pre><code>press:\n  paper: a5\n</code></pre> <p>The supported formats include but are not limited to: a0, a1, a2, a3, a4, a5, a6, b0, b1, b2, b3, b4, b5, b6, c0, c1, c2, c3, c4, c5, c6, letter, legal, executive, ansia, ansib, ansic, ansid, ansie.</p> <p>Note</p> <p>The default format is <code>a4</code>, in contrast to LATEX\u2019s <code>letter</code> default. Globally, only the United States, Canada, Mexico, and a few Caribbean countries primarily use the <code>letter</code> size -- roughly 500 million people. The rest of the world, representing more than 6 billion people, relies on <code>a4</code> as the standard paper size. Given this overwhelming majority, TeXSmith defaults to <code>a4</code> to better serve its global user base. Sorry, folks in the US, Canada, and Mexico -- TeXSmith is opinionated and has chosen the broadest consensus!</p>"},{"location":"guide/fragments/geometry/#orientation","title":"Orientation","text":"<p>You can set the page orientation using the <code>paper.orientation</code> key. The possible values are <code>portrait</code> and <code>landscape</code>. For example, to set the orientation to landscape, you would use:</p> <pre><code>press:\n  paper:\n    orientation: landscape\n</code></pre>"},{"location":"guide/fragments/geometry/#margins","title":"Margins","text":"<p>You can customize the page margins using the <code>paper.margin</code> key. You can either specify a single value for all margins or provide an object with specific margins. For example:</p> <pre><code>press:\n  paper:\n    margin: 2cm\n</code></pre> <p>Or for specific margins:</p> <pre><code>press:\n  paper:\n    margin:\n      left: 3cm\n      right: 2cm\n      top: 4cm\n      bottom: 5cm\n</code></pre> <p>Or use predefined margin settings like <code>narrow</code>, <code>moderate</code>, or <code>wide</code>:</p> <pre><code>press:\n  paper:\n    margin: narrow\n</code></pre>"},{"location":"guide/fragments/geometry/#examples","title":"Examples","text":"<p>Here is an example configuration that sets the paper size to C5, uses landscape orientation, adds a frame, customizes the margins, and includes a watermark:</p> <pre><code>---\npress:\n  paper:\n    format: c5\n    orientation: landscape\n    frame: true\n    margin:\n      left: 3cm\n      bottom: 5\n    watermark: \"ENVELOPE\"\n---\n# Custom Geometry Example\n\nThis document demonstrates custom page geometry settings using the geometry fragment.\n</code></pre> <pre><code>---\nwidth: 70%\ntemplate: article\nfragments:\n  ts-frame\npress:\n  frame: true\n  paper:\n    format: c5\n    orientation: landscape\n    frame: true\n    margin:\n      left: 3cm\n      bottom: 5\n    watermark: \"ENVELOPE\"\n---\n# Custom Geometry Example\n\nThis document demonstrates custom page geometry settings using the geometry fragment.\n</code></pre> <p>Here's another example with custom paper width:</p> <pre><code>---\npress:\n  paper:\n    width: 12cm\n    height: 5cm\n    frame: true\n    margin: narrow\n---\n$$ E=mc^2 $$\n</code></pre> <pre><code>---\nwidth: 70%\ntemplate: article\npress:\n  frame: true\n  paper:\n    width: 12cm\n    height: 5cm\n    frame: true\n    margin: narrow\nfragments:\n  ts-frame\n---\n$$ E=mc^2 $$\n</code></pre>"},{"location":"guide/fragments/glossary/","title":"Glossary","text":"<p>In online documentation, a glossary doesn't make much sense because you can search for terms directly and you have hyperlinks. However, in printed documents, a glossary can be very useful to provide definitions of terms used in the text.</p> <p>TeXSmith adds support for glossaries through the <code>glossary</code> extension, which allows you to define glossary entries in your Markdown files and generate a glossary section in the output document.</p> <p>The fragment is automatically included when needed:</p> <ul> <li>If you use acronyms or abbreviations.</li> <li>If you define glossary entries using the <code>glossary</code> directive.</li> </ul>"},{"location":"guide/fragments/typesetting/","title":"Typesetting controls","text":"<p>TeXSmith bundles a <code>ts-typesetting</code> fragment that tweaks basic paragraph layout, line spacing, and optional line numbers. By default it stays silent\u2014nothing is injected unless you set one of its options.</p>"},{"location":"guide/fragments/typesetting/#configuration","title":"Configuration","text":"<p>All keys live under <code>press.typesetting</code> (short aliases also work: <code>press.paragraph</code>, <code>paragraph</code>, etc.).</p> <pre><code>press:\n  typesetting:\n    paragraph:\n      indent: auto    # true | false | auto\n      spacing: 1cm    # any TeX length; omit to keep the template default\n    leading: onehalf  # single | onehalf | double | &lt;length&gt; | &lt;number factor&gt;\n    lineno: true      # turn on margin line numbers\n</code></pre> <ul> <li><code>paragraph.indent</code> controls <code>\\parindent</code> plus the memoir/article <code>\\@afterindent\u2026</code> switches. <code>auto</code> leaves the first paragraph flush and indents the following ones; <code>true</code> always indents; <code>false</code> disables indentation.</li> <li><code>paragraph.spacing</code> sets <code>\\parskip</code> to your length (leave empty for the template\u2019s original value).</li> <li><code>leading</code> sets line spacing. <code>single</code>, <code>onehalf</code>, and <code>double</code> call the usual spacing commands. A numeric value applies a stretch factor (<code>1.2</code> \u2192 1.2\u00d7). A length sets <code>\\baselineskip</code> directly (<code>1em</code>, <code>14pt</code>, etc.).</li> <li><code>lineno: true</code> loads the <code>lineno</code> package and enables <code>\\linenumbers</code> for the whole document.</li> </ul>"},{"location":"guide/fragments/typesetting/#class-aware-spacing","title":"Class-aware spacing","text":"<ul> <li>On <code>memoir</code>, the fragment uses the class-provided <code>\\SingleSpacing</code>, <code>\\OnehalfSpacing</code>, and <code>\\DoubleSpacing</code> when available, falling back to <code>\\baselinestretch</code> updates.</li> <li>On other classes (article, report\u2026), it loads <code>setspace</code> and uses <code>\\singlespacing</code>, <code>\\onehalfspacing</code>, or <code>\\doublespacing</code>.</li> </ul>"},{"location":"guide/fragments/typesetting/#templates","title":"Templates","text":"<p>The built-in <code>article</code> and <code>book</code> templates inject <code>ts-typesetting</code> directly (no <code>\\usepackage</code> file to manage). If you don\u2019t set any of the options above, the fragment emits nothing and the templates\u2019 stock spacing stays unchanged.</p>"},{"location":"guide/plumbing/","title":"Plumbing","text":"<p>This section dives into the inner workings of TeXSmith, exploring its architecture, core components, and the mechanisms that enable its seamless integration of Markdown and LATEX. Whether you're curious about how TeXSmith processes documents or interested in extending its capabilities, this guide offers a concise overview of the plumbing that powers TeXSmith.</p>"},{"location":"guide/plumbing/engines/","title":"TEX Engines","text":"<p>TEX has grown far beyond Knuth\u2019s original engine, evolving into a whole ecosystem of specialized typesetting machines. Each engine inherits the soul of classic TEX but adds its own twist\u2014some focusing on programmability, others on Unicode, scripting, or a modern toolchain experience. Together they form a strange but delightful family tree where 1980s design meets cutting-edge typography.</p>"},{"location":"guide/plumbing/engines/#tex","title":"TEX","text":"<p>The original TEX engine, created by Donald Knuth, is the minimalist mathematical core of the entire ecosystem. It\u2019s deterministic, stable to the point of obsession, and designed so its output will match forever. It handles typesetting with surgical precision but offers no frills\u2014no Unicode, no PDF output, and no modern scripting hooks. Pure, legendary, and a little bit stubborn.</p>"},{"location":"guide/plumbing/engines/#e-tex","title":"E-TEX","text":"<p>e-TEX extends TEX with much-needed programming features without altering the underlying output. It adds new registers, improved conditionals, and tracing tools, making it a favorite for macro designers and format creators (like LATEX). Think of it as TEX with a Swiss-army-knife upgrade.</p>"},{"location":"guide/plumbing/engines/#pdftex","title":"pdfTeX","text":"<p>pdfTeX brought TEX into the era of digital documents by producing PDF natively instead of going through DVI. It introduced microtypography\u2014character protrusion, font expansion, and other subtle magic that makes text look professionally polished. Most modern LATEX distributions still rely heavily on pdfTeX.</p>"},{"location":"guide/plumbing/engines/#xetex","title":"XeTeX","text":"<p>XeTeX is the engine that finally made TEX feel Unicode-native. It uses system fonts directly (TrueType, OpenType), supports complex scripts naturally, and works beautifully for multilingual documents. If you need Arabic, Chinese, Hindi, or emoji without pain, XeTeX is your friend.</p>"},{"location":"guide/plumbing/engines/#luatex","title":"LuaTeX","text":"<p>LuaTeX embeds a full Lua interpreter into the engine, effectively giving TEX a programmable runtime. This allows deep customization, dynamic content generation, and powerful extensions like <code>luaotfload</code> and <code>luametalatex</code>. It\u2019s the most flexible and hackable TEX engine, almost a TEX/Lua hybrid organism.</p>"},{"location":"guide/plumbing/engines/#tectonic","title":"Tectonic","text":"<p>Tectonic is a modern, Rust-powered TEX engine aiming for reproducibility and user-friendliness. It automatically fetches missing packages, builds in a sandboxed environment, and removes the traditional \u201cTEX installation anxiety.\u201d It tries to make TEX behave like a modern build tool with zero configuration.</p>"},{"location":"guide/plumbing/engines/#omega-aleph","title":"Omega (\u03a9) / Aleph (\u2135)","text":"<p>Omega (and its successor Aleph) were early attempts at adding Unicode and advanced multilingual typesetting. They never became mainstream, but their ideas paved the way for XeTeX and LuaTeX.</p>"},{"location":"guide/plumbing/engines/#ptex-uptex","title":"pTeX / upTeX","text":"<p>Specialized engines designed for Japanese typesetting. pTeX handles vertical writing and Japanese line-breaking rules, while upTeX brings Unicode support to that world. They\u2019re essential in the Japanese TEX community.</p>"},{"location":"guide/plumbing/engines/#which-to-prefer","title":"Which to prefer?","text":"<p>That a debate as old as TEX itself still rages on is a testament to its complexity and versatility. For most users, pdfTeX or LuaTeX (with LATEX macros) will cover nearly all needs. Some facts:</p> <ol> <li>Tectonic is so smooth, it downloads packages automatically, making it great for newcomers. No need to install a heavy TEX distribution.</li> <li>LuaLaTeX is the only engine that supports both protrusion and font expansion (microtypography) along with Lua scripting, which yields smoother PDF output.</li> <li>XeLaTeX has similar results to Tectonic but allows <code>--shell-escape</code> for minted code highlighting.</li> </ol>"},{"location":"guide/plumbing/latex/","title":"LATEX","text":"<p>LATEX is the layer that turned TEX from a brilliant but arcane typesetting engine into a real document preparation system. Where TEX gives you microscopic control of every typographic atom, LATEX gives you structure, meaning, and reusable design. It\u2019s the difference between soldering your own circuit board and using a well-designed development kit: the power is still there, but now it\u2019s ergonomic, consistent, and scalable. Over the decades, LATEX has become the lingua franca of academic publishing, math-heavy documents, and anyone who appreciates the elegance of markup-driven writing.</p>"},{"location":"guide/plumbing/latex/#leslie-lamport","title":"Leslie Lamport","text":"<p>Leslie Lamport, an American computer scientist best known for his pioneering work in distributed systems and formal methods, created LATEX in the early 1980s while at SRI International. Frustrated by the repetitiveness and fragility of raw TEX macros, Lamport designed LATEX as a higher-level interface where authors declare what a document element is\u2014\"this is a theorem,\" \"this is a section,\" \"this is a quotation\"\u2014and let the underlying macros decide how it should look. Lamport\u2019s disciplined, engineering-driven approach gave LATEX the structure and style consistency that made it indispensable across scientific disciplines. Though others have maintained and extended LATEX since, Lamport remains the architect of the system that made TEX widely accessible.</p>"},{"location":"guide/plumbing/latex/#how-latex-differs-from-tex","title":"How LATEX differs from TEX","text":"<p>TEX is a typesetting engine, essentially a low-level programming language for shaping glyphs and boxes in beautifully precise ways. LATEX sits on top of it as a macro format and workflow philosophy. Where TEX wants you to manage fonts, spacing, and layout directly, LATEX encourages \"semantic markup\": writing with meaning and structure rather than appearance. TEX says \"place this box 2 pt to the right and apply this italic correction\"; LATEX says \"this is a subsection header; I\u2019ll handle the aesthetics.\" LATEX also provides standardized environments, robust cross-referencing, bibliographies, floating figures, and a massive ecosystem of packages. In short, TEX is the engine; LATEX is the operating system built on top of it.</p>"},{"location":"guide/plumbing/latex/#legacy","title":"Legacy","text":"<p>LATEX\u2019s legacy is enormous. It transformed TEX from a typographic laboratory into a practical tool used by millions. It standardized academic publishing workflows, made mathematical writing accessible, and proved that declarative document design could outlive trends in software and UI. From the original LATEX 2.09 to today\u2019s actively developed LATEX2\u03b5 and the upcoming LaTeX3 paradigm, the system continues to evolve while staying compatible with decades of documents. Its influence goes beyond typesetting: LATEX shaped how scientists write, how publishers structure content, and how digital typography is conceptualized. It remains one of the rare pieces of software whose output is expected to remain stable across generations.</p>"},{"location":"guide/plumbing/pipeline/","title":"How does TeXSmith work?","text":"<p>TeXSmith ingests Markdown (<code>.md</code>), HTML (<code>.html</code>), YAML (<code>.yaml</code>), and BibTeX (<code>.bib</code>), then runs them through a conversion pipeline to produce LATEX or a finished PDF.</p> <p>Templates define the layout and expose slots that get filled with content from your sources. The template also relies on fragments which are extra layers for extending the features such as a bibliography, glossary, fonts, page geometry, or other typesetting options.</p> <p></p>"},{"location":"guide/plumbing/pipeline/#internal-pipeline","title":"Internal pipeline","text":"<ol> <li> <p>Collect and classify inputs    The CLI and <code>ConversionService</code> accept Markdown/HTML documents, optional front matter YAML, and bibliography files. <code>split_inputs</code> peels off <code>.bib</code>/<code>.bibtex</code>, treats a lone YAML file as the only document when needed, and normalises any provided front matter. When documents share front matter, it is deep-merged into each <code>Document</code>, with <code>press.*</code> metadata validated up front to avoid surprises later.</p> </li> <li> <p>Normalise documents to HTML <code>Document.from_markdown</code> runs Python-Markdown with the bundled extensions (smallcaps, texlogos, index, Mermaid, raw LATEX fences, etc.), extracts front matter, and caches the resulting HTML. <code>Document.from_html</code> can either keep the whole file or extract a selector (<code>article.md-content__inner</code> by default). Heading strategies are decided here (keep, drop, or promote the first heading into <code>press.title</code>), numbering defaults are resolved, and slot directives declared in front matter (<code>press.slot.*</code>) are seeded into the document slot mapping.</p> </li> <li> <p>Bind the template and attributes <code>build_binder_context</code> resolves which template runtime to use (<code>TemplateBinding</code>) and which slots exist. Template attributes declared in <code>manifest.toml</code> (<code>TemplateAttributeSpec</code>) are merged in a strict order: template defaults \u2192 fragment defaults \u2192 front matter (<code>press.*</code> or direct fields) \u2192 CLI/session overrides. Attribute ownership is enforced so two fragments or the template cannot claim the same attribute. Before anything renders, mustache placeholders in HTML, front matter, and template overrides are expanded against the merged context so later stages see concrete values.</p> </li> <li> <p>Split content into slots    Slot requests come from CLI <code>--slot</code>, front matter, or defaults. <code>extract_slot_fragments</code> walks the HTML to find the requested headings/IDs, pulls those sections out, and assigns them to template slots (abstract, mainmatter, appendix, etc.). Base heading levels and offsets are computed per slot so sectioning commands line up with the template\u2019s depth configuration. Any missing selectors produce warnings and the remainder of the document flows into the default slot.</p> </li> <li> <p>Prime context, fragments, and attributes    The binder context prepares runtime defaults: language, code engine/style, callout definitions, diagram backend, emoji mode, and bibliography map. Active fragments are resolved (from template extras or explicit overrides) and each fragment injects its context defaults plus owned attributes. Fragments are small, declarative building blocks (<code>fragment.toml</code> or a Python <code>BaseFragment</code>) that emit pieces into specific slots (<code>package</code>/<code>input</code>/<code>inline</code>). Examples: <code>ts-geometry</code>, <code>ts-fonts</code>, <code>ts-bibliography</code>, <code>ts-index</code>, glossary, code. A fragment may skip rendering via <code>should_render</code> (for example, bibliography and index fragments only activate when citations or index entries exist).</p> </li> <li> <p>Resolve partials LATEX output is assembled from Jinja partials (one per Markdown/HTML construct). The precedence is explicit: template overrides (<code>manifest.toml</code> <code>latex.template.override</code>) \u2192 fragment partials \u2192 core defaults in <code>src/texsmith/adapters/latex/partials</code>. Both templates and fragments can declare <code>required_partials</code>; missing providers abort with a <code>TemplateError</code>. TeXSmith tracks which provider owns each partial so diagnostics clearly name the culprit.</p> </li> <li> <p>Render HTML fragments to LATEX    Each slot fragment is rendered through <code>LaTeXRenderer</code>, with fallback converters registered when external tools are unavailable. Runtime data (base_level, numbered flag, drop_title, bibliography map, partial providers, language, diagram backend) flows to every handler. The <code>DocumentState</code> accumulates headings, citations, index terms, script usage/fallback font summaries, glossaries, snippets, callouts, and asset references so later stages can emit the right packages and backmatter.</p> </li> <li> <p>Fonts and script matching    As text is rendered, the script detector (<code>texsmith.fonts.scripts</code>) scans moving arguments (headings, captions, index entries) and wraps non-Latin runs in dedicated LATEX macros. A cached fallback index built from Noto coverage data chooses per-script font families and emits both font-switching commands and summary stats. The <code>--fonts-info</code> flag surfaces the detected scripts, chosen families, and counts after the run.</p> </li> <li> <p>Bibliography and index resolution    Bibliography data comes from <code>.bib</code> files plus optional inline front matter entries (including DOI lookups with caching). Only cited keys are written to a generated <code>texsmith-bibliography.bib</code>, keeping outputs lean. Citations recorded in <code>DocumentState</code> trigger the <code>ts-bibliography</code> fragment, which injects package setup and backmatter hooks. Index terms collected by the Markdown extension set <code>has_index</code>/<code>index_terms</code>, enabling the <code>ts-index</code> fragment to load <code>imakeidx</code> helpers and drop the <code>\\printindex</code> block into the <code>fragment_backmatter</code> slot.</p> </li> <li> <p>Template wrap and emission     Slot outputs are merged back into the template entrypoint via <code>wrap_template_document</code>, alongside template/fragment attributes, required assets, and optional manifest/debug artefacts. When running under <code>TemplateSession</code>, the fragments are also materialised as <code>.tex</code> files so templates can <code>\\input{}</code> or <code>\\usepackage{}</code> them. The resulting <code>TemplateRenderResult</code> carries the main <code>.tex</code> path, per-fragment outputs, bibliography path (if any), selected template engine, and shell-escape requirement, ready for <code>texsmith pdf</code>/Tectonic to produce the final PDF.</p> </li> </ol>"},{"location":"guide/plumbing/tex/","title":"TEX","text":""},{"location":"guide/plumbing/tex/#donald-knuth","title":"Donald Knuth","text":"<p>Donald Knuth is an American mathematician and computer scientist, born in 1938. He is widely regarded as one of the great pioneers of algorithmics and theoretical computer science. Beyond pure algorithms, he cared deeply about how mathematics and computer science are communicated\u2014elegant notation, crisp printing, clear layout. Thus, to support his own writing (notably of his magnum opus The Art of Computer Programming), he decided to build a better typesetting system from scratch, one tailored for math and scientific texts.</p>"},{"location":"guide/plumbing/tex/#origins-motivation","title":"Origins &amp; Motivation","text":"<p>In the late 1970s, typesetting was shifting: older \"hot-metal\" composition methods gave way to phototypesetting. When the second edition of The Art of Computer Programming was being reset under the new technology, Knuth saw proofs of the text\u2014and was horrified by the ugliness and loss of typographic quality. Frustrated, he resolved to create his own system\u2014a digital typesetting engine that gave precise control over layout, spacing, and especially the complex demands of mathematical formulae. Thus began TEX. The project started around 1977; by 1978 a first version was running. Knuth\u2019s vision was not just about pretty printing: he wanted a stable, precise system that would produce consistent output forever\u2014so that technical documents would remain readable and reproducible decades later.</p>"},{"location":"guide/plumbing/tex/#versioning-of-texwhy","title":"Versioning of TEX\u2014Why \u03c0?","text":"<p>After a few years of development (first version around 1978, then a major rewrite as TeX82 released in 1982), the design of TEX was deemed complete and \"frozen\" around version 3.0 (in 1989). Rather than increment major version numbers as new features, Knuth opted for a quirky, symbolic versioning: after 3.0, every subsequent bug-fix release adds another digit to the decimal expansion, so the version number asymptotically approaches the mathematical constant \u03c0. As of now, the version of TEX is 3.141592653 (the cursed geekiest of version numbers). This reflects Knuth\u2019s philosophy: TEX is stable, mature, its core doesn\u2019t need new features\u2014only maintenance to keep it consistent and bug-free.</p> <p>Knuth reportedly joked that after his death, when no more bug-fixes remain, the final version \"will be\" exactly \u03c0\u2014meaning that any residual quirks or \"bugs\" will simply be features.</p>"},{"location":"guide/plumbing/tex/#pronunciation","title":"Pronunciation","text":"<p>The name \"TEX\" comes from the Greek root \u03c4\u03b5\u03c7- (t\u00e9k\u02b0n\u0113) meaning \"art, craft, technique\"\u2014fitting for a typesetting system deeply rooted in the art of typesetting. Because the \"X\" in TEX is really the Greek letter chi (\u03a7), the \"proper\" pronunciation is something like \"tekh\" (with a voiceless velar fricative\u2014like the \"ch\" in German or Scottish \"loch\").</p> <p>Over time, many users found plain TEX a bit \"low-level\" and hard to use directly. This led to the rise of higher-level macro systems like LATEX (and later others), which made it easier to write large documents, papers, theses\u2014without wrestling directly with spacing, boxes, etc.</p> <p>Despite these newer systems, the core TEX engine and its philosophy remain influential. Many scientific, mathematical, and academic publications still rely on TEX (or macro layers over it) because nothing else matches its combination of precision, stability, and typographic quality.</p>"},{"location":"guide/templates/","title":"Templates","text":"<p>TeXSmith templates define the LATEX skeleton that wraps converted Markdown. Each template bundles assets, slot definitions, attribute schemas, and build metadata so you can aim the renderer at anything from articles to slide decks.</p> <p>Templates are a core feature that allows TeXSmith to be extended for different use cases. You may use:</p> <ul> <li>Custom project templates stored in a <code>templates/</code> folder.</li> <li>Local user templates installed in your <code>~/.texsmith/templates/</code> folder.</li> <li>Published templates installed from PyPI.</li> <li>Built-in templates included with TeXSmith.</li> </ul>"},{"location":"guide/templates/#built-in-templates","title":"Built-in templates","text":"<p>TeXSmith includes standard templates for common document types:</p> <ul> <li><code>article</code>: academic-style article layout with title page, abstract, and sections.</li> <li><code>book</code>: book-style layout with parts, chapters, preface, table of contents, appendices, and optional <code>part</code> base-level override.</li> <li><code>letter</code>: formal letters with sender/recipient metadata, fold marks, and signature.</li> <li><code>snippet</code>: standalone <code>tikzpicture</code> frame for screenshots, stickers, and snippets.</li> </ul> <p>Invoke them in the CLI with <code>-tarticle</code> or <code>-tletter</code>. Additional community templates remain available under <code>templates/</code> or as separate PyPI packages.</p> <p>Take a look at built-in fragments for full configuration options.</p>"},{"location":"guide/templates/#quick-start","title":"Quick start","text":"<pre><code># 1. Inspect a built-in template\ntexsmith --template article --template-info\n\n# 2. Render a document with template slots + build\ntexsmith docs/intro.md \\\n  --template article \\\n  --slot mainmatter:@document \\\n  --output-dir build/article \\\n  --build\n</code></pre> <p>Need a blank template skeleton? Use the scaffold flag to copy any template into your working tree:</p> <pre><code>texsmith --template article --template-scaffold my-template\ncd my-template\nuv run hatch build  # optional packaging smoke test\n</code></pre> <p>Publish by pointing <code>pyproject.toml</code> to the <code>template/</code> package, then <code>uv publish</code> or <code>twine upload dist/*</code>. For in-depth patterns (overrides, slots, metadata), see the Template Cookbook.</p>"},{"location":"guide/templates/#write-your-own-texsmith-templates","title":"Write your own TeXSmith templates","text":"<p>TeXSmith uses Jinja2 templates to assemble LATEX documents from converted Markdown fragments. You can create your own templates to control the layout, styling, and structure of the final output.</p> <p>You may start by copying an existing template package and modifying it to suit your needs. Templates can either be published on PyPI for easy distribution or kept locally for personal use. By default, TeXSmith will look for templates installed in the current Python environment or in the current working directory under a <code>templates/</code> folder.</p>"},{"location":"guide/templates/#structure","title":"Structure","text":"<pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 overrides\n\u2502   \u2514\u2500\u2500 fragment.tex\n\u2514\u2500\u2500 template\n    \u251c\u2500\u2500 assets\n    \u2502   \u2514\u2500\u2500 latexmkrc\n    \u251c\u2500\u2500 manifest.toml\n    \u251c\u2500\u2500 template.tex\n    \u2514\u2500\u2500 .sty, .cls...\n</code></pre>"},{"location":"guide/templates/#toml-manifest","title":"TOML manifest","text":"<p>The <code>manifest.toml</code> file describes the template and its metadata.</p> <pre><code>[compat]\n# Specify the compatible TeXSmith versions. Do not forget\n# to set a maximum version to avoid future incompatibilities.\ntexsmith = \"&gt;=0.1,&lt;1.0\"\n\n[latex.template]\nname = \"acme\"\nversion = \"0.1.0\"\nentrypoint = \"template/template.tex\"\n# Useful for generic docker images or CI pipelines, where\n# we only install the required packages.\ntexlive_year = 2023\ntlmgr_packages = [\n    \"babel\",\n    \"geometry\",\n    \"hyperref\",\n    \"microtype\",\n    \"fontspec\",\n    \"biblatex\",\n]\n\n# Attributes:\n# -----------\n# Attributes are declared as nested tables describing the type, default\n# value, and optional normalisation rules for each entry. Types are inferred\n# from the default when omitted.\n[latex.template.attributes.base_level]\ndefault = 1\ntype = \"integer\"\n\n[latex.template.attributes.title]\ndefault = \"Title\"\ntype = \"string\"\nescape = \"latex\"\nallow_empty = false\n\n[latex.template.attributes.subtitle]\ndefault = \"\"\ntype = \"string\"\nescape = \"latex\"\n\n[latex.template.attributes.author]\ndefault = \"John Doe\"\ntype = \"string\"\nescape = \"latex\"\n\n[latex.template.attributes.date]\ndefault = \"\\\\today\"\ntype = \"string\"\nescape = \"latex\"\n\n[latex.template.attributes.language]\ndefault = \"english\"\ntype = \"string\"\nnormaliser = \"babel_language\"\n\n[latex.template.attributes.paper]\ndefault = \"a4paper\"\ntype = \"string\"\nnormaliser = \"paper_option\"\n\n[latex.template.attributes.orientation]\ndefault = \"portrait\"\ntype = \"string\"\nnormaliser = \"orientation\"\nchoices = [\"portrait\", \"landscape\"]\n\n[latex.template.attributes.bibliography_style]\ndefault = \"numeric\"\ntype = \"string\"\n\n# Slots definition:\n# -----------------\n# Each slot represents a section of the document that can be filled\n# with content. The 'depth' parameter indicates the LaTeX sectioning\n# command to use.\n[latex.template.slots.mainmatter]\ndefault = true\ndepth = \"section\"\n\n[latex.template.slots.abstract]\ndepth = \"section\"\nstrip_heading = true\n\n# Additional Assets:\n# ------------------\n# All additional assets to be included in the template package.\n# They will be copied to the working directory when the template is used.\n[latex.template.assets]\n\".latexmkrc\" = { source = \"template/assets/latexmkrc\" }\n</code></pre>"},{"location":"guide/templates/#attribute-schema","title":"Attribute schema","text":"<p>Each attribute table accepts the following keys:</p> <ul> <li><code>default</code>: (required) the value injected when no override is provided.</li> <li><code>type</code>: optional primitive among <code>string</code>, <code>integer</code>, <code>float</code>, <code>boolean</code>, <code>list</code>, <code>mapping</code>, <code>any</code>. When omitted TeXSmith infers a type from <code>default</code>.</li> <li><code>sources</code>: the lookup paths (dot notation) used to pull overrides from document front matter. If omitted, TeXSmith probes <code>press.press.&lt;name&gt;</code>, <code>press.&lt;name&gt;</code>, then <code>&lt;name&gt;</code>.</li> <li><code>allow_empty</code>: when <code>false</code>, empty strings are coerced to <code>None</code> so templates fall back to defaults.</li> <li><code>required</code>: when <code>true</code>, a missing override raises a <code>TemplateError</code>.</li> <li><code>choices</code>: restricts string/integer values to the provided list.</li> <li><code>escape</code>: currently supports <code>latex</code> to automatically escape special characters coming from user input.</li> <li><code>normaliser</code>: name of a registered normaliser that post-processes the value (see below).</li> </ul> <p>Attributes are resolved before <code>WrappableTemplate.prepare_context</code> runs, meaning template classes only need to handle presentation-specific tweaks (for example, combining authors, building option strings, or removing temporary keys).</p>"},{"location":"guide/templates/#attribute-ownership-precedence","title":"Attribute ownership &amp; precedence","text":"<ul> <li>Each attribute belongs to a single owner (template by default, fragment when declared in <code>fragment.toml</code>). Conflicting owners raise a <code>TemplateError</code>.</li> <li>Overrides flow: CLI/front matter \u2192 attribute resolver (type coercion, normalisers) \u2192 template emitters/fragment defaults. Empty strings are dropped when <code>allow_empty = false</code>.</li> <li>Attributes no longer live under ad-hoc dotted names (<code>press.*</code>); normalisation collapses supported aliases onto the declared attribute name.</li> </ul>"},{"location":"guide/templates/#template-slots-and-built-ins","title":"Template slots and built-ins","text":"<ul> <li>Templates must declare at least one slot; <code>mainmatter</code> is the default when absent. Slots surface <code>depth</code>, <code>offset</code>, <code>strip_heading</code>, and optional <code>base_level</code>.</li> <li>Built-in <code>article</code> exposes <code>mainmatter</code>, <code>abstract</code>, <code>appendix</code>, and <code>backmatter</code>. <code>book</code> inserts <code>appendix</code> before <code>backmatter</code> and supports <code>part</code> toggling. <code>letter</code> uses <code>mainmatter</code> only.</li> <li>Deprecated attributes removed from built-ins: <code>article</code>/<code>book</code> no longer accept <code>cover</code>, <code>covercolor</code>, <code>twocolumn</code>, or template-owned <code>emoji</code>. Backmatter/preamble overrides moved into fragments where applicable. </li> </ul>"},{"location":"guide/templates/#built-in-normalisers","title":"Built-in normalisers","text":"Name Purpose <code>paper_option</code> Validates paper sizes and emits <code>&lt;size&gt;paper</code> strings (for example <code>letterpaper</code>). <code>orientation</code> Normalises orientation flags and guarantees <code>portrait</code> or <code>landscape</code>. <code>babel_language</code> Maps ISO-like language codes to Babel identifiers (for example <code>fr</code> \u2192 <code>french</code>). <p>Normalisers run after type coercion and before escaping. They can also reuse existing defaults to provide fallbacks (<code>paper_option</code> and <code>orientation</code> do this).</p>"},{"location":"guide/templates/#metadata-overrides","title":"Metadata overrides","text":"<p>At runtime TeXSmith merges template defaults with document front matter. By default, overrides come from the <code>press</code> section:</p> <pre><code>---\npress:\n  title: Sample Article\n  subtitle: Insights on Cheese\n  language: fr\n  authors:\n    - name: Ada Lovelace\n      affiliation: Analytical Engine\n    - name: Grace Hopper\n---\n</code></pre> <p>With the manifest above TeXSmith will:</p> <ul> <li>Escape <code>title</code> and <code>subtitle</code> for LATEX compatibility.</li> <li>Map <code>language: fr</code> to <code>french</code>.</li> <li>Normalise author collections so individual templates can format them consistently.</li> <li>Populate both defaults (<code>author</code>) and structured data (<code>authors</code>) that template classes can consume.</li> </ul> <p>To pull metadata from alternative locations add explicit <code>sources</code>:</p> <pre><code>[latex.template.attributes.project_code]\ndefault = \"\"\ntype = \"string\"\nsources = [\"press.project.code\", \"project.code\"]\nallow_empty = false\n</code></pre>"},{"location":"guide/templates/#slots","title":"Slots","text":"<p>Slots control where converted content is injected. Each entry allows:</p> <ul> <li><code>depth</code>: maps to a LATEX sectioning command (<code>section</code>, <code>chapter</code>, etc.).</li> <li><code>base_level</code> and <code>offset</code>: fine tune heading levels when rendering.</li> <li><code>default</code>: mark exactly one slot as the primary sink for content.</li> <li><code>strip_heading</code>: remove the first heading when populating the slot (useful for abstracts).</li> </ul> <p>Slots become Jinja variables inside the template (<code>\\VAR{abstract}</code>, <code>\\VAR{mainmatter}</code>).</p>"},{"location":"guide/templates/#overrides","title":"Overrides","text":"<p>TeXSmith uses partials to render different parts of the document such as bold text with <code>adapters/latex/partials/bold.tex</code>:</p> <pre><code>\\textbf{\\VAR{text}}\n</code></pre> <p>You may want to override some of these partials to customize the output of specific Markdown elements. To do so, create an <code>overrides/</code> folder in your template package and add the partials you want to override.</p> <p>When the manifest lists <code>latex.template.override = [\"partials/bold.tex\"]</code>, TeXSmith searches the following locations in order:</p> <ol> <li><code>&lt;template&gt;/overrides/</code></li> <li><code>&lt;template&gt;/template/overrides/</code></li> <li>The template root itself.</li> <li>A sibling <code>overrides/</code> directory next to the template package.</li> </ol> <p>Placeholders inside override files can use the same Jinja syntax (<code>\\VAR{...}</code>, <code>\\BLOCK{...}</code>).</p>"},{"location":"guide/templates/#slot-strategies","title":"Slot strategies","text":"<p>Slots determine how multiple Markdown documents (or sections) flow into the LATEX structure. Typical patterns:</p> <ul> <li>Single document, single slot \u2013 map the only input with <code>--slot mainmatter:@document</code>.</li> <li>Front matter + main matter \u2013 convert two files (eg <code>intro.md</code>,   <code>book.md</code>) and pass <code>--slot frontmatter:intro.md</code> and <code>--slot mainmatter:book.md</code>.</li> <li>Selective sections \u2013 reference headings or IDs:   <code>--slot abstract:paper.md:@abstract --slot mainmatter:paper.md:\"Results\"</code> injects   only the abstract heading and the \u201cResults\u201d section into separate slots.</li> <li>Per-language appendices \u2013 define slots (<code>appendix_en</code>, <code>appendix_fr</code>) and use front-matter metadata (<code>press.slot.appendix_en: docs/en.md</code>) so automation scripts do not need to pass CLI flags.</li> </ul> <p>Slots are resolved by the document slot mapping across CLI flags, front matter (<code>press.slot.*</code>), and API overrides, so mix and match whichever suits your workflow.</p>"},{"location":"guide/templates/#testing-your-template","title":"Testing your template","text":"<p>Before publishing, run the built-in test suite against your template:</p> <pre><code>uv run pytest tests/test_template_attributes.py\n</code></pre> <p>This repository includes examples for the bundled templates; copy one into your package and adjust expectations to match your manifest. Automated tests help ensure attributes, slots, and metadata mappings keep working as the TeXSmith runtime evolves.</p>"},{"location":"guide/templates/#next-steps","title":"Next steps","text":"<ul> <li>Study the Template Cookbook for practical recipes (title pages, metadata bindings, bibliography tweaks).</li> <li>Browse the API high-level guide to orchestrate templates programmatically with <code>ConversionService</code>.</li> </ul>"},{"location":"guide/templates/discovery/","title":"Template Discovery","text":"<p>TeXSmith finds templates from multiple locations in a deterministic order:</p> <ol> <li>Built-ins: shipped with TeXSmith (<code>article</code>, <code>book</code>, <code>letter</code>, <code>snippet</code>).</li> <li>Installed packages: PyPI distributions named <code>texsmith-template-*</code> (or exposing the <code>texsmith.templates</code> entry point).</li> <li>Local tree: current working directory and any ancestor <code>templates/</code> folder. Any <code>manifest.toml</code>/<code>template/manifest.toml</code> or <code>__init__.py</code> counts as a template root.</li> <li>User directory: <code>~/.texsmith/templates/&lt;name&gt;</code> (same structure as local).</li> </ol> <p>Use the CLI to inspect what was found:</p> <pre><code>texsmith --template-info --template article\ntexsmith templates  # list all visible templates\n</code></pre> <p>A valid template root contains either <code>manifest.toml</code> or <code>template/manifest.toml</code>; an <code>__init__.py</code> alongside these allows specialized Python logic.</p> <p>Notes: - Passing an explicit path (<code>--template ./templates/custom</code>) bypasses discovery order. - Package roots win over same-named local folders; local folders win over the home directory. - Template manifests can include a <code>mermaid-config.json</code> at the root; <code>--template-info</code> will surface it.</p> <p>To scaffold a built-in for customization:</p> <pre><code>texsmith templates scaffold article ./templates/article\n</code></pre> <p>Then point <code>--template</code> to that path. Any <code>mermaid-config.json</code> placed at the template root will be picked up automatically.</p>"},{"location":"guide/templates/fragments/","title":"Template fragments","text":"<p>Fragments are small, pluggable LATEX packages (<code>.sty</code> rendered from Jinja) that TeXSmith can inject into any template at <code>\\VAR{extra_packages}</code>. They keep shared logic (callouts, code listings, \u2026) out of individual templates while staying configurable from front matter or your own extensions.</p>"},{"location":"guide/templates/fragments/#built-in-fragments","title":"Built-in fragments","text":"<code>ts-geometry</code> page size/orientation glue that mirrors <code>press.paper</code>/<code>press.geometry</code> options. <code>ts-extra</code> opt-in aux packages detected from the rendered content (hyperref, soul, ulem, etc.). <code>ts-keystrokes</code> renders <code>\\keystroke{\u2026}</code> shortcuts with styled TikZ boxes when they appear in content. <code>ts-callouts</code> admonition/callout boxes generated from callout definitions. <code>ts-code</code> unified minted/tcolorbox code listing style. <code>ts-index</code> central imakeidx/macros glue, selects texindy/makeindex and runs <code>\\makeindex</code> when entries are present. <code>ts-glossary</code> glossary and acronym wiring: loads <code>glossaries</code>, runs <code>\\makeglossaries</code> when needed, and materializes acronym definitions from front matter with configurable styles. <code>ts-bibliography</code> bibliography helper that wires <code>biblatex</code> into the rendered document. <code>ts-todolist</code> checklist helpers providing <code>\\done</code>, <code>\\wontfix</code>, and the <code>todolist</code> environment when they are referenced. <p>All built-in templates default to rendering these fragments. They are written into the build directory as <code>ts-*.sty</code> and loaded via <code>\\usepackage{...}</code> in the generated TEX.</p>"},{"location":"guide/templates/fragments/#using-fragments-in-documents","title":"Using fragments in documents","text":"<p>Fragments are declared under the <code>press.fragments</code> list in front matter. Each entry is either the name of a built-in fragment or a path to a custom Jinja template (absolute or relative to the Markdown file).</p> <pre><code>---\npress:\n  template: article\n  fragments:\n    - ts-callouts\n    - ts-code\n    - ts-glossary\n    - fragments/foo.jinja.sty  # custom fragment located next to your doc\n  foo:\n    value: 42         # variables consumed by foo.jinja.sty\n---\n</code></pre> <p>TeXSmith renders each fragment into the output directory and injects the corresponding <code>\\usepackage{\u2026}</code> lines into <code>\\VAR{extra_packages}</code>.</p>"},{"location":"guide/templates/fragments/#what-a-fragment-looks-like","title":"What a fragment looks like","text":"<p>Fragments are plain Jinja templates that output LATEX. The package name is the stem of the file unless it is a built-in registered name.</p> <pre><code>% fragments/foo.jinja.sty\n\\ProvidesPackage{foo}[2025/01/01 Example fragment]\n\\newcommand{\\FooValue}{\\VAR{foo.value|default(0)}}\n</code></pre> <p>With the front matter above, the generated build will contain <code>foo.sty</code> and the document preamble will include <code>\\usepackage{foo}</code>.</p>"},{"location":"guide/templates/fragments/#template-authors-allowing-fragments","title":"Template authors: allowing fragments","text":"<p>To consume fragments, a template needs a placeholder where TeXSmith can inject the <code>\\usepackage</code> lines. Add <code>\\VAR{extra_packages}</code> near the top of your preamble\u2014typically next to other package imports. No TOML manifest changes are required; the core runtime resolves fragments before rendering.</p> <p>Built-in templates already include this placeholder and opt into <code>ts-geometry</code>, <code>ts-extra</code>, <code>ts-keystrokes</code>, <code>ts-callouts</code>, <code>ts-code</code>, <code>ts-glossary</code>, <code>ts-index</code>, <code>ts-bibliography</code>, and <code>ts-todolist</code> via the template runtime extras; conditional fragments only render when their macros are present in the rendered LATEX. Third-party templates can also declare default fragments in their <code>TemplateRuntime.extras[\"fragments\"]</code> or let users supply their own through front matter.</p>"},{"location":"guide/templates/fragments/#passing-variables-to-fragments","title":"Passing variables to fragments","text":"<p>Any values under <code>press</code> (or other front matter keys) are merged into the template rendering context. If your fragment expects a variable such as <code>foo.value</code>, document it and read it directly in the Jinja template. Unknown keys are ignored.</p>"},{"location":"guide/templates/fragments/#cli-and-api-integration","title":"CLI and API integration","text":"<p>CLI usage is automatic once <code>press.fragments</code> is present. For API consumers:</p> <pre><code>from texsmith import Document, TemplateSession\nfrom texsmith.core.templates import load_template_runtime\n\nsession = TemplateSession(load_template_runtime(\"article\"))\nsession.add_document(Document.from_markdown(path_to_md))\nresult = session.render(output_dir)\n# result.main_tex_path already includes the rendered fragments\n</code></pre> <p>Custom fragments may live anywhere; relative paths are resolved against the document\u2019s directory. Built-in names are always available without shipping assets in your template package.</p>"},{"location":"guide/templates/mermaid/","title":"Mermaid Configuration","text":"<p>TeXSmith will automatically pick up a <code>mermaid-config.json</code> located at the root of a template (next to <code>manifest.toml</code>). The diagrams module passes this config to Mermaid for all diagrams rendered with that template.</p>"},{"location":"guide/templates/mermaid/#using-a-built-in-template","title":"Using a Built-in Template","text":"<p>The built-in <code>article</code> template ships with a <code>mermaid-config.json</code>. To inspect or override it:</p> <pre><code>texsmith --template-info --template article\ntexsmith templates  # list all discoverable templates\n</code></pre> <p>To customize, copy the file, adjust options, and point to your modified template directory:</p> <pre><code>cp -r $(python - &lt;&lt;'PY'\\nfrom texsmith.core.templates import load_template\\nfrom pathlib import Path\\nt = load_template('article')\\nprint(t.root)\\nPY) ./templates/article\\n# edit ./templates/article/mermaid-config.json\\ntexsmith doc.md --template ./templates/article\n</code></pre>"},{"location":"guide/templates/mermaid/#adding-mermaid-config-to-a-custom-template","title":"Adding Mermaid Config to a Custom Template","text":"<ol> <li>Place <code>mermaid-config.json</code> at the template root (same level as <code>manifest.toml</code>).</li> <li>TeXSmith will expose the path via <code>template.extras[\"mermaid_config\"]</code> so the renderer can pass it to Mermaid.</li> <li>No manifest changes are required; the presence of the file is enough.</li> </ol> <p>Typical options include theme, font, backgroundColor, and securityLevel. See https://mermaid.js.org/config/theming.html for full reference.</p>"},{"location":"guide/templates/partials/","title":"Partials &amp; Override Precedence","text":"<p>TeXSmith renders LATEX through reusable partials (Jinja templates) for list items, code blocks, images, etc. The override order is explicit and enforced:</p> <ol> <li>Template overrides \u2014 declared under <code>latex.template.override</code> in <code>manifest.toml</code>. These always win.</li> <li>Fragment overrides \u2014 declared via <code>partials</code> in <code>fragment.toml</code> or a fragment entrypoint. They apply after core defaults but are superseded by template overrides.</li> <li>Core defaults \u2014 shipped with TeXSmith (<code>src/texsmith/adapters/latex/partials</code>).</li> </ol> <p>Conflicts &amp; requirements: - Two fragments cannot override the same partial; TeXSmith raises a <code>TemplateError</code>. - Templates and fragments can declare <code>required_partials</code> (list of names without extensions). Missing entries abort the render with a clear error. - Providers are tracked so diagnostics can point to the template or fragment responsible.</p> <p>Usage: - Templates: list override paths in <code>manifest.toml</code> under <code>latex.template.override</code> (relative to the template root, <code>template/overrides</code>, or <code>overrides/</code>). - Fragments: add <code>partials = [\"strong.tex\", \"codeblock.tex\"]</code> (or a <code>{ name = \"path\" }</code> mapping) plus optional <code>required_partials</code> inside <code>fragment.toml</code>. Entry points may return the same fields on the <code>Fragment</code> object.</p> <p>Guidance: - Prefer template overrides for document-wide styling or publisher branding. - Use fragment overrides to co-locate rendering tweaks with the feature they own (callouts, code, glossary). - Keep a single source of truth per partial; if a fragment needs to opt out, expose a fragment attribute instead of overlapping overrides.</p>"},{"location":"guide/templates/template-cookbook/","title":"Template Cookbook","text":"<p>This cookbook collects repeatable patterns for building and iterating on TeXSmith templates. Use it in combination with the Templates primer when you need concrete commands or Jinja snippets.</p>"},{"location":"guide/templates/template-cookbook/#clone-a-starter-and-rename-it","title":"Clone a starter and rename it","text":"<pre><code>cp -R src/texsmith/templates/article texsmith-template-report\ncd texsmith-template-report\n\n# Update package metadata\nrg -l \"article\" | xargs sed -i 's/article/report/g'\n</code></pre> <p>Adjust <code>pyproject.toml</code> (name, version), <code>template/manifest.toml</code> (template attributes), and <code>README.md</code>. Keep <code>tests/</code> so you can run <code>uv run pytest</code> after each change.</p>"},{"location":"guide/templates/template-cookbook/#inspect-metadata-with-template-info","title":"Inspect metadata with <code>template info</code>","text":"<pre><code>texsmith --template ./texsmith-template-report --template-info\n</code></pre> <p>Use the output to validate:</p> <ul> <li>Slots and their depth/offsets.</li> <li>Attribute defaults and normalizers (escape rules, <code>required</code> flags).</li> <li>Declared assets and whether they require templating.</li> <li>TEX Live year, tlmgr packages, and shell-escape requirements.</li> </ul>"},{"location":"guide/templates/template-cookbook/#tip","title":"Tip","text":"<p>Run the command inside CI to log tlmgr prerequisites, then cache <code>tlmgr install ...</code> between builds.</p>"},{"location":"guide/templates/template-cookbook/#map-mkdocs-sections-to-slots","title":"Map MkDocs sections to slots","text":"<p>When a template defines slots such as <code>frontmatter</code>, <code>mainmatter</code>, and <code>appendix</code>, wire documents via CLI selectors:</p> <pre><code>texsmith docs/intro.md docs/manual.md docs/appendix.md \\\n  --template texsmith-template-report \\\n  --slot frontmatter:docs/intro.md \\\n  --slot mainmatter:docs/manual.md \\\n  --slot appendix:docs/appendix.md#appendix-a \\\n  --output-dir build/report \\\n  --build\n</code></pre> <p>The <code>#appendix-a</code> selector pulls only the section with that ID. Mix selectors freely (IDs, headings, <code>@document</code>) to keep Markdown sources modular.</p>"},{"location":"guide/templates/template-cookbook/#override-partials","title":"Override partials","text":"<p>Place overrides under <code>overrides/partials/</code>. Update <code>manifest.toml</code>:</p> <pre><code>[latex.template]\noverride = [\"partials/bold.tex\"]\n</code></pre> <p>Then create <code>overrides/partials/bold.tex</code>:</p> <pre><code>\\textbf{%\n  \\BLOCK{ if attrs.emphasis }%\n    \\VAR{attrs.emphasis}~%\n  \\BLOCK{ endif }%\n  \\VAR{text}%\n}\n</code></pre> <p>The renderer will prefer this file over the built-in partial when emitting bold spans.</p>"},{"location":"guide/templates/template-cookbook/#inject-custom-assets","title":"Inject custom assets","text":"<p>Add extra files (preamble snippets, latexmk config, fonts) through the <code>[latex.template.assets]</code> table:</p> <pre><code>[latex.template.assets]\n\".latexmkrc\" = { source = \"template/assets/latexmkrc\" }\n\"fonts/MySerif.otf\" = { source = \"template/assets/fonts/MySerif.otf\" }\n</code></pre> <p>Assets are copied to the render directory. Combine this with <code>latexmkrc</code> options (<code>-shell-escape</code>) or fontspec helpers to keep users from editing the generated output manually.</p>"},{"location":"guide/templates/template-cookbook/#publish-and-version-responsibly","title":"Publish and version responsibly","text":"<ul> <li>Set <code>compat.texsmith = \"&gt;=0.3,&lt;0.4\"</code> so incompatible engine changes fail fast.</li> <li>Tag template releases with the same TEX Live year used in <code>manifest.toml</code>.</li> <li>Document tlmgr packages, slot names, and attribute changes in your README so downstream projects can upgrade with confidence.</li> </ul>"},{"location":"guide/templates/template-cookbook/#further-reading","title":"Further reading","text":"<ul> <li>Templates primer \u2013 attribute schema, manifest format, and slot mechanics.</li> <li>API High-Level Workflows \u2013 use <code>ConversionService</code> to assemble slots programmatically.</li> <li>Troubleshooting \u2013 debugging latexmk, shell-escape, and bibliography issues once your template ships.</li> </ul>"},{"location":"syntax/","title":"Markdown","text":"<p>If Markdown is new to you, start with the canonical guide.</p> <p>The original spec is spartan\u2014tables, diagrams, and other niceties didn\u2019t exist.</p> <p>Over time new flavours sprouted to fill the gaps. Because TeXSmith targets MkDocs, it aligns with Python-Markdown (MkDocs\u2019 engine) plus the usual suspects like Pymdown Extensions.</p> <p>For printed documentation, especially for scientific or technical reports, some additional features are required:</p> <ul> <li>Citations and bibliographies</li> <li>Cross-references</li> <li>Diagrams (Mermaid, Graphviz, Vega)</li> <li>Mathematical formulas (LATEX math)</li> <li>Index</li> <li>Glossary and acronyms</li> <li>Rich tables (span, multi-line cells, etc.)</li> <li>Direct LATEX injections using fenced <code>/// latex</code> blocks or inline <code>{latex}[...]</code> snippets that stay hidden in HTML but reach the LATEX output unchanged</li> </ul>"},{"location":"syntax/#markdown-is-a-mess","title":"Markdown is a mess","text":"<p>So many flavours, so many extensions, so many incompatible syntaxes\u2014it\u2019s a jungle. CommonMark tried to herd the cats and mostly succeeded, but fragmentation remains. MyST brought Sphinx-style goodies to Markdown, yet it isn\u2019t MkDocs-compatible, so TeXSmith had to chart its own course.</p> <p></p> <p>Source: xkcd<sup>1</sup>.</p> <p>TeXSmith is unapologetically opinionated: it curates a stack, sprinkles extra sauce on top, and calls the bundle Tmark (TeXSmith Markdown).</p>"},{"location":"syntax/#texsmith-compatibility","title":"TeXSmith compatibility","text":""},{"location":"syntax/#commonmark","title":"CommonMark","text":"<p>CommonMark is the standardized, modern version of Markdown.</p> Feature Syntax Supported Italic <code>*x*</code> Yes Bold <code>**x**</code> Yes Heading <code># H</code> Yes Links <code>[Text](url)</code> Yes Images <code>![Alt](url)</code> Yes Inline Code <code>`code`</code> Yes Footnotes <code>^[1]</code> Yes Tables Yes Blockquotes <code>&gt; Quote</code> Yes Ordered Lists <code>1. Item</code> Yes Unordered Lists <code>- Item</code> Yes Horizontal Rules <code>---</code> Yes Superscript <code>^x^</code> Yes Subscript <code>~x~</code> Yes Strikethrough <code>~~x~~</code> Yes"},{"location":"syntax/#github-flavored-markdown-gfm","title":"GitHub Flavored Markdown (GFM)","text":"<p>GFM is the version of Markdown used by GitHub, which extends CommonMark with additional features.</p> Feature Syntax Supported Separator <code>***</code>, <code>___</code> Yes"},{"location":"syntax/#python-markdown","title":"Python Markdown","text":"<p>Python-Markdown is the Markdown engine used by MkDocs. It extends CommonMark with a variety of features through extensions.</p> Feature Syntax Extension Supported Definition Lists <code>: def</code> <code>def_list</code> Yes Admonitions <code>!!! note</code> <code>admonition</code> Yes Inline Math <code>$\\sqrt{x}$</code> <code>mdx_math</code> Yes SmartyPants <code>&lt;&lt; &gt;&gt;</code>, <code>...</code>, <code>--</code>, <code>---</code> <code>smarty</code> Yes WikiLinks <code>[[Wiki link]]</code> <code>wikilinks</code> Yes"},{"location":"syntax/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>Pymdown Extensions is a popular collection of Markdown extensions for Python-Markdown, which adds many useful features.</p> Feature Syntax Extension Supported Better Emphasis <code>***x***</code> <code>pymdownx.betterem</code> Yes Superscript <code>x^2^</code> <code>pymdownx.caret</code> Yes Underline <code>^^x^^</code> <code>pymdownx.caret</code> Yes Strikethrough <code>~~x~~</code> <code>pymdownx.tilde</code> Yes Collapsible Sections <code>??? note</code> <code>pymdownx.details</code> Yes Emoji <code>:smile:</code> <code>pymdownx.emoji</code> Yes Code Highlight <code>`#!php echo \"Hello\";`</code> <code>pymdownx.inlinehilite</code> Yes Keys <code>++ctrl+a++</code> <code>pymdownx.keys</code> Yes Magic Links <code>https://acme.com</code> <code>pymdownx.magiclink</code> Yes Highlight <code>==x==</code> <code>pymdownx.mark</code> Yes Smart Symbols <code>(c)</code> <code>pymdownx.smartsymbols</code> Yes Task Lists <code>- [ ]</code> <code>pymdownx.tasklist</code> Yes"},{"location":"syntax/#texsmith-extensions","title":"TeXSmith Extensions","text":"Feature Syntax Extension Small Caps <code>^^x^^</code> <code>texsmith.extensions.smallcaps</code> Mermaid <code>![](diagram.mmd)</code> <code>texsmith.extensions.mermaid</code> Progress Bars <code>[=75% \"Done\"]</code> <code>texsmith.progressbar</code> Bibliography <code>[^citekey]</code> <code>texsmith.bibliography</code> Index Entries <code>{index}[entry]</code> (use <code>{index:registry}[entry]</code> to target another registry; add more <code>[level]</code> brackets for nesting) <code>texsmith.index</code> Acronyms <code>ACME (Acme Corporation)</code> <code>texsmith.acronyms</code> Raw LATEX <code>/// latex</code>, <code>{latex}[x]</code> <code>texsmith.extensions.latex_raw</code> LATEX Text <code>LaTeX</code>, <code>TeXSmith</code> <code>texsmith.latex</code>"},{"location":"syntax/#other","title":"Other","text":"<p>| Cross-references         |               |  Yes       | | Mermaid Diagrams         |               |  Yes       | | Graphviz Diagrams        |               |  Yes       | | Vega Diagrams            |               |  Yes       | | Svgbob Diagrams          |               |  Yes       | | CircuitTikZ Diagrams     |               |  Yes       |</p>"},{"location":"syntax/#default-extensions","title":"Default Extensions","text":"<ul> <li>Python Markdown</li> <li>abbr</li> <li>admonition</li> <li>attr_list</li> <li>def_list</li> <li>footnotes</li> <li>smarty</li> <li>tables</li> <li>mdx_math</li> <li>md_in_html</li> <li>TeXSmith</li> <li>texsmith.extensions.multi_citations:MultiCitationExtension</li> <li>texsmith.extensions.latex_raw:LatexRawExtension</li> <li>texsmith.extensions.missing_footnotes:MissingFootnotesExtension</li> <li>texsmith.extensions.latex_text:LatexTextExtension</li> <li>texsmith.extensions.smallcaps:SmallCapsExtension</li> <li>texsmith.progressbar:ProgressBarExtension</li> <li>Pymdown Extensions</li> <li>pymdownx.betterem</li> <li>pymdownx.blocks.caption</li> <li>pymdownx.blocks.html</li> <li>pymdownx.caret</li> <li>pymdownx.critic</li> <li>pymdownx.details</li> <li>pymdownx.emoji</li> <li>pymdownx.fancylists</li> <li>pymdownx.highlight</li> <li>pymdownx.inlinehilite</li> <li>pymdownx.keys</li> <li>pymdownx.magiclink</li> <li>pymdownx.mark</li> <li>pymdownx.saneheaders</li> <li>pymdownx.smartsymbols</li> <li>pymdownx.snippets</li> <li>pymdownx.superfences</li> <li>pymdownx.tabbed</li> <li>pymdownx.tasklist</li> <li>pymdownx.tilde</li> </ul>"},{"location":"syntax/#raw-latex-snippets-latex-latex","title":"Raw LATEX Snippets (<code>/// latex</code>, <code>{latex}[...]</code>)","text":"<p>When you need to insert LATEX that must not appear in the HTML build, use the dedicated fence:</p> <pre><code>/// latex\n\\newcommand{\\R}{\\mathbb{R}}\n///\n</code></pre> <p>For inline tweaks, drop <code>{latex}[payload]</code> anywhere inside your paragraph:</p> <pre><code>Section break {latex}[\\clearpage] before the next topic.\n</code></pre> <p>Both syntaxes create hidden nodes (<code>&lt;p&gt;</code> for blocks, <code>&lt;span&gt;</code> for inline) so the fragments remain invisible online. During the HTML \u2192 LATEX conversion, TeXSmith spots these nodes and drops the original payload straight into the final document. This makes it safe to declare macros, page tweaks, or any advanced snippet without impacting the web version.</p> <ol> <li> <p>xkcd:927 \u21a9</p> </li> </ol>"},{"location":"syntax/abbr/","title":"Abbreviations / Acronyms","text":"<p>Enable the <code>texsmith.abbr</code> extension and you can sprinkle definitions directly into your Markdown. Drop the abbreviation between square brackets, follow it with the expanded form in parentheses, and the parser does the rest.</p> <pre><code>The HTML specification is maintained by the W3C.\n\n*[HTML]: HyperText Markup Language\n*[W3C]: World Wide Web Consortium\n</code></pre> <p>TeXSmith renders that snippet as:</p> <pre><code>$ uv run texsmith abbr.md\nThe \\acrshort{HTML} specification is maintained by the \\acrshort{W3C}.\n</code></pre> <p>Which displays as:</p> <pre><code>---\npress:\n  template: article\n  paper:\n    width: 150mm\n    height: 90mm\n    orientation: landscape\n  frame: true\nfragments:\n  ts-frame\n---\nThe HTML specification is maintained by the W3C.\n\n*[HTML]: HyperText Markup Language\n*[W3C]: World Wide Web Consortium\n</code></pre> <p>Of course, this also works on this HTML site. Try hovering over the abbreviations.</p> <p>Acronyms are collected automatically during the LATEX pass:</p> <pre><code>$ uv run texsmith test.md -tarticle 1&gt;/dev/null\n$ rg newacronym build/test.tex\n92:\\newacronym{HTML}{HTML}{HyperText Markup Language}\n93:\\newacronym{W3C}{W3C}{World Wide Web Consortium}\n</code></pre>"},{"location":"syntax/admonitions/","title":"Admonitions","text":"<p>Admonitions are little callout blocks for surfacing notes, warnings, tips, and whatever else you need to highlight. Python-Markdown\u2019s <code>admonition</code> extension powers them.</p> <p>You can render them in two flavors. The plain/static variant looks like this:</p> <pre><code>!!! note \"This is a Note\"\n    Any number of other indented Markdown elements.\n\n    This is the second paragraph.\n</code></pre> <p>This is a Note</p> <p>Any number of other indented Markdown elements.</p> <p>This is the second paragraph.</p> <p>Prefer collapsible callouts? Use the foldable form:</p> <pre><code>??? note \"This is a Note\"\n    Any number of other indented markdown elements.\n\n    This is the second paragraph.\n</code></pre> This is a Note <p>Any number of other indented markdown elements.</p> <p>This is the second paragraph.</p>"},{"location":"syntax/admonitions/#latex-rendering","title":"LATEX Rendering","text":"<p>TeXSmith maps admonitions onto the <code>tcolorbox</code> package automatically, so they come through in LATEX without extra work. Template authors can still restyle them via the preamble or dedicated slots.</p> <p>Built-in templates like <code>article</code> and <code>book</code> ship with sensible defaults. Tweak the look by setting <code>callout_style</code> in front matter (or via <code>--attribute callout_style=&lt;style&gt;</code>):</p> <pre><code>---\npress:\n  callout_style: classic  # fancy | classic | minimal\n---\n</code></pre> <ul> <li><code>fancy</code> (default): colored headings with icons.</li> <li><code>classic</code>: black-and-white layout with a bold left rule.</li> <li><code>minimal</code>: subtle border, rounded corners, and no icons.</li> </ul> Fancy AdmonitionsClassic AdmonitionsMinimal Admonitions <pre><code>cwd: ../../examples/admonition\nsources:\n  - admonition.md\npress:\n  template: article\n  callout_style: fancy\n</code></pre> <pre><code>cwd: ../../examples/admonition\nsources:\n  - admonition.md\npress:\n  template: article\n  callout_style: classic\n</code></pre> <pre><code>cwd: ../../examples/admonition\nsources:\n  - admonition.md\npress:\n  template: article\n  callout_style: minimal\n</code></pre>"},{"location":"syntax/admonitions/#built-in-admonition-types","title":"Built-in Admonition Types","text":"<p>The following admonition types are built into the <code>admonition</code> extension:</p> <p>Note</p> <p>A Note</p> <p>Tip</p> <p>A Tip</p> <p>Warning</p> <p>A Warning</p> <p>Important</p> <p>An important notice</p> <p>Danger</p> <p>A danger notice</p> <p>Info</p> <p>An info notice</p> <p>Hint</p> <p>A Hint</p> <p>Seealso</p> <p>A see-also notice</p> <p>Question</p> <p>A question notice</p> <p>Abstract</p> <p>An abstract</p>"},{"location":"syntax/captions/","title":"Captions","text":"<p>Markdown doesn\u2019t ship with a native caption primitive for figures or tables. The closest thing is image <code>alt</code> text:</p> <pre><code>![This is the alt text](image.png)\n</code></pre> <p>Alt text exists for accessibility, not for captions. Some browsers show it as a tooltip, but it is not a real caption and you can\u2019t style it separately. Moreover, since it is inserted in an HTML tag's attribute, it can\u2019t contain block elements or complex formatting.</p> <p>Fortunately, <code>pymdownx.blocks.captions</code> adds proper caption blocks:</p> <pre><code>As seen in [this figure](#my-figure), the results are significant.\n\n![This is the alt text](https://picsum.photos/400/150)\n\n/// caption #my-figure\nThis is the caption for the figure.\n///\n</code></pre> <p>Enable numbering and each document gets its own sequence starting at 1.</p> <pre><code>As seen in [this figure](#my-figure), the results are significant.\n\n![This is the alt text](https://picsum.photos/400/150)\n\n/// caption\n    attrs: {id: my-figure}\nThis is the caption for the figure.\n///\n</code></pre>"},{"location":"syntax/captions/#latex","title":"LATEX","text":"<p>LATEX wraps figures/tables in <code>figure</code>/<code>table</code> environments, uses <code>\\caption{}</code> for the text, and <code>\\label{}</code> for cross-references:</p> <pre><code>As seen in Figure \\ref{fig:my-figure}, the results are significant.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\includegraphics{image.png}\n  \\caption{This is the caption for the figure.}\n  \\label{fig:my-figure}\n\\end{figure}\n</code></pre>"},{"location":"syntax/captions/#addressing-issues","title":"Addressing issues","text":"<ol> <li>Consistent numbering across a document</li> <li>Easy cross-references</li> <li>Short captions for lists of figures/tables</li> </ol>"},{"location":"syntax/captions/#coherent-numbering","title":"Coherent numbering","text":"<p>Markdown headings aren\u2019t numbered, so figures/tables can\u2019t piggyback on heading numbering. On the web that\u2019s fine\u2014hyperlinks rule the navigation story\u2014but in print numbering is essential. Guideline:</p> <p>Printed documents shall have numbered heading elements, figures, and tables for cross-referencing. Web documents, however, should not have numbered headings, figures, or tables, relying instead on hyperlinks for navigation.</p> <p>Printed LATEX floats figures and tables, so writers can\u2019t assume a caption stays \u201cabove\u201d or \u201cbelow\u201d the reference. HTML is literal: the figure stays where you put it.</p> <p>On printed documents, the words \"above\" and \"below\" when referring to figures and tables shall never be used, as their position may vary due to floating. On web documents, \"above\" and \"below\" may be used, as figures and tables appear exactly where they are defined.</p>"},{"location":"syntax/captions/#cross-referencing-captions","title":"Cross-referencing captions","text":"<p>That rule complicates cross-references: web versions prefer \u201cthis figure below,\u201d whereas LATEX wants \u201cFigure 2.\u201d Examples:</p> <pre><code>As seen in [this figure below](#my-figure), the results are significant.\n\nAs seen [here](#my-figure), the results are significant.\n\nThe results [shown](#my-figure) are significant.\n</code></pre> <p>In LATEX you\u2019d use:</p> <pre><code>As seen in Figure \\ref{fig:my-figure}, the results are significant.\n</code></pre> <p>Language adds another wrinkle: \u201cFigure\u201d in English, \u201cfigure\u201d (lowercase) in French mid-sentence, \u201cAbbildung\u201d in German, and so on. Hardcoding wording would be brittle.</p> <p>Fortunately <code>pymdownx.blocks.captions</code> tracks IDs, so TeXSmith can bridge both worlds with a shared syntax:</p> <pre><code>As seen in [](#fig:my-figure), the results are significant.\n</code></pre> <p>Any link whose fragment starts with <code>fig:</code> is decorated with the assigned number. The HTML output looks like:</p> <pre><code>As seen in &lt;a href=\"#fig:my-figure\"&gt;Figure &lt;span class=\"caption-number\"&gt;1&lt;/span&gt;&lt;/a&gt;, the results are significant.\n</code></pre> <p>In LATEX:</p> <pre><code>As seen in Figure \\ref{fig:my-figure}, the results are significant.\n</code></pre> <p>Or with <code>cleveref</code>:</p> <pre><code>As seen in \\Cref{fig:my-figure}, the results are significant.\n</code></pre> <p>Pandoc users write <code>{@fig:my-figure}</code>; the idea is the same.</p>"},{"location":"syntax/captions/#short-caption-names","title":"Short caption names","text":"<p>Printed lists of figures appreciate a condensed caption. LATEX handles this via the optional <code>\\caption[]</code> argument:</p> <pre><code>\\caption[Short caption for list of figures]{This is the caption for the figure.}\n</code></pre> <p>TeXSmith reuses the Markdown <code>alt</code> text as that short entry:</p> <pre><code>![Short caption for list of figures](image.png)\n\n/// figure-caption #my-figure\nThis is the caption for the figure.\n///\n</code></pre> <p>The current syntax is a bit verbose. In the future we\u2019d like a shorthand along these lines:</p> <pre><code>![Short caption](image.png){#my-figure}\n\nCaption: This is the caption for the figure.\n</code></pre>"},{"location":"syntax/captions/#tables","title":"Tables","text":"<p>Tables follow the same pattern:</p> <pre><code>| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n\nTable: This is the caption for the table. {#my-table, short=\"Short caption for list of tables\"}\n</code></pre>"},{"location":"syntax/code/","title":"Code","text":"<p>Code fences are one of Markdown\u2019s greatest hits: drop a triple backtick block, label it, and you get nicely formatted snippets. TeXSmith leans on the <code>minted</code> package for LATEX output. It\u2019s a bit slower than <code>listings</code>, but the highlighting is richer, it speaks more languages, and its Unicode support (especially under XeLaTeX/LuaLaTeX) is top-notch.</p>"},{"location":"syntax/code/#code-blocks","title":"Code Blocks","text":"<p>You can insert code snippets and specify options for syntax highlighting.</p> <ul> <li>Line numbers with <code>linenums=\"1\"</code></li> <li>Title with <code>title=\"filename.ext\"</code></li> <li>Highlight specific lines with <code>hl_lines=\"2-3\"</code></li> </ul>"},{"location":"syntax/code/#name-your-code-blocks","title":"Name your code blocks","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"syntax/code/#add-line-numbers","title":"Add line numbers","text":"<pre><code>function bubbleSort(items) {\n    for (let i = 0; i &lt; items.length; i++) {\n        for (let j = 0; j &lt; items.length - 1 - i; j++) {\n            if (items[j] &gt; items[j + 1]) {\n                [items[j], items[j + 1]] = [items[j + 1], items[j]];\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"syntax/code/#highlight-specific-lines","title":"Highlight specific lines","text":"<pre><code>(defun bubble-sort (items)\n  (dotimes (i (length items))\n    (dotimes (j (- (length items) 1 i))\n      (when (&gt; (nth j items) (nth (+ j 1) items))\n        (rotatef (nth j items) (nth (+ j 1) items))))))\n</code></pre>"},{"location":"syntax/code/#snippets","title":"Snippets","text":"<p>With <code>pymdownx.snippets</code> you can pull code from external files, keeping samples reusable across docs.</p> <pre><code>```python\n--8&lt;-- \"examples/code/bubble_sort.py\"\n```\n</code></pre> <p>Tip</p> <p>If you're using MkDocs, ensure that the <code>base_path</code> for snippets is correctly set in your configuration to point to the directory containing your code files.</p> <p>A safe configuration would be:</p> <pre><code>- pymdownx.snippets:\n    check_paths: true\n    base_path: !relative $config_dir\n</code></pre>"},{"location":"syntax/code/#with-latex-output","title":"With LATEX output","text":"<p>Here\u2019s what the above examples look like when rendered with TeXSmith:</p> <pre><code># Code Blocks\n\n## Name your code blocks\n\n``` py title=\"Bubble Sort Algorithm\"\ndef bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n```\n\n## Add line numbers\n\n``` javascript linenums=\"1\"\nfunction bubbleSort(items) {\n    for (let i = 0; i &lt; items.length; i++) {\n        for (let j = 0; j &lt; items.length - 1 - i; j++) {\n            if (items[j] &gt; items[j + 1]) {\n                [items[j], items[j + 1]] = [items[j + 1], items[j]];\n            }\n        }\n    }\n}\n```\n\n## Highlight specific lines\n\n``` lisp hl_lines=\"2-3\"\n(defun bubble-sort (items)\n  (dotimes (i (length items))\n    (dotimes (j (- (length items) 1 i))\n      (when (&gt; (nth j items) (nth (+ j 1) items))\n        (rotatef (nth j items) (nth (+ j 1) items))))))\n```\n</code></pre>"},{"location":"syntax/code/#inline-code","title":"Inline Code","text":"<p>You can also include inline code snippets using backticks <code>`</code> like this:</p>"},{"location":"syntax/code/#unformatted","title":"Unformatted","text":"<pre><code>To sort a list in Python, you can use the `sorted()` function.\n</code></pre> <p>It will simply be rendered as monospaced text in LATEX:</p> <pre><code>To sort a list in Python, you can use the \\texttt{sorted()} function.\n</code></pre>"},{"location":"syntax/code/#highlighted","title":"Highlighted","text":"<p>Inline code can also be highlighted thanks to the Pymdownx <code>inlinehilite</code> extension.</p> <pre><code>You can use `` `#!py print(\"Hello, World!\")` `` to display a message in Python.\n\n&gt; You can use `#!py print(\"Hello, World!\")` to display a message in Python.\n</code></pre> <p>With TeXSmith this example renders as follows:</p> <pre><code># Inline Code\n\nIn C the `strstr` function defined with the prototype\n`#!c char *strstr(const char *haystack, const char *needle);` is\nused to locate a substring within a string. It returns a pointer to the first occurrence of the substring\n`needle` in the string `haystack`, or `NULL` if the substring is not found.\n\nIn Python, you can achieve similar functionality using the `find` method of strings for example: `#!python haystack.find(sub: int) -&gt; int`. This method returns the lowest index of the substring if found in the string, otherwise it returns `-1`.\n</code></pre> <pre><code># Inline Code\n\nIn C the `strstr` function defined with the prototype\n`#!c char *strstr(const char *haystack, const char *needle);` is\nused to locate a substring within a string. It returns a pointer to the first occurrence of the substring\n`needle` in the string `haystack`, or `NULL` if the substring is not found.\n\nIn Python, you can achieve similar functionality using the `find` method of strings for example: `#!python haystack.find(sub: int) -&gt; int`. This method returns the lowest index of the substring if found in the string, otherwise it returns `-1`.\n</code></pre>"},{"location":"syntax/deflists/","title":"Definition Lists","text":"<p>Definition lists pair a term with one or more definitions. Markdown sticks to a simple pattern:</p> <pre><code>Apple\n:   Pomaceous fruit of plants of the genus Malus in\n    the family Rosaceae.\n\nOrange\n:   The fruit of an evergreen tree of the genus Citrus.\n</code></pre> <p>Which renders as:</p> Apple Pomaceous fruit of plants of the genus Malus in the family Rosaceae. Orange The fruit of an evergreen tree of the genus Citrus. <p>LATEX output:</p> <pre><code>\\begin{description}\n\\item[Apple] Pomaceous fruit of plants of the genus Malus in the family Rosaceae.\n\\item[Orange] The fruit of an evergreen tree of the genus Citrus.\n\\end{description}\n</code></pre> <pre><code>Apple\n:   Pomaceous fruit of plants of the genus Malus in\n    the family Rosaceae.\n\nOrange\n:   The fruit of an evergreen tree of the genus Citrus.\n</code></pre>"},{"location":"syntax/extra/","title":"Custom Attributes","text":"<p>These are the stalwarts borrowed from PHP Markdown Extra and bundled directly with Python-Markdown.</p> <pre><code>pip install markdown\n</code></pre>"},{"location":"syntax/extra/#attribute-lists","title":"Attribute Lists","text":"<p>Attribute Lists add lightweight metadata to headings, paragraphs, images, links, and more. Drop a brace block right after the element:</p> <pre><code># Header 1 {#header1 .class1 key=\"value\"}\n\nThis is a paragraph with a class and an ID.\n{: #para1 .text key=\"value\" }\n\n![Alt text](image.jpg){#img1 .responsive width=\"300\"}\n\n| set on td    | set on em   |\n|--------------|-------------|\n| *a* { .foo } | *b*{ .foo } |\n</code></pre>"},{"location":"syntax/formatting/","title":"Text Formatting","text":"<p>Like vanilla Markdown, you can apply basic text formatting using a variety of delimiters. TeXSmith extends this with small capitals support.</p> <pre><code>The quick brown fox jumps over the lazy dog. *(regular)*\n\n*The quick brown fox jumps over the lazy dog.* *(italic)*\n\n**The quick brown fox jumps over the lazy dog.** *(bold)*\n\n***The quick brown fox jumps over the lazy dog.*** *(bold italic)*\n\n~~The quick brown fox jumps over the lazy dog.~~ *(strikethrough)*\n\n__The quick brown fox jumps over the lazy dog.__ *(small capitals)*\n</code></pre> <pre><code>The quick brown fox jumps over the lazy dog. *(regular)*\n\n*The quick brown fox jumps over the lazy dog.* *(italic)*\n\n**The quick brown fox jumps over the lazy dog.** *(bold)*\n\n***The quick brown fox jumps over the lazy dog.*** *(bold italic)*\n\n~~The quick brown fox jumps over the lazy dog.~~ *(strikethrough)*\n\n__The quick brown fox jumps over the lazy dog.__ *(small capitals)*\n</code></pre> <p>The <code>pymdownx.betterem</code> extension lets you stack delimiters for bold italic.</p> <p>Note</p> <p>In MkDocs, you need to specify how to render small capitals using a custom CSS:</p> <pre><code>.texsmith-smallcaps {\n    font-variant: small-caps;\n    letter-spacing: 0.04em;\n}\n</code></pre> <p>Then, include this CSS in your MkDocs configuration under <code>extra_css</code>:</p> <pre><code>extra_css:\n  - stylesheets/smallcaps.css\n</code></pre>"},{"location":"syntax/images/","title":"Images","text":"<p>Images can be included in Markdown using the following syntax:</p> <pre><code>![Alt text](https://picsum.photos/400/150){width=50%}\n</code></pre> <p>The width attribute is useful to scale images directly in the Markdown source.</p> <pre><code>![Alt text](https://picsum.photos/400/150){width=50%}\n</code></pre>"},{"location":"syntax/math/","title":"Math Extension","text":"<p>LATEX is the gold standard for math notation. TeXSmith relies on the same syntax that MathJax/Arithmatex understand.</p>"},{"location":"syntax/math/#inline-math","title":"Inline Math","text":"<p>Inline math uses the usual delimiters <code>\\( ... \\)</code> or <code>$ ... $</code>:</p> <pre><code>The quadratic formula is given by \\(x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\)\nor $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$.\n</code></pre> <p>Rendered as:</p> <p>The quadratic formula is given by \\(x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\) or \\(x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\).</p> <p>Note</p> <p>Skip the spaces right after <code>$</code> or <code>\\(</code>\u2014they confuse the parser.</p>"},{"location":"syntax/math/#block-math","title":"Block Math","text":""},{"location":"syntax/math/#simple-equations","title":"Simple equations","text":"<p>Example: Schr\u00f6dinger\u2019s equation in the non-relativistic case:</p> <pre><code>$$\n\\imath \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) =\n\\left[ -\\frac{\\hbar^2}{2m} \\nabla^2 + V(\\mathbf{r},t) \\right] \\Psi(\\mathbf{r},t)\n$$\n</code></pre> \\[ \\imath \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) = \\left[ -\\frac{\\hbar^2}{2m} \\nabla^2 + V(\\mathbf{r},t) \\right] \\Psi(\\mathbf{r},t) \\]"},{"location":"syntax/math/#multiple-equations","title":"Multiple equations","text":"<pre><code>$$\n\\begin{align*}\n\\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\varepsilon_0} \\quad &amp;&amp;\\text{Gauss Law}\\\\[4pt]\n\\nabla \\cdot \\vec{B} &amp;= 0 \\quad &amp;&amp;\\text{Gauss's law for electricity}\\\\[4pt]\n\\nabla \\times \\vec{E} &amp;= -\\,\\frac{\\partial \\vec{B}}{\\partial t}\n    \\quad &amp;&amp;\\text{Faraday's law}\\\\[4pt]\n\\nabla \\times \\vec{B} &amp;= \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0\n    \\frac{\\partial \\vec{E}}{\\partial t}\n\\quad &amp;&amp;\\text{Amp\u00e8re-Maxwell law}\n\\end{align*}\n$$\n</code></pre> \\[ \\begin{align*} \\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\varepsilon_0} \\quad &amp;&amp;\\text{Gauss Law}\\\\[4pt] \\nabla \\cdot \\vec{B} &amp;= 0 \\quad &amp;&amp;\\text{Gauss's law for electricity}\\\\[4pt] \\nabla \\times \\vec{E} &amp;= -\\,\\frac{\\partial \\vec{B}}{\\partial t}     \\quad &amp;&amp;\\text{Faraday's law}\\\\[4pt] \\nabla \\times \\vec{B} &amp;= \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0     \\frac{\\partial \\vec{E}}{\\partial t} \\quad &amp;&amp;\\text{Amp\u00e8re-Maxwell law} \\end{align*} \\]"},{"location":"syntax/math/#numbered-equation","title":"Numbered equation","text":"<p>Wrap an equation inside <code>\\begin{equation}...\\end{equation}</code> (or <code>equation*</code>) to control numbering. Example: the relativistic gravitational field equation:</p> <pre><code>The equation $\\eqref{eq:gravity}$ describes the fundamental interaction of\ngravitation as a result of spacetime being curved by matter and energy.\n\n$$\n\\begin{equation} \\label{eq:gravity}\nR_{\\mu \\nu} - \\frac{1}{2} R g_{\\mu \\nu} + \\Lambda g_{\\mu \\nu} =\n    \\frac{8 \\pi G}{c^4} T_{\\mu \\nu}\n\\end{equation}\n$$\n</code></pre> <p>The equation \\(\\eqref{eq:gravity}\\) describes the fundamental interaction of gravitation as a result of spacetime being curved by matter and energy.</p> \\[ \\begin{equation} \\label{eq:gravity} R_{\\mu \\nu} - \\frac{1}{2} R g_{\\mu \\nu} + \\Lambda g_{\\mu \\nu} = \\frac{8 \\pi G}{c^4} T_{\\mu \\nu} \\end{equation} \\] <p>Reference numbered equations via <code>\\label{}</code> and drop <code>$\\eqref{...}$</code> in Markdown.</p> <p>In an aligned environment, you can number individual lines using the <code>\\label{}</code> command:</p> <pre><code>As we see in $\\eqref{eq:max2}$, the magnetic flux through any closed surface is zero;\nthis implies that there are no magnetic monopoles.\n\n$$\n\\begin{align}\n\\oint_{\\partial V} \\vec{E} \\cdot d\\vec{S} &amp;= \\frac{Q_{\\text{int}}}{\\varepsilon_0}\n    \\label{eq:max1} \\\\[6pt]\n\\oint_{\\partial V} \\vec{B} \\cdot d\\vec{S} &amp;= 0 \\label{eq:max2} \\\\[6pt]\n\\oint_{\\partial S} \\vec{E} \\cdot d\\vec{\\ell} &amp;= -\\,\\frac{d}{dt} \\int_{S} \\vec{B}\n    \\cdot d\\vec{S} \\label{eq:max3} \\\\[6pt]\n\\oint_{\\partial S} \\vec{B} \\cdot d\\vec{\\ell} &amp;= \\mu_0 I_{\\text{int}}\n+ \\mu_0 \\varepsilon_0 \\frac{d}{dt} \\int_{S} \\vec{E} \\cdot d\\vec{S} \\label{eq:max4}\n\\end{align}\n$$\n</code></pre> <p>As we see in \\(\\eqref{eq:max2}\\), the magnetic flux through a closed surface is zero, implying the lack of magnetic monopoles.</p> \\[ \\begin{align} \\oint_{\\partial V} \\vec{E} \\cdot d\\vec{S} &amp;= \\frac{Q_{\\text{int}}}{\\varepsilon_0} \\label{eq:max1} \\\\[6pt] \\oint_{\\partial V} \\vec{B} \\cdot d\\vec{S} &amp;= 0 \\label{eq:max2} \\\\[6pt] \\oint_{\\partial S} \\vec{E} \\cdot d\\vec{\\ell} &amp;= -\\,\\frac{d}{dt} \\int_{S} \\vec{B} \\cdot d\\vec{S} \\label{eq:max3} \\\\[6pt] \\oint_{\\partial S} \\vec{B} \\cdot d\\vec{\\ell} &amp;= \\mu_0 I_{\\text{int}} + \\mu_0 \\varepsilon_0 \\frac{d}{dt} \\int_{S} \\vec{E} \\cdot d\\vec{S} \\label{eq:max4} \\end{align} \\]"},{"location":"syntax/math/#mkdocs-configuration","title":"MkDocs Configuration","text":"<p>Running under MkDocs? Enable Arithmatex/MathJax and let it handle numbering:</p> <pre><code>markdown_extensions:\n  - pymdownx.arithmatex:\n      generic: true\nextra_javascript:\n  - js/mathjax.js\n  - https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js\n</code></pre> <p>In the <code>js/mathjax.js</code> file, include the following MathJax configuration:</p> <pre><code>window.MathJax = {\n  tex: {\n    inlineMath: [['\\\\(', '\\\\)']],\n    displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']],\n    tags: 'ams',\n    packages: {'[+]': ['ams']}\n  },\n  options: {\n    ignoreHtmlClass: '.*',\n    processHtmlClass: 'arithmatex'\n  }\n};\n</code></pre>"},{"location":"syntax/math/#with-latex-output","title":"With LATEX output","text":"<p>Here\u2019s what the above snippets look like once rendered through TeXSmith:</p> <pre><code>The Schr\u00f6dinger equation in a non-relativistic case is written as:\n\n$$\n\\imath \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) =\n\\left[ -\\frac{\\hbar^2}{2m} \\nabla^2 + V(\\mathbf{r},t) \\right] \\Psi(\\mathbf{r},t)\n$$\n\nAnd the set of Maxwell's equations in differential form. The magnetic flux $\\eqref{eq:max2}$ through any closed surface is zero, which implies that there are no magnetic monopoles.\n\n$$\n\\begin{align}\n\\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\varepsilon_0} \\quad &amp;&amp;\\text{Gauss Law}\\\\[4pt]\n\\nabla \\cdot \\vec{B} &amp;= 0 \\quad &amp;&amp;\\text{Gauss's law for electricity} \\label{eq:max2}\\\\[4pt]\n\\nabla \\times \\vec{E} &amp;= -\\,\\frac{\\partial \\vec{B}}{\\partial t}\n    \\quad &amp;&amp;\\text{Faraday's law}\\\\[4pt]\n\\nabla \\times \\vec{B} &amp;= \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0\n    \\frac{\\partial \\vec{E}}{\\partial t}\n\\quad &amp;&amp;\\text{Amp\u00e8re-Maxwell law}\n\\end{align}\n$$\n</code></pre> <p>With the source:</p> <pre><code>The Schr\u00f6dinger equation in a non-relativistic case is written as:\n\n$$\n\\imath \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r},t) =\n\\left[ -\\frac{\\hbar^2}{2m} \\nabla^2 + V(\\mathbf{r},t) \\right] \\Psi(\\mathbf{r},t)\n$$\n\nAnd the set of Maxwell's equations in differential form. The magnetic flux $\\eqref{eq:max2}$ through any closed surface is zero, which implies that there are no magnetic monopoles.\n\n$$\n\\begin{align}\n\\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\varepsilon_0} \\quad &amp;&amp;\\text{Gauss Law}\\\\[4pt]\n\\nabla \\cdot \\vec{B} &amp;= 0 \\quad &amp;&amp;\\text{Gauss's law for electricity} \\label{eq:max2}\\\\[4pt]\n\\nabla \\times \\vec{E} &amp;= -\\,\\frac{\\partial \\vec{B}}{\\partial t}\n    \\quad &amp;&amp;\\text{Faraday's law}\\\\[4pt]\n\\nabla \\times \\vec{B} &amp;= \\mu_0 \\vec{J} + \\mu_0 \\varepsilon_0\n    \\frac{\\partial \\vec{E}}{\\partial t}\n\\quad &amp;&amp;\\text{Amp\u00e8re-Maxwell law}\n\\end{align}\n$$\n</code></pre>"},{"location":"syntax/mermaid/","title":"Mermaid Diagrams","text":"<p>Just like MkDocs, TeXSmith understands Mermaid diagrams. Browsers render them on the fly, but PDFs need static assets, so TeXSmith converts each diagram into a vector PDF during the build. That requires either:</p> <ol> <li>Installing <code>mermaid-cli</code> and its dependencies in your environment, or</li> <li>Using Docker with the pulled image <code>mermaidjs/mermaid-cli</code>.</li> </ol>"},{"location":"syntax/mermaid/#inline-diagram","title":"Inline diagram","text":"<pre><code>```mermaid\nflowchart LR\n    A --&gt; B\n    B --&gt; C\n```\n</code></pre> <pre><code>flowchart LR\n    A --&gt; B\n    B --&gt; C</code></pre>"},{"location":"syntax/mermaid/#external-diagrams","title":"External diagrams","text":"<p>Sometimes diagrams live better outside the Markdown. TeXSmith supports:</p> <ol> <li>Reference external <code>.mmd</code> / <code>.mermaid</code> files.</li> <li>Embed Mermaid Live snippets using <code>pako:</code> URLs for live editing.</li> </ol> <p>The <code>texsmith.extensions.mermaid</code> extension sniffs out these references, pulls the content in, and treats inline/external sources the same way.</p> <p>Using a <code>mmd</code> file is as simple as including an image:</p> <pre><code>![Build pipeline](../assets/mermaid.mmd)\n</code></pre> <pre>%% Build pipeline\npacket\n    0-15: \"Source Port\"\n    16-31: \"Destination Port\"\n    32-63: \"Sequence Number\"\n    64-95: \"Acknowledgment Number\"\n    96-99: \"Data Offset\"\n    100-105: \"Reserved\"\n    106: \"URG\"\n    107: \"ACK\"\n    108: \"PSH\"\n    109: \"RST\"\n    110: \"SYN\"\n    111: \"FIN\"\n    112-127: \"Window\"\n    128-143: \"Checksum\"\n    144-159: \"Urgent Pointer\"</pre> <p>Mermaid Live encodes diagrams via Pako (a compression library) so you can share/edit them through URLs:</p> <pre><code>![Online Diagram](https://mermaid.live/edit#pako:eNpVTctugzAQ_BVrT4lEEMQEiA_tIemt7aE9tX\nEODl4eSrAtY5q2iH8vEBGpe1jtzOzMdJBpicAgv-hrVgrryPMbV2SYxg1o8T7uJVmtHoipsvNhXxWkNcfby8hMU\npV3O3E6iQKbx_6mVfmgcHjVHMaPxqE5vOgvJLm2V2El0Qon9jjXobnX_Iv4wGbO0GbxpOQSPChsJYE526IHNdpa\njBC60cjBlVgjBzacUtgzB676wWOE-tS6nm1Wt0UJLBeXZkCtkcLhvhKFFfWdtagk2p1ulQO23tApBFgH38DCMPG\nTMKI0TKKABkHswQ-wlPrxOtrSKNnSOA2SsPfgd2oN_DTZ9H9_ZXFC)\n</code></pre> <p>When TeXSmith renders HTML/PDF it wraps the image with a link to the Mermaid Live editor. Click the preview to inspect the source:</p> <pre>%% Example Pako\nflowchart LR\n    start(Start) --&gt; pick[Dig up]\n    pick --&gt; if{Cabbages?}\n    if --\"No\"--&gt; step[Move forward one step]\n    step --&gt; pick\n    if --\"Yes\"--&gt; stop(End)</pre>"},{"location":"syntax/mermaid/#latex-rendering","title":"LATEX Rendering","text":"<p>Here\u2019s how the diagrams look once TeXSmith embeds them:</p> <pre><code># Mermaid Diagrams\n\n## Inline diagram\n\n```mermaid\nflowchart LR\n    A --&gt; B\n    B --&gt; C\n```\n\n## External file\n\n![Build pipeline](../../docs/assets/mermaid.mmd)\n\n## Pako URL\n\n![Example Pako](https://mermaid.live/edit#pako:eNpVTctugzAQ_BVrT4lEEMQEiA_tIemt7aE9tXEODl4eSrAtY5q2iH8vEBGpe1jtzOzMdJBpicAgv-hrVgrryPMbV2SYxg1o8T7uJVmtHoipsvNhXxWkNcfby8hMUpV3O3E6iQKbx_6mVfmgcHjVHMaPxqE5vOgvJLm2V2El0Qon9jjXobnX_Iv4wGbO0GbxpOQSPChsJYE526IHNdpajBC60cjBlVgjBzacUtgzB676wWOE-tS6nm1Wt0UJLBeXZkCtkcLhvhKFFfWdtagk2p1ulQO23tApBFgH38DCMPGTMKI0TKKABkHswQ-wlPrxOtrSKNnSOA2SsPfgd2oN_DTZ9H9_ZXFC)\n</code></pre>"},{"location":"syntax/mermaid/#conversion-by-texsmith","title":"Conversion by TeXSmith","text":"<p>All Mermaid diagrams are converted to PDF and included with <code>\\includegraphics</code> so they integrate cleanly with templates and LATEX floats.</p> <p>Printed output might deserve a different theme. Point <code>mermaid_config</code> to a JSON config (front matter or CLI <code>--attribute press.mermaid_config=...</code>) to override:</p> <pre><code>---\npress:\n  mermaid_config: mermaid-config.json\n---\n</code></pre> <p>Alternatively, you can add a <code>mermaid-config.json</code> file to the <code>~/.texsmith/</code> directory to apply it globally to all your TeXSmith projects.</p>"},{"location":"syntax/notes/","title":"Notes on TeXSmith Extensions","text":"<p>TeXSmith ships with laser-focused extensions to close the LATEX-sized gaps that stock Markdown leaves behind. They cooperate with MkDocs and MkDocs Material, tagging the HTML with enough metadata for the LATEX renderer to finish the heavy lifting.</p> <ul> <li>Index entries double as Lunr tags in MkDocs and page references in LATEX.</li> <li>Glossary entries and acronyms keep terminology consistent.</li> <li>Citations and cross-references wire figures, tables, equations, and bibliography entries together.</li> <li>Raw LATEX fences and inline snippets let you sprinkle precise TEX without polluting the HTML build.</li> </ul>"},{"location":"syntax/notes/#syntax","title":"Syntax","text":"<p>The syntax for these helpers follows a few rules:</p> <ol> <li>Easy to type in Markdown.</li> <li>Friendly with standard Markdown parsers.</li> <li>Collision-free with existing extensions.</li> <li>Minimal visual noise in the raw text.</li> </ol>"},{"location":"syntax/notes/#syntax-shorthand","title":"Syntax shorthand","text":"<code>@[]</code> Smart references Expands to the proper label for the referenced object. Figures become <code>Figure X</code>, tables render as <code>Table Y</code>, sections as <code>Section Z</code>, equations as <code>(N)</code>, theorems as <code>Theorem M</code>, and so on. <code>^[]</code> Footnotes/bibliographic citations Resolves to either an inline footnote (if defined locally) or a bibliography citation. <code>{index}[...]</code> Index entries Inserts one or more index terms. They stay invisible in HTML yet show up as tags in Lunr and as <code>\\index{}</code> entries in LATEX. <p>Quick reference:</p> <ul> <li><code>[](:)</code> Add content block</li> <li><code>@()</code> Cross-reference helper</li> <li><code>^[]</code> / <code>\\cite{}</code> Bibliographic citation</li> <li><code>{index}[term]</code> / <code>\\index{}</code> Index entry</li> </ul>"},{"location":"syntax/notes/#other-extensions","title":"Other extensions","text":"<ul> <li>Epigraphs: define <code>epigraph</code> blocks in front matter or mark blockquotes with the <code>epigraph</code> class to route them through the LATEX epigraph macro.</li> <li>Drop caps: Material\u2019s <code>lettering</code> syntax (<code>:[A](Natoly)</code>) produces LATEX lettrine output automatically.</li> <li>Wikipedia shortcodes keep working; they simply render as annotated links in both HTML and LATEX.</li> </ul>"},{"location":"syntax/notes/#index","title":"Index","text":"<p>Printed indexes convey intent with typography:</p> <ul> <li>Normal text: the topic is discussed.</li> <li>Italic: quick mention only.</li> <li>Bold: this section focuses on the topic.</li> <li>Bold italic: primary topic plus ancillary references.</li> <li>Nested entries: group related terms.</li> </ul> <p>Use <code>{index}</code> plus multiple <code>[brackets]</code> to build entries. Append <code>{b}</code>, <code>{i}</code>, or <code>{bi}</code> to tweak the style, and specify <code>{index:registry}</code> when you want to file the entry under a custom registry (handy for multi-index books).</p> <pre><code>Do you know the Gulliver's Travels tale about the egg dispute?\n{index}[endianness]{i}\n\n{index}[endianness]{bi}\n{index}[endianness]{b}\n{index}[byte order][endianness]{i}\n{index:physics}[relativity]{b}\n</code></pre>"},{"location":"syntax/notes/#citations","title":"Citations","text":"<p>Bibliographic references land in two ways:</p> <ol> <li>Point TeXSmith at one or more <code>.bib</code> files and cite entries using <code>^[]</code>.</li> <li>Declare references directly in front matter via DOIs or inline metadata.</li> </ol> <pre><code>---\nbibliography:\n  # Just DOI entry, TeXSmith will fetch the rest\n  ein05: https://doi.org/10.1002/andp.19053221004\n  # Manual entry\n  KOFINAS2025:\n    type: article\n    title: |\n        The impact of generative AI on academic integrity of authentic\n        assessments within a higher education context\n    authors:\n      - name: \"Alexander K. Kofinas\"\n        affiliation: \"University of Example\"\n      - \"Crystal Han-Huei Tsay\"\n      - \"David Pike\"\n    journal: \"British Journal of Educational Technology\"\n    date: 2025-03\n    volume: 56\n    number: 6\n    pages: \"2522-2549\"\n    url: https://doi.org/10.1111/bjet.13585\n---\nWe know that time is relative ^[ein05] and recent work explores\nassessment ^[KOFINAS2025]. You can also cite multiple\nreferences ^[ein05,KOFINAS2025].\n</code></pre> <p>Or with the CLI:</p> <pre><code>texsmith article.md article.bib\n</code></pre> <p>Or directly in Python:</p> <pre><code>from pathlib import Path\n\nfrom texsmith import ConversionRequest, ConversionService\n\nservice = ConversionService()\nrequest = ConversionRequest(\n    documents=[Path(\"article.md\")],\n    bibliography_files=[Path(\"article.bib\")]\n)\nresponse = service.execute(request)\ntex_path = response.render_result.main_tex_path\nprint(f\"LaTeX written to: {tex_path}\")\n</code></pre>"},{"location":"syntax/notes/#math","title":"Math","text":"<p>Inline math uses the standard Markdown-friendly delimiters: <code>$...$</code> or <code>\\(...\\)</code> for inline spans, <code>$$...$$</code> or <code>\\[...\\]</code> for display mode. Most Markdown engines (including MkDocs) pass these through untouched.</p> <p>Numbered equations are not part of Markdown itself, so TeXSmith handles the heavy lifting for you.</p> <pre><code>{#pythagoras}\n: $$a^2 + b^2 = c^2$$\n\nFrom @[pythagoras], we know that...\n</code></pre> <p>The equation receives an automatic number and can be referenced inline.</p>"},{"location":"syntax/notes/#theorems","title":"Theorems","text":"<p>Use admonitions to define theorems, lemmas, definitions, and friends.</p> <pre><code>!!! theorem \"Pythagorean Theorem\" {#thm:pythagoras}\n    This is a theorem about right triangles and can be summarized in the next\n    equation\n    $$ x^2 + y^2 = z^2 $$\n</code></pre> <p>It will be rendered as:</p> <pre><code>\\begin{theorem}[Pythagorean theorem]\n\\label{pythagorean}\nThis is a theorem about right triangles and can be summarized in the next\nequation\n\\[ x^2 + y^2 = z^2 \\]\n\\end{theorem}\n</code></pre> <p>TeXSmith automatically generates the following admonition types:</p> <ul> <li>Theorem (\ud83d\udcd0)</li> <li>Corollary (\ud83e\uddfe)</li> <li>Lemma (\ud83d\udcdc)</li> <li>Proof (\ud83d\udd0d)</li> </ul>"},{"location":"syntax/notes/#glossary","title":"Glossary","text":"<p>Specific terms live in the glossary; shorthand belongs in the acronym list. Keep them separate so TeXSmith can decide when to expand, hyperlink, or index each one.</p> Glossary entries Definitions for full terms, whether single words or multi-word concepts. Acronyms Shortened forms such as NASA or UNESCO, often with an expanded description. <p>Define both collections in front matter:</p> <pre><code>acronyms:\n  nasa:\n    name: NASA\n    description: National Aeronautics and Space Administration\n  unesco:\n    name: UNESCO\n    description: United Nations Educational, Scientific and Cultural Organization\nglossary:\n  solid:\n    name: S.O.L.I.D.\n    description: |\n        Acronym for five design principles intended to make software designs\n        more understandable, flexible, and maintainable.\n\n        1. Single Responsibility Principle\n        2. Open/Closed Principle\n        3. Liskov Substitution Principle\n        4. Interface Segregation Principle\n        5. Dependency Inversion Principle\n  liskov:\n    name: Liskov Substitution Principle\n    description: |\n        The Liskov Substitution Principle (LSP) states that objects of a\n        superclass should be replaceable with objects of a subclass without\n        affecting the correctness of the program. In other words, if S is a\n        subtype of T, then objects of type T in a program may be replaced with\n        objects of type S without altering any of the desirable properties of\n        that program (e.g., correctness).\n</code></pre> <p>Inside the Markdown document you can reference glossary entries with the <code>gls:</code> prefix:</p> <pre><code>From the well-known [](gls:solid) principles, the following class must\nbe [](gls:liskov) Substitution Principle-compliant.\n</code></pre>"},{"location":"syntax/notes/#wikipedia","title":"Wikipedia","text":"<p>Many glossary-worthy entries live on Wikipedia, and TeXSmith can pull their summaries automatically.</p> <pre><code>From the well-known [SOLID](https://en.wikipedia.org/wiki/SOLID)\n</code></pre> <p>When enabled, TeXSmith converts Wikipedia links into glossary entries for the printed document.</p> <pre><code>[texsmith.extensions]\nwikipedia_glossary = true\n</code></pre>"},{"location":"syntax/notes/#caption","title":"Caption","text":"TeXSmith style <p>Here is a figure with a caption:</p> <pre><code>A diagram with 25% width\n: ![Diagram example](../examples/diagrams.png){width=25%}\n\nTable Caption Avec une grosse famille de chats  {#bigcats}\n: | Cat Name    | Age | Color      |\n  | ----------- | ---:| ---------- |\n  | Whiskers    |  2  | Tabby      |\n  | Mittens     |  5  | Black      |\n</code></pre> Pymarkdown style <p>Here is a figure with a caption:</p> <pre><code>![Diagram example](../examples/diagrams.png){width=25%}\n\n/// figure-caption\n    attrs: {#foobar}\n    Avec un chocolat violet qui sent la **vanille**\n///\n</code></pre>"},{"location":"syntax/notes/#formatting","title":"Formatting","text":"<p>Plain Markdown covers bold, italic, and <code>inline code</code>. PyMdown extensions add strikethrough, highlighted text, inserted text.</p> <p>Small capitals are missing from the spec, so TeXSmith repurposes the double-underscore syntax for that effect:</p> <pre><code>__Small Capitals__\n</code></pre> <p>which renders as:</p> <pre><code>\\textsc{Small Capitals}\n</code></pre>"},{"location":"syntax/notes/#tables","title":"Tables","text":"<p>One of the limitations of Markdown is the lack of support for complex table features such as multi-row and multi-column cells, cell alignment, and captions.</p> <p>When a table is too large to fit on the page, try:</p> <ul> <li>Slightly resizing the table to fit the available width.</li> <li>Allowing cells to wrap across multiple lines.</li> <li>Rotating the table to landscape orientation.</li> </ul>"},{"location":"syntax/progressbar/","title":"Progress Bars","text":"<p>The <code>texsmith.progressbar</code> extension mirrors the <code>pymdownx.progressbar</code> syntax and converts it into LATEX commands powered by the <code>progressbar</code> package. It is enabled by default, so you can drop the <code>[=75% \"Done\"]</code> shorthand in your Markdown and keep both the HTML preview and the PDF build in sync.</p>"},{"location":"syntax/progressbar/#syntax","title":"Syntax","text":"<pre><code>[=25% \"Research\"]\n[=50% \"Implementation\"]\n[=75% \"Review\"]\n[=100% \"Launch\"]{: .thin}\n</code></pre> <ul> <li>Values must be percentages (<code>0 \u2013 100</code>). TeXSmith clamps the values if needed.</li> <li>The quoted label is optional; when omitted the percentage is used.</li> <li>Trailing attribute lists (<code>{: .class #id }</code>) attach CSS classes and HTML attributes.   Use the <code>.thin</code> class to halve the bar height (e.g. for tables or dense summaries).</li> </ul>"},{"location":"syntax/progressbar/#latex-output","title":"LATEX output","text":"<p>During rendering, TeXSmith emits a <code>\\progressbar</code> call with the following defaults:</p> <pre><code>{\\progressbar[\n  width=9cm,\n  heighta=12pt,\n  roundnessr=0.1,\n  borderwidth=1pt,\n  linecolor=black,\n  filledcolor=black!60,\n  emptycolor=black!10\n]{0.73} Launch}\n</code></pre> <p>The <code>.thin</code> class switches <code>heighta</code> to <code>6pt</code>. If you need more control, wrap the Markdown block in a raw LATEX fence and tweak the options directly.</p>"},{"location":"syntax/progressbar/#example-project","title":"Example project","text":"<p>Use the bundled <code>examples/progressbar</code> project for smoke tests or screenshots:</p> <pre><code>cd examples/progressbar\ntexsmith progressbar.md --template article --output-dir build --build\n</code></pre> <pre><code>[=25% \"Research\"]\n[=50% \"Implementation\"]\n[=75% \"Review\"]\n[=100% \"Launch\"]{: .thin}\n</code></pre>"},{"location":"syntax/references/","title":"References","text":"<p>We define several types of references that can be used throughout the documentation:</p> Internal References These are links that point to other sections within the same document or to other documents within the same project. External References These are links that point to resources outside of the current project, such as websites or external documents. Bibliographic References These are citations that refer to external publications, articles, or books. They are often formatted using a specific citation style (e.g., APA, MLA) and may include a bibliography section at the end of the document. Footnotes Footnotes provide additional information or citations without cluttering the main text. They are typically indicated by a superscript number in the text, with the corresponding footnote text provided at the bottom of the page or section. Equations Mathematical equations can be included in the document using LATEX syntax. Equations can be labeled and referenced throughout the text. Tables Tables are used to present data in a structured format with rows and columns. They can be labeled and referenced within the document. Figures Figures are images, charts, or diagrams included in the document. They can be labeled and referenced throughout the text. Listings/Code Blocks Code blocks are used to display code snippets in various programming languages. They can be labeled and referenced within the document. Tags/Index Tags or index entries allow you to associate keywords with specific sections or topics in the document, making it easier to locate related information."},{"location":"syntax/references/#internal-references","title":"Internal References","text":"<p>You can reference another section in the same document or cross-link to other files in the project.</p> <p>Linking to another file? TeXSmith targets the destination\u2019s main heading and drops a proper hyperlink\u2014handy for navigation-friendly PDFs without any manual tinkering.</p> <pre><code>See the [Code Examples](code.md) for more details.\n</code></pre> <p>Skip the link text and TeXSmith injects the section number for the print build automatically. <pre><code>See the section [](code.md) for more details.\n</code></pre></p> <pre><code>## Section Title {#sec:section-title}\n\nPlaceholder text that other sections can reference.\n\n## Other Section\n\nCheck section @[sec:section-title] for more details.\n</code></pre>"},{"location":"syntax/references/#autorefs","title":"Autorefs","text":"<p>When the <code>mkdocs-autorefs</code> extension is enabled, you can use the <code>[text][label]</code> syntax to generate automatic references to headings.</p>"},{"location":"syntax/references/#external-references","title":"External References","text":"<p>Reference external resources (HTTP/HTTPS) with vanilla Markdown link syntax:</p> <pre><code>For more information, visit the [TeXSmith Website](https://texsmith.org).\nYou can also check our GitHub repository at https://github.com/yves-chevallier/texsmith.\n</code></pre> <p>Printed output uses the usual LATEX link commands:</p> <pre><code>For more information, visit the \\href{https://texsmith.org}{TeXSmith Website}.\nYou can also check our GitHub repository at \\url{https://github.com/yves-chevallier/texsmith}.\n</code></pre>"},{"location":"syntax/references/#bibliographic-references","title":"Bibliographic References","text":"<p>Markdown lacks native bibliography support, so TeXSmith reuses the footnote syntax and BibTeX/front matter keys. See the documentation on Bibliography management for more details.</p> <pre><code>---\nbibliography:\n  einstein1905: https://doi.org/10.1002/andp.19053221004\n---\nEinstein's theory of relativity revolutionized physics. [^einstein1905]\n</code></pre>"},{"location":"syntax/references/#footnotes","title":"Footnotes","text":"<p>Use footnotes to park side comments without cluttering the main text. Markdown marks them with superscript numbers; the rendered document moves the details to the bottom of the page or section.</p> <pre><code>This is a sample sentence with a footnote.[^1]\n\n[^1]: This is the footnote text that provides additional information.\n</code></pre> <p>Footnotes are limited to one line in print\u2014keep them tight.</p>"},{"location":"syntax/references/#equations","title":"Equations","text":"<p>You can include mathematical equations in your document using LATEX syntax and use <code>\\label{}</code> to reference them later.</p> <pre><code>\\begin{equation}\nE = mc^2\n\\label{eq:einstein}\n\\end{equation}\n\nAs shown in Equation $\\eqref{eq:einstein}$, energy is equal to mass times the speed of light squared.\n</code></pre> <p>For consistency, TeXSmith provides the shorthand <code>@[label]</code> to reference it.</p> <pre><code>As shown in Equation @[eq:einstein], energy is equal to mass times the speed of light squared.\n</code></pre>"},{"location":"syntax/references/#figures","title":"Figures","text":"<p>Figures are any diagram with a caption and label for cross-references.</p> <pre><code>!!! figure {#fig:sample-figure}\n    ![Sample Figure](image-url.jpg)\n</code></pre> <p>Reference the figure anywhere using its label.</p> <pre><code>As shown in Figure @[fig:sample-figure], the data illustrates...\n</code></pre> <p>Both web and print outputs number figures automatically, though the actual numbers may differ because each layout floats content differently.</p>"},{"location":"syntax/references/#tables","title":"Tables","text":"<p>Tables present structured data; give them a label so you can reference them later.</p> <pre><code>!!! table {#tab:sample-table}\n    | Header 1 | Header 2 |\n    |----------|----------|\n    | Cell 1   | Cell 2   |\n\n    This is a sample table for cross-references.\n\nCheck Table @[tab:sample-table] for more details.\n</code></pre>"},{"location":"syntax/references/#code-block-references","title":"Code Block References","text":"<p>You can reference specific code blocks within your document by assigning them a label.</p> <pre><code>!!! listing {#code:bubble-sort}\n    ```python {#code:bubble-sort}\n    def bubble_sort(items):\n        for i in range(len(items)):\n            for j in range(0, len(items)-i-1):\n                if items[j] &gt; items[j+1]:\n                    items[j], items[j+1] = items[j+1], items[j]\n    ```\n\n    Caption for the bubble sort code block.\n\nListing @[code:bubble-sort] shows the classic bubble sort.\n</code></pre>"},{"location":"syntax/references/#tags-and-index-entries","title":"Tags and Index Entries","text":"<p>Add tags or index entries to associate keywords with specific sections or topics in the document.</p> <pre><code>This section covers advanced sorting algorithms. {index}[algorithm]\n</code></pre> <p>See the section Index / Tags for more details on how to manage index entries.</p>"},{"location":"syntax/references/#naming-conventions","title":"Naming Conventions","text":"<p>Before hypertext, references revolved around numbers: pages, figures, tables, equations.</p> <pre><code>1. Section\n\n  Some Text\n\n  Table 7: An example table\n         +-------+\n         | Table |\n         +-------+\n\n         +--------+\n         | Figure |\n         +--------+\n  Figure 42: An example figure\n\n2. Another Section\n\n  See Table 7 for more details. The Figure 42 illustrates the concept.\n  Everything is explained in Section 1.\n</code></pre>"},{"location":"syntax/references/#french","title":"French","text":"<p>In French, the reference type stays lowercase unless it begins the sentence.</p> <p>Voir le tableau 7 pour plus de d\u00e9tails. La figure 42 illustre le concept. Le tout est expliqu\u00e9 \u00e0 la section 1.</p>"},{"location":"syntax/references/#english","title":"English","text":"<p>In English we capitalize the reference type and skip the article (\u201cTable 7,\u201d not \u201cthe Table 7\u201d).</p> <p>See Table 7 for more details. Figure 42 illustrates the concept. Everything is explained in Section 1.</p>"},{"location":"syntax/references/#german","title":"German","text":"<p>German capitalizes the reference type too.</p> <p>Siehe Tabelle 7 f\u00fcr weitere Details. Abbildung 42 veranschaulicht das Konzept. Alles wird in Abschnitt 1 erkl\u00e4rt.</p>"},{"location":"syntax/smartypants/","title":"Smarty Pants","text":"<p>This extension ports the Python-Markdown SmartyPants behavior. It swaps plain ASCII punctuation for typographically \u201csmart\u201d equivalents\u2014straight quotes become curly quotes, <code>--</code> becomes an en dash, and <code>---</code> turns into an em dash. The substitutions happen in both HTML and LATEX output, so your prose looks polished everywhere.</p>"},{"location":"syntax/supported/","title":"Supported Markdown Syntax","text":"<p>TeXSmith bundles Python-Markdown together with a curated set of PyMdown extensions. The combination lets you author rich documentation while keeping output predictable for LATEX conversion. This page summarizes the syntax you can use out of the box and points to the extension behind each feature.</p> <p>Renderer defaults</p> <p>The CLI and API both enable the exact same extension list defined in <code>texsmith.adapters.markdown.DEFAULT_MARKDOWN_EXTENSIONS</code>. You can always override the list with CLI flags or API options, but the features below are available without additional configuration.</p>"},{"location":"syntax/supported/#core-markdown-always-on","title":"Core Markdown (Always On)","text":"<pre><code># Heading 1\n## Heading 2\n### Heading 3\n\n**bold**, *italic*, ~~strikethrough~~, `inline code`\n\n[Links](https://www.example.com) and ![images](assets/logo.svg)\n\n&gt; Blockquote text\n\n- Unordered item\n  - Nested item\n1. Ordered item\n2. Next item\n\nHorizontal rules:\n---\n</code></pre> <p>All standard Markdown constructs\u2014headings, emphasis, lists, code blocks, blockquotes, links, images, and horizontal rules\u2014render exactly as you would expect. In LATEX output, horizontal rules become <code>\\clearpage</code> page breaks rather than a literal line. TeXSmith relies on fenced code blocks by default, so triple backticks (<code>``</code>) are the recommended way to author code samples.</p>"},{"location":"syntax/supported/#extension-cheat-sheet","title":"Extension Cheat Sheet","text":"Feature Extension Package Example Definition lists <code>def_list</code> <code>markdown</code> <code>Term: Definition</code> Footnotes <code>footnotes</code> <code>markdown</code> <code>Footnote ref[^1]</code> Abbreviations <code>abbr</code> <code>markdown</code> <code>*[HTML]: HyperText Markup Language</code> Admonitions <code>admonition</code> <code>markdown</code> <code>!!! note\u00a0\u00a0Body</code> Attribute lists <code>attr_list</code> <code>markdown</code> <code>![Alt](image.png){ width=\"50%\" }</code> Tables <code>tables</code> <code>markdown</code> Pipe-delimited tables Markdown in HTML <code>md_in_html</code> <code>markdown</code> Markdown inside custom <code>&lt;div&gt;</code> blocks SmartyPants <code>pymdownx.smartsymbols</code> <code>pymdown-extensions</code> Auto-converts quotes/dashes Highlighted code <code>pymdownx.highlight</code> <code>pymdown-extensions</code> Adds syntax highlighting + anchors Inline highlighting <code>pymdownx.inlinehilite</code> <code>pymdown-extensions</code> <code><code>print(\"hi\")</code></code> Details/summary <code>pymdownx.details</code> <code>pymdown-extensions</code> <code>???+ note \"Title\"</code> SuperFences <code>pymdownx.superfences</code> <code>pymdown-extensions</code> Nest code fences safely Task lists <code>pymdownx.tasklist</code> <code>pymdown-extensions</code> <code>- [x] Done</code> Better emphasis <code>pymdownx.betterem</code> <code>pymdown-extensions</code> Fixes edge cases with underscores MagicLink <code>pymdownx.magiclink</code> <code>pymdown-extensions</code> Autolinks URLs/issues Keys <code>pymdownx.keys</code> <code>pymdown-extensions</code> <code>Ctrl+Alt+Del</code> Tabbed content <code>pymdownx.tabbed</code> <code>pymdown-extensions</code> Content tabs Snippets <code>pymdownx.snippets</code> <code>pymdown-extensions</code> Include external Markdown snippets Caret markup <code>pymdownx.caret</code> <code>pymdown-extensions</code> <code>insert</code> Mark (highlight) <code>pymdownx.mark</code> <code>pymdown-extensions</code> <code>highlight</code> Tilde syntax <code>pymdownx.tilde</code> <code>pymdown-extensions</code> Subscript / superscript Critic markup <code>pymdownx.critic</code> <code>pymdown-extensions</code> Editorial annotations Emoji <code>pymdownx.emoji</code> <code>pymdown-extensions</code> <code>:sparkles:</code> or <code>:fontawesome-regular-face-smile:</code> Fancy lists <code>pymdownx.fancylists</code> <code>pymdown-extensions</code> Extended list markers Blocks caption <code>pymdownx.blocks.caption</code> <code>pymdown-extensions</code> Captions for fenced blocks Blocks HTML <code>pymdownx.blocks.html</code> <code>pymdown-extensions</code> Named block wrappers Snippets of LATEX <code>texsmith.extensions.latex_raw</code> bundled Raw LATEX fence Missing footnotes guard <code>texsmith.extensions.missing_footnotes</code> bundled Warns when references lack definitions <p>Want a generated table of contents? Add the Python-Markdown <code>toc</code> extension with <code>-x toc</code> or <code>--enable-extension toc</code>\u2014it is no longer enabled by default.</p> <p>Use the table above as a quick pointer. The following sections provide more context and runnable examples.</p>"},{"location":"syntax/supported/#working-with-admonitions","title":"Working with Admonitions","text":"<pre><code>!!! warning \"LaTeX toolchain\"\n    Remember to install TeX Live, MiKTeX, or MacTeX before running `texsmith --build`.\n</code></pre> <p>Admonitions render as highlighted callouts in HTML and as tcolorbox blocks in the LATEX output. Combine them with tabs or details blocks to create layered walkthroughs.</p>"},{"location":"syntax/supported/#tables-and-definition-lists","title":"Tables and Definition Lists","text":"<pre><code>| Option | Description |\n| ------ | ----------- |\n| `--list-extensions` | Prints enabled Markdown extensions |\n| `--debug` | Shows full tracebacks |\n\nTerm\n: Definition content\n</code></pre> <p>Tables use the Python-Markdown <code>tables</code> extension while definition lists come from <code>def_list</code>. Both convert cleanly into LATEX environments.</p>"},{"location":"syntax/supported/#task-lists-and-checkboxes","title":"Task Lists and Checkboxes","text":"<pre><code>- [x] Validate MkDocs navigation\n- [ ] Document template slots\n</code></pre> <p>Task lists automatically render checkboxes in HTML. In LATEX they become custom itemize entries with inline symbols.</p>"},{"location":"syntax/supported/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<pre><code>Use ++ctrl+s++ to save changes and ++ctrl+shift+b++ to build the docs.\n</code></pre> <p>The <code>pymdownx.keys</code> extension turns the markup above into keyboard glyphs, which carry across to PDFs through the TeXSmith formatter.</p>"},{"location":"syntax/supported/#embedding-raw-latex","title":"Embedding Raw LATEX","text":"<p>Use the <code>/// latex</code> fence when native LATEX is required:</p> <pre><code>/// latex\n\\begin{align}\nE &amp;= mc^2 \\\\\n\\nabla \\cdot \\vec{E} &amp;= \\frac{\\rho}{\\varepsilon_0}\n\\end{align}\n///\n</code></pre> <p>TeXSmith passes the block straight to the renderer, letting you mix handcrafted LATEX with converted Markdown content. For inline adjustments, drop <code>{latex}[commands]</code> right into the paragraph:</p> <pre><code>The chapter ends here {latex}[\\clearpage] before appendices.\n</code></pre>"},{"location":"syntax/supported/#snippet-includes","title":"Snippet Includes","text":"<p>The <code>pymdownx.snippets</code> extension lets you avoid duplication:</p> <pre><code>--8&lt;-- \"includes/built-in-tasks.md\"\n</code></pre> <p>Create an <code>includes</code> directory under <code>docs/</code> and share fragments across pages. The same mechanism can pull example Markdown from the samples used in automated tests, keeping docs and fixtures aligned.</p>"},{"location":"syntax/supported/#when-you-need-more","title":"When You Need More","text":"<ul> <li>Use <code>texsmith --list-extensions</code> to see the live extension list.</li> <li>Disable or add extensions via the <code>--enable-extension</code> and <code>--disable-extension</code>   flags in <code>texsmith</code> or through <code>ConversionRequest.markdown_extensions</code>   in the API.</li> <li>If a feature relies on a third-party executable (for example Mermaid to PDF),   make sure the binary is available on the build worker before running   <code>texsmith --build</code>.</li> </ul> <p>With these extensions enabled, TeXSmith can faithfully render everything from simple README-style guides to complex, reference-heavy manuals.</p>"},{"location":"syntax/tables/","title":"Tables","text":"Column 1 Col 2 Big row span r1_c1 spans two cols {rspan} One large cell r2_c1 spans two rows r2_c2 {cspan} r3_c2 r4_c2 {cspan} <p>LATEX tables get fancy fast: row/column spans, width constraints, captions, labels, alignment tweaks. Stock Markdown only handles the basics, so TeXSmith extends the syntax to cover:</p> <ul> <li>Row and column spans (<code>{rspan}</code>, <code>{cspan}</code>)</li> <li>Automatic cell wrapping</li> <li>Full-width tables with custom column widths</li> <li>Captions + labels for cross-references</li> <li>Per-column alignment</li> </ul>"},{"location":"syntax/tables/#metadata-approach","title":"Metadata approach","text":"<p>Attach a metadata block immediately before the Markdown table to describe layout hints:</p> <pre><code>```yml { .meta-table }\nwidth: 100%\nalign: center\ncolumns:\n  - align: center\n  - align: right\n  - align: left\n```\n</code></pre>"},{"location":"syntax/tables/#code-block-definition","title":"Code block definition","text":"<p>Alternatively, describe the table entirely through a fenced code block marked with <code>.table</code>:</p> <pre><code>```yml { .table }\nwidth: 100%\nspan:\nalignment:\n  - center\n  - right\n  - left\ntable:\n  - [ \"Column 1\", \"Col 2\", \"Big row span\" ]\n  - [ {rspan}, \"r1_c1 spans two cols\", \"One large cell\" ]\n  - [ \"r2_c1 spans two rows\", \"r2_c2\", \"\" ]\n  - [ {cspan}, \"\", \"\" ]\n  - [ \"\", \"r4_c2\", {cspan} ]\n```\n</code></pre>"},{"location":"syntax/wikilinks/","title":"Wiki Links","text":"<p>MkDocs and Python-Markdown support the <code>[[Wiki Link]]</code> syntax via the <code>wikilinks</code> extension. TeXSmith keeps that behavior so you can link between pages without remembering exact file paths.</p> <pre><code>[[Getting Started]]\n[[Subfolder/Page Title|Custom label]]\n</code></pre> <ul> <li>The portion before the pipe resolves to a Markdown file (<code>Getting Started</code> \u2192   <code>getting-started.md</code>).</li> <li>Anything after <code>|</code> becomes the rendered link text.</li> <li>When building PDFs, TeXSmith turns wiki links into standard hyperlinks, so the   references remain navigable.</li> </ul>"}]}